diff --git a/.gitignore b/.gitignore
index a245636..5705816 100644
--- a/.gitignore
+++ b/.gitignore
@@ -25,6 +25,8 @@ install-sh
 libtool
 *.lo
 ltmain.sh
+Makefile
+Makefile.in
 missing
 moc_*.cpp
 *.o
diff --git a/BoxBrandingTest.py b/BoxBrandingTest.py
index 8bdb0ce..ccd6486 100644
--- a/BoxBrandingTest.py
+++ b/BoxBrandingTest.py
@@ -21,5 +21,25 @@ print "getImageType=%s<" %boxbranding.getImageType()
 print "getImageDistro=%s<" %boxbranding.getImageDistro()
 print "getImageFolder=%s<" %boxbranding.getImageFolder()
 print "getImageFileSystem=%s<" %boxbranding.getImageFileSystem()
+print "getImageDevBuild=%s<" %boxbranding.getImageDevBuild()
+print "getImageType=%s<" %boxbranding.getImageType()
+print "getMachineMake=%s<" %boxbranding.getMachineMake()
 print "getImageArch=%s<" %boxbranding.getImageArch()
+print "getFeedsUrl=%s<" %boxbranding.getFeedsUrl()
+print "getDisplayType=%s<" %boxbranding.getDisplayType()
+print "getHaveHDMI=%s<" %boxbranding.getHaveHDMI()
+print "getHaveYUV=%s<" %boxbranding.getHaveYUV()
+print "getHaveRCA=%s<" %boxbranding.getHaveRCA()
+print "getHaveAVJACK=%s<" %boxbranding.getHaveAVJACK()
+print "getHaveSCART=%s<" %boxbranding.getHaveSCART()
+print "getHaveSCARTYUV=%s<" %boxbranding.getHaveSCARTYUV()
+print "getHaveDVI=%s<" %boxbranding.getHaveDVI()
+print "getHaveMiniTV=%s<" %boxbranding.getHaveMiniTV()
+print "getHaveHDMIinHD=%s<" %boxbranding.getHaveHDMIinHD()
+print "getHaveHDMIinFHD=%s<" %boxbranding.getHaveHDMIinFHD()
+print "getHaveWOL=%s<" %boxbranding.getHaveWOL()
+print "getHaveWWOL=%s<" %boxbranding.getHaveWWOL()
+print "getHaveTranscoding1=%s<" %boxbranding.getHaveTranscoding1()
+print "getHaveTranscoding2=%s<" %boxbranding.getHaveTranscoding2()
+print "getHaveCI=%s<" %boxbranding.getHaveCI()
 
diff --git a/Navigation.py b/Navigation.py
index 54a7513..037cd9f 100644
--- a/Navigation.py
+++ b/Navigation.py
@@ -36,6 +36,9 @@ class Navigation:
 		self.currentlyPlayingServiceOrGroup = None
 		self.currentlyPlayingService = None
 
+		Screens.Standby.TVstate()
+		self.skipWakeup = False
+
 		self.RecordTimer = None
 		self.isRecordTimerImageStandard = False
 		for p in plugins.getPlugins(PluginDescriptor.WHERE_RECORDTIMER):
@@ -53,81 +56,87 @@ class Navigation:
 		self.__wasPowerTimerWakeup = False
 
 		#wakeup data
+		now = time()
 		try:
-			self.wakeuptime, self.timertime, self.wakeuptyp, self.getstandby, self.recordtime, self.forcerecord = [int(n) for n in wakeupData.split(',')]
+			self.lastshutdowntime, self.wakeuptime, self.timertime, self.wakeuptyp, self.getstandby, self.recordtime, self.forcerecord = [int(n) for n in wakeupData.split(',')]
 		except:
 			print "="*100
 			print "[NAVIGATION] ERROR: can't read wakeup data"
-			self.wakeuptime, self.timertime, self.wakeuptyp, self.getstandby, self.recordtime, self.forcerecord = -1,-1,0,0,-1,0
-		#print ctime(self.wakeuptime), ctime(self.timertime), self.wakeuptyp, self.getstandby, ctime(self.recordtime), self.forcerecord
-		now = time()
-		self.wakeupwindow_plus = self.timertime + 300
-		self.wakeupwindow_minus = self.wakeuptime - (config.workaround.wakeupwindow.value * 60)
+			self.lastshutdowntime, self.wakeuptime, self.timertime, self.wakeuptyp, self.getstandby, self.recordtime, self.forcerecord = int(now),-1,-1,0,0,-1,0
 		self.syncCount = 0
-
+		hasFakeTime = (now <= 31536000 or now - self.lastshutdowntime <= 120) and self.getstandby < 2 #set hasFakeTime only if lower than values and was last shutdown to deep standby
 		wasTimerWakeup, wasTimerWakeup_failure = getFPWasTimerWakeup(True)
 		#TODO: verify wakeup-state for boxes where only after shutdown removed the wakeup-state (for boxes where "/proc/stb/fp/was_timer_wakeup" is not writable (clearFPWasTimerWakeup() in StbHardware.py has no effect -> after x hours and restart/reboot is wasTimerWakeup = True)
 
+		if 0: #debug
+			print "#"*100
+			print "[NAVIGATION] timediff from last shutdown to now = %ds" %(now - self.lastshutdowntime)
+			print "[NAVIGATION] shutdowntime: %s, wakeuptime: %s timertime: %s, recordtime: %s" %(ctime(self.lastshutdowntime), ctime(self.wakeuptime), ctime(self.timertime), ctime(self.recordtime))
+			print "[NAVIGATION] wakeuptyp: %s, getstandby: %s, forcerecord: %s" %({0:"record-timer",1:"zap-timer",2:"power-timer",3:"plugin-timer"}[self.wakeuptyp],{0:"no standby",1:"standby",2:"no standby (box was not in deepstandby)"}[self.getstandby],self.forcerecord)
+			print "#"*100
+
 		print "="*100
-		if self.wakeuptime > 0: 
-			print "[NAVIGATION] wakeup time from deep-standby expected: *** %s ***" %(ctime(self.wakeuptime))
-			print "-"*100
+		print "[NAVIGATION] was timer wakeup = %s" %wasTimerWakeup
+		print "[NAVIGATION] current time is %s -> it's fake-time suspected: %s" %(ctime(now),hasFakeTime)
+		print "-"*100
+
 		thisBox = getBoxType()
 		if not config.workaround.deeprecord.value and (wasTimerWakeup_failure or thisBox in ('ixussone', 'uniboxhd1', 'uniboxhd2', 'uniboxhd3', 'sezam5000hd', 'mbtwin', 'beyonwizt3', 'et8000') or getBrandOEM() in ('ebox', 'azbox', 'xp', 'ini', 'fulan', 'entwopia') or getMachineBuild() in ('dags7335' , 'dags7356', 'dags7362')):
 			print"[NAVIGATION] FORCED DEEPSTANDBY-WORKAROUND FOR THIS BOXTYPE (%s)" %thisBox
+			print "-"*100
 			config.workaround.deeprecord.setValue(True)
 			config.workaround.deeprecord.save()
 			config.save()
 
 		if config.workaround.deeprecord.value: #work-around for boxes where driver not sent was_timer_wakeup signal to e2
-			wasTimerWakeup = False
 			print "[NAVIGATION] starting deepstandby-workaround"
-			print "[NAVIGATION] timer wakeup detection window: %s - %s" %(ctime(self.wakeupwindow_minus),ctime(self.wakeupwindow_plus))
-			if now <= 31536000: # check for NTP-time sync, if no sync, wait for transponder time
-				self.timesynctimer = eTimer()
-				self.timesynctimer.callback.append(self.TimeSynctimer)
-				self.timesynctimer.start(5000, True)
-				print"[NAVIGATION] wait for time sync"
-				print "~"*100
-			elif now >= self.wakeupwindow_minus and now <= self.wakeupwindow_plus: # if there is a recording sheduled, set the wasTimerWakeup flag
+			self.wakeupwindow_plus = self.timertime + 300
+			self.wakeupwindow_minus = self.wakeuptime - (config.workaround.wakeupwindow.value * 60)
+			wasTimerWakeup = False
+			if not hasFakeTime and now >= self.wakeupwindow_minus and now <= self.wakeupwindow_plus: # if there is a recording sheduled, set the wasTimerWakeup flag
 				wasTimerWakeup = True
 				f = open("/tmp/was_timer_wakeup_workaround.txt", "w")
 				file = f.write(str(wasTimerWakeup))
 				f.close()
+		else:
+			#secure wakeup window to prevent a wrong 'wasTimerWakeup' value as timer wakeup detection
+			self.wakeupwindow_plus = self.timertime + 900
+			self.wakeupwindow_minus = self.wakeuptime - 3600
 
-		print "[NAVIGATION] was timer wakeup = %s" % wasTimerWakeup
-		print "[NAVIGATION] current time is %s" % ctime(now)
+		if self.wakeuptime > 0:
+			print "[NAVIGATION] wakeup time from deep-standby expected: *** %s ***" %(ctime(self.wakeuptime))
+			if config.workaround.deeprecord.value:
+				print "[NAVIGATION] timer wakeup detection window: %s - %s" %(ctime(self.wakeupwindow_minus),ctime(self.wakeupwindow_plus))
+		else:
+			print "[NAVIGATION] wakeup time was not set"
+		print "-"*100
 
 		if wasTimerWakeup:
 			self.__wasTimerWakeup = True
-			print "-"*100
-			if self.wakeuptime > 0:
-				print "[NAVIGATION] wakeup time was %s" % ctime(self.wakeuptime)
-			else:
-				print "[NAVIGATION] wakeup time was not set"
-			if now <= 31536000:
-				self.timesynctimer = eTimer()
-				self.timesynctimer.callback.append(self.TimeSynctimer)
-				self.timesynctimer.start(5000, True)
-				print"[NAVIGATION] wait for time sync"
-				print "~"*100
-			else:
+			if not hasFakeTime:
 				self.wakeupCheck()
+				return
+
+		if hasFakeTime and self.wakeuptime > 0: # check for NTP-time sync, if no sync, wait for transponder time
+			if Screens.Standby.TVinStandby.getTVstandby('waitfortimesync') and not wasTimerWakeup:
+				Screens.Standby.TVinStandby.setTVstate('power')
+			self.savedOldTime = now
+			self.timesynctimer = eTimer()
+			self.timesynctimer.callback.append(self.TimeSynctimer)
+			self.timesynctimer.start(5000, True)
+			print"[NAVIGATION] wait for time sync"
+			print "~"*100
 		else:
-			if now > 31536000:
-				if self.timertime > 0:
-					print "[NAVIGATION] next '%s' starts at %s" % ({0:"record-timer",1:"zap-timer",2:"power-timer",3:"plugin-timer"}[self.wakeuptyp], ctime(self.timertime))
-				else:
-					print "[NAVIGATION] no next timers"
-				print "="*100
+			self.wakeupCheck(False)
 
-	def wakeupCheck(self):
+	def wakeupCheck(self, runCheck = True):
 		now = time()
-		stbytimer = 5 # original was 15
+		stbytimer = 15 # original was 15
 
-		if self.__wasTimerWakeup or (config.workaround.deeprecord.value and now >= self.wakeupwindow_minus and now <= self.wakeupwindow_plus):
+		if runCheck and ((self.__wasTimerWakeup or config.workaround.deeprecord.value) and now >= self.wakeupwindow_minus and now <= self.wakeupwindow_plus):
 			if self.syncCount > 0:
-				stbytimer = 0
+				stbytimer = stbytimer - (self.syncCount * 5)
+				if stbytimer < 0: stbytimer = 0
 				if not self.__wasTimerWakeup:
 					self.__wasTimerWakeup = True
 					print "-"*100
@@ -158,9 +167,14 @@ class Navigation:
 				if not self.forcerecord:
 					print "[NAVIGATION] timer starts at %s" % ctime(self.timertime)
 			#check for standby
-			if not self.getstandby and self.wakeuptyp < 3 and self.timertime - now > 60 + stbytimer:
+			cec =  ((self.wakeuptyp == 0 and (Screens.Standby.TVinStandby.getTVstandby('zapandrecordtimer'))) or 
+					(self.wakeuptyp == 1 and (Screens.Standby.TVinStandby.getTVstandby('zaptimer'))) or
+					(self.wakeuptyp == 2 and (Screens.Standby.TVinStandby.getTVstandby('wakeuppowertimer'))))
+			if self.getstandby != 1 and ((self.wakeuptyp < 3 and self.timertime - now > 60 + stbytimer) or cec):
 				self.getstandby = 1
-				print "[NAVIGATION] more than 60 seconds to wakeup - go in standby"
+				txt = ""
+				if cec: txt = "... or special hdmi-cec settings"
+				print "[NAVIGATION] more than 60 seconds to wakeup%s - go in standby now" %txt
 			print "="*100
 			#go in standby
 			if self.getstandby == 1:
@@ -171,17 +185,24 @@ class Navigation:
 				else:
 					self.gotostandby()
 		else:
+			if self.__wasTimerWakeup:
+				print '+'*100
+				print "[NAVIGATION] wrong signal 'was timer wakeup' detected - please activate the deep standby workaround."
+				print "[NAVIGATION] secure timer wakeup detection window: %s - %s" %(ctime(self.wakeupwindow_minus),ctime(self.wakeupwindow_plus))
+				print '+'*100
 			if self.timertime > 0:
-				print "[NAVIGATION] no timers in the time window, next '%s' starts at %s" % ({0:"record-timer",1:"zap-timer",2:"power-timer",3:"plugin-timer"}[self.wakeuptyp], ctime(self.timertime))
+				print "[NAVIGATION] next '%s' starts at %s" % ({0:"record-timer",1:"zap-timer",2:"power-timer",3:"plugin-timer"}[self.wakeuptyp], ctime(self.timertime))
 				if self.recordtime > 0 and self.timertime != self.recordtime:
 					print "[NAVIGATION] next 'record-timer' starts at %s" % ctime(self.recordtime)
 				else:
 					print "[NAVIGATION] no next 'record-timer'"
+			else:
+				print "[NAVIGATION] no next timer"
 			print "="*100
 			self.getstandby = 0
 
 		#workaround for normal operation if no time sync after e2 start - box is in standby
-		if self.getstandby != 1:
+		if self.getstandby != 1 and not self.skipWakeup:
 			self.gotopower()
 
 	def wasTimerWakeup(self):
@@ -196,26 +217,23 @@ class Navigation:
 	def TimeSynctimer(self):
 		now = time()
 		self.syncCount += 1
+		runNextSync = now <= 31536000 or now - (self.savedOldTime + (self.syncCount * 5)) <= 10
 
-		if now <= 31536000:
-			if self.syncCount <= 24 and now <= 31536000: # max 2 mins or when time is in sync
+		result = "successful"
+		if runNextSync:
+			if self.syncCount <= 24: # max 2 mins or when time is in sync
 				self.timesynctimer.start(5000, True)
+				return
 			else:
-				print "~"*100
-				print "[NAVIGATION] time sync failure, current time is %s, sync time is %s sec." % (ctime(now),(self.syncCount * 5))
-				if self.timertime > 0:
-					print "[NAVIGATION] next '%s' starts at %s" % ({0:"record-timer",1:"zap-timer",2:"power-timer",3:"plugin-timer"}[self.wakeuptyp], ctime(self.timertime))
-				else:
-					print "[NAVIGATION] no next timers"
-				print "="*100
-				#workaround for normal operation if no time sync after e2 start - box is in standby
-				self.gotopower()
-		else:
-			print "~"*100
-			print "[NAVIGATION] time sync successful, current time is %s, sync time is %s sec." % (ctime(now),(self.syncCount * 5))
-			self.wakeupCheck()
+				result = "failure or the time was correct"
+
+		print "~"*100
+		print "[NAVIGATION] time sync %s, current time is %s, sync time is %s sec." % (result,ctime(now),((self.syncCount) * 5))
+		self.wakeupCheck()
 
 	def gotopower(self):
+		if not Screens.Standby.TVinStandby.getTVstate('on'):
+			Screens.Standby.TVinStandby.setTVstate('power')
 		if Screens.Standby.inStandby:
 			print '[NAVIGATION] now entering normal operation'
 			Screens.Standby.inStandby.Power()
diff --git a/PowerTimer.py b/PowerTimer.py
index f70ce0b..61619a9 100644
--- a/PowerTimer.py
+++ b/PowerTimer.py
@@ -95,6 +95,10 @@ class PowerTimerEntry(timer.TimerEntry, object):
 			if self.begin < time() - 1209600:
 				self.begin = int(time())
 
+		#check autopowertimer
+		if (timerType == TIMERTYPE.AUTOSTANDBY or timerType == TIMERTYPE.AUTODEEPSTANDBY) and not disabled and time() > 3600 and self.begin > time():
+			self.begin = int(time())						#the begin is in the future -> set to current time = no start delay of this timer
+
 		if self.end < self.begin:
 			self.end = self.begin
 
@@ -124,11 +128,7 @@ class PowerTimerEntry(timer.TimerEntry, object):
 
 		self.messageBoxAnswerPending = False
 
-		#check autopowertimer
-		if (self.timerType == TIMERTYPE.AUTOSTANDBY or self.timerType == TIMERTYPE.AUTODEEPSTANDBY) and not self.disabled and time() > 3600 and self.begin > time():
-			self.begin = int(time())						#the begin is in the future -> set to current time = no start delay of this timer
-
-	def __repr__(self):
+	def __repr__(self, getType = False):
 		timertype = {
 			TIMERTYPE.NONE: "nothing",
 			TIMERTYPE.WAKEUP: "wakeup",
@@ -140,6 +140,7 @@ class PowerTimerEntry(timer.TimerEntry, object):
 			TIMERTYPE.REBOOT: "reboot",
 			TIMERTYPE.RESTART: "restart"
 			}[self.timerType]
+		if getType: return timertype
 		if not self.disabled:
 			return "PowerTimerEntry(type=%s, begin=%s)" % (timertype, ctime(self.begin))
 		else:
@@ -193,16 +194,24 @@ class PowerTimerEntry(timer.TimerEntry, object):
 			if self.timerType == TIMERTYPE.AUTODEEPSTANDBY:
 				self.getNetworkTraffic(getInitialValue = True)
 
-		if (next_state == self.StateRunning or next_state == self.StateEnded) and NavigationInstance.instance.PowerTimer is None:
-			#TODO: running/ended timer at system start has no nav instance
-			#First fix: crash in getPriorityCheck (NavigationInstance.instance.PowerTimer...)
-			#Second fix: suppress the message (A finished powertimer wants to ...)
-			if debug: print "*****NavigationInstance.instance.PowerTimer is None*****", self.timerType, self.state, ctime(self.begin), ctime(self.end)
-			return True
-		elif next_state == self.StateRunning and abs(self.begin - now) > 900: return True
-		elif next_state == self.StateEnded and abs(self.end - now) > 900: return True
-
 		if next_state == self.StateRunning or next_state == self.StateEnded:
+			if NavigationInstance.instance.PowerTimer is None:
+				#TODO: running/ended timer at system start has no nav instance
+				#First fix: crash in getPriorityCheck (NavigationInstance.instance.PowerTimer...)
+				#Second fix: suppress the message (A finished powertimer wants to ...)
+				if debug: print "*****NavigationInstance.instance.PowerTimer is None*****", self.timerType, self.state, ctime(self.begin), ctime(self.end)
+				return True
+			elif (next_state == self.StateRunning and abs(self.begin - now) > 900) or (next_state == self.StateEnded and abs(self.end - now) > 900):
+				if self.timerType == TIMERTYPE.AUTODEEPSTANDBY or self.timerType == TIMERTYPE.AUTOSTANDBY:
+					print '[Powertimer] time warp detected - set new begin time for %s timer' %self.__repr__(True)
+					if not self.getAutoSleepWindow():
+						return False
+					else:
+						self.begin = self.end = int(now) + int(self.autosleepdelay)*60
+						return False
+				print '[Powertimer] time warp detected - timer %s ending without action' %self.__repr__(True)
+				return True
+
 			if NavigationInstance.instance.isRecordTimerImageStandard:
 				isRecTimerWakeup = NavigationInstance.instance.RecordTimer.isRecTimerWakeup()
 			if isRecTimerWakeup:
@@ -229,6 +238,7 @@ class PowerTimerEntry(timer.TimerEntry, object):
 
 			elif self.timerType == TIMERTYPE.WAKEUP:
 				if debug: print "self.timerType == TIMERTYPE.WAKEUP:"
+				Screens.Standby.TVinStandby.skipHdmiCecNow('wakeuppowertimer')
 				if Screens.Standby.inStandby:
 					Screens.Standby.inStandby.Power()
 				return True
@@ -517,6 +527,7 @@ class PowerTimerEntry(timer.TimerEntry, object):
 
 		elif next_state == self.StateEnded:
 			if self.afterEvent == AFTEREVENT.WAKEUP:
+				Screens.Standby.TVinStandby.skipHdmiCecNow('wakeuppowertimer')
 				if Screens.Standby.inStandby:
 					Screens.Standby.inStandby.Power()
 			elif self.afterEvent == AFTEREVENT.STANDBY:
diff --git a/RecordTimer.py b/RecordTimer.py
index 8059ed5..198ec9b 100644
--- a/RecordTimer.py
+++ b/RecordTimer.py
@@ -30,11 +30,16 @@ from enigma import pNavigation, eDVBFrontend
 # event data		 (ONLY for time adjustments etc.)
 
 wasRecTimerWakeup = False
-try:
-	from Screens.InfoBar import InfoBar
-except Exception, e:
-	print "[RecordTimer] import from 'Screens.InfoBar import InfoBar' failed:", e
-	InfoBar = False
+InfoBar = False
+
+#//import later (no error message on system start)
+#try:
+#	from Screens.InfoBar import InfoBar
+#except Exception, e:
+#	print "[RecordTimer] import from 'Screens.InfoBar import InfoBar' failed:", e
+#	InfoBar = False
+#//
+
 #+++
 debug = False
 #+++
@@ -386,6 +391,7 @@ class RecordTimerEntry(timer.TimerEntry, object):
 				return True
 
 			if self.always_zap:
+				Screens.Standby.TVinStandby.skipHdmiCecNow('zapandrecordtimer')
 				if Screens.Standby.inStandby:
 					self.wasInStandby = True
 					#eActionMap.getInstance().bindAction('', -maxint - 1, self.keypress)
@@ -398,8 +404,6 @@ class RecordTimerEntry(timer.TimerEntry, object):
 				else:
 					cur_zap_ref = NavigationInstance.instance.getCurrentlyPlayingServiceReference()
 					if cur_zap_ref and not cur_zap_ref.getPath():# we do not zap away if it is no live service
-						self.messageString += _("The TV was switched to the recording service!\n")
-						self.messageStringShow = True
 						self.setRecordingPreferredTuner()
 						self.failureCB(True)
 						self.log(5, "zap to recording service")
@@ -565,6 +569,7 @@ class RecordTimerEntry(timer.TimerEntry, object):
 				return True
 
 			if self.justplay:
+				Screens.Standby.TVinStandby.skipHdmiCecNow('zaptimer')
 				if Screens.Standby.inStandby:
 					self.wasInStandby = True
 					#eActionMap.getInstance().bindAction('', -maxint - 1, self.keypress)
@@ -609,7 +614,6 @@ class RecordTimerEntry(timer.TimerEntry, object):
 									notFound = True
 									break
 
-
 								if bouquet.flags & eServiceReference.isDirectory:
 									ChannelSelectionInstance.clearPath()
 									ChannelSelectionInstance.setRoot(bouquet)
@@ -664,21 +668,26 @@ class RecordTimerEntry(timer.TimerEntry, object):
 					self.record_service = None
 
 			NavigationInstance.instance.RecordTimer.saveTimer()
-			self.autostate = Screens.Standby.inStandby
+
+			box_instandby = Screens.Standby.inStandby
+			tv_notactive = Screens.Standby.TVinStandby.getTVstate('notactive')
 			isRecordTime = abs(NavigationInstance.instance.RecordTimer.getNextRecordingTime() - time()) <= 900 or NavigationInstance.instance.RecordTimer.getStillRecording()
-			if debug: print "[RECORDTIMER] self.autostate=%s" % self.autostate, "wasRecTimerWakeup=%s" % wasRecTimerWakeup, "self.wasInStandby=%s" % self.wasInStandby, "self.afterEvent=%s" % self.afterEvent
 
+			if debug: print "[RECORDTIMER] box_instandby=%s" % box_instandby, "tv_notactive=%s" % tv_notactive, "wasRecTimerWakeup=%s" % wasRecTimerWakeup, "self.wasInStandby=%s" % self.wasInStandby, "self.afterEvent=%s" % self.afterEvent, "isRecordTime=%s" % isRecordTime
+
+			timeout = 180
+			default = True
+			messageboxtyp = MessageBox.TYPE_YESNO
 			if self.afterEvent == AFTEREVENT.STANDBY or (self.afterEvent == AFTEREVENT.AUTO and self.wasInStandby and (not wasRecTimerWakeup or (wasRecTimerWakeup and isRecordTime))):
-				if not Screens.Standby.inStandby: # not already in standby
+				if not box_instandby and not tv_notactive:# not already in standby
 					callback = self.sendStandbyNotification
 					message = _("A finished record timer wants to set your\n%s %s to standby. Do that now?") % (getMachineBrand(), getMachineName())
-					messageboxtyp = MessageBox.TYPE_YESNO
-					timeout = 180
-					default = True
 					if InfoBar and InfoBar.instance:
 						InfoBar.instance.openInfoBarMessageWithCallback(callback, message, messageboxtyp, timeout, default)
 					else:
 						Notifications.AddNotificationWithCallback(callback, MessageBox, message, messageboxtyp, timeout = timeout, default = default)
+				elif not box_instandby:
+					self.sendStandbyNotification(True)
 
 			if isRecordTime or abs(NavigationInstance.instance.RecordTimer.getNextZapTime() - time()) <= 900:
 				if self.afterEvent == AFTEREVENT.DEEPSTANDBY or (wasRecTimerWakeup and self.afterEvent == AFTEREVENT.AUTO and self.wasInStandby) or (self.afterEvent == AFTEREVENT.AUTO and wasRecTimerWakeup):
@@ -694,25 +703,21 @@ class RecordTimerEntry(timer.TimerEntry, object):
 
 			if self.afterEvent == AFTEREVENT.DEEPSTANDBY or (wasRecTimerWakeup and self.afterEvent == AFTEREVENT.AUTO and self.wasInStandby):
 				if not Screens.Standby.inTryQuitMainloop: # no shutdown messagebox is open
-					if Screens.Standby.inStandby: # in standby
-						print "[RecordTimer] quitMainloop #1"
-						quitMainloop(1)
-					else:
+					if not box_instandby and not tv_notactive: # not already in standby
 						callback = self.sendTryQuitMainloopNotification
 						message = _("A finished record timer wants to shut down\nyour %s %s. Shutdown now?") % (getMachineBrand(), getMachineName())
-						messageboxtyp = MessageBox.TYPE_YESNO
-						timeout = 180
-						default = True
 						if InfoBar and InfoBar.instance:
 							InfoBar.instance.openInfoBarMessageWithCallback(callback, message, messageboxtyp, timeout, default)
 						else:
 							Notifications.AddNotificationWithCallback(callback, MessageBox, message, messageboxtyp, timeout = timeout, default = default)
+					else:
+						print "[RecordTimer] quitMainloop #1"
+						quitMainloop(1)
 			elif self.afterEvent == AFTEREVENT.AUTO and wasRecTimerWakeup:
 				if not Screens.Standby.inTryQuitMainloop: # no shutdown messagebox is open
 					if Screens.Standby.inStandby: # in standby
 						print "[RecordTimer] quitMainloop #2"
 						quitMainloop(1)
-
 			self.wasInStandby = False
 			resetTimerWakeup()
 			return True
diff --git a/configure.ac b/configure.ac
index 1a5c0f0..5a5f836 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,4 +1,4 @@
-AC_INIT([enigma2],[2.1],[http://www.open-plus.es])
+AC_INIT([enigma2],[6.1],[http://www.opena.tv])
 AM_INIT_AUTOMAKE([dist-bzip2 no-define tar-pax -Wno-portability])
 AC_CONFIG_HEADERS([enigma2_config.h])
 
@@ -192,16 +192,63 @@ AM_CONDITIONAL(VUUNO4KSE, test "$BOXTYPE" == vuuno4kse)
 AM_CONDITIONAL(VUULTIMO4K, test "$BOXTYPE" == vuultimo4k)
 AM_CONDITIONAL(VUZERO4K, test "$BOXTYPE" == vuzero4k)
 AM_CONDITIONAL(VUDUO2, test "$BOXTYPE" == vuduo2)
+AM_CONDITIONAL(VUDUO4K, test "$BOXTYPE" == vuduo4k)
 AM_CONDITIONAL(VUZERO, test "$BOXTYPE" == vuzero)
 AM_CONDITIONAL(VENTONHDX, test "$BOXTYPE" == ventonhdx)
 AM_CONDITIONAL(XP1000, test "$BOXTYPE" == xp1000)
-AM_CONDITIONAL(HAVE_WETEK_XBMC, test "$BOXTYPE" == wetekplay)
+AM_CONDITIONAL(HAVE_KODI, test "$BOXTYPE" == wetekplay -o "$BOXTYPE" == wetekplay2 -o "$BOXTYPE" == alien5)
 AM_CONDITIONAL(HAVE_COLORLCD3, test "$BOXTYPE" == dm7080)
 AM_CONDITIONAL(HAVE_COLORLCD2, test "$BOXTYPE" == dm800se -o "$BOXTYPE" == dm800sev2 -o "$BOXTYPE" == dm820)
 AM_CONDITIONAL(HAVE_COLORLCD1, test "$BOXTYPE" == dm8000 -o "$BOXTYPE" == dm800 -o "$BOXTYPE" == dm7020hd -o "$BOXTYPE" == dm7020hdv2)
 AM_CONDITIONAL(HAVE_GRAUTEC8000, test "$BOXTYPE" == dm8000)
 AM_CONDITIONAL(HAVE_GRAUTEC70X0, test "$BOXTYPE" == dm7020hd -o "$BOXTYPE" == dm7020hdv2 -o "$BOXTYPE" == dm7080)
 
+AC_ARG_WITH(accelerationthreshold,
+	AC_HELP_STRING([--with-accelerationthreshold=n], [use acceleration threshold of n bytes]),
+	[[with_accelerationthreshold=$withval]],
+	[[with_accelerationthreshold=48000]]
+)
+
+AC_DEFINE_UNQUOTED(GFX_SURFACE_ACCELERATION_THRESHOLD, $with_accelerationthreshold,[Configure threshold for accelerated surfaces (in bytes)])
+
+AC_ARG_WITH(fillaccelerationthreshold,
+	AC_HELP_STRING([--with-fillaccelerationthreshold=n], [use fill acceleration threshold of n bytes]),
+	[[with_fillaccelerationthreshold=$withval]],
+	[[with_fillaccelerationthreshold=80000]]
+)
+
+AC_DEFINE_UNQUOTED(GFX_SURFACE_FILL_ACCELERATION_THRESHOLD, $with_fillaccelerationthreshold,[Configure threshold for accelerated fill operations (in bytes)])
+
+AC_ARG_WITH(blitaccelerationthreshold,
+	AC_HELP_STRING([--with-blitaccelerationthreshold=n], [use blit acceleration threshold of n bytes]),
+	[[with_blitaccelerationthreshold=$withval]],
+	[[with_blitaccelerationthreshold=0]]
+)
+
+AC_DEFINE_UNQUOTED(GFX_SURFACE_BLIT_ACCELERATION_THRESHOLD, $with_blitaccelerationthreshold,[Configure threshold for accelerated blit operations (in bytes)])
+
+AC_ARG_WITH(alphablendingacceleration,
+	AC_HELP_STRING([--with-alphablendingacceleration=never/always/auto], [alphablending acceleration strategy: never accelerate / always accelerate / automatically decide when to accelerate (default)]),
+	[[with_alphablendingacceleration=$withval]],
+	[[with_alphablendingacceleration=auto]]
+)
+
+if test x"$with_alphablendingacceleration" = xnever ; then
+	AC_DEFINE_UNQUOTED(FORCE_NO_BLENDING_ACCELERATION, 1, [Do not attempt to accelerate alphablending blits])
+elif test x"$with_alphablendingacceleration" = xalways ; then
+	AC_DEFINE_UNQUOTED(FORCE_ALPHABLENDING_ACCELERATION, 1, [Accelerate alphablending blits])
+fi
+
+AC_ARG_WITH(accelerationaccumulation,
+	AC_HELP_STRING([--with-accelerationaccumulation], [accumulate blit/fill acceleration operations]),
+	[[with_accelerationaccumulation=$withval]],
+	[[with_accelerationaccumulation=no]]
+)
+
+if test x"$with_accelerationaccumulation" = xyes ; then
+	AC_DEFINE(SUPPORT_ACCUMULATED_ACCELERATION_OPERATIONS, 1,[Accumulate blit/fill acceleration operations])
+fi
+
 AC_ARG_WITH(machinebuild,
 	[  --with-machinebuild=NAME machine build [[none,atemeo5200,atemeo6000...]]],
 	[MACHINEBUILD="$withval"],[MACHINEBUILD="atemeo5200"])
@@ -217,6 +264,18 @@ if test "$with_libvugles2" = "yes"; then
 fi
 AM_CONDITIONAL(HAVE_LIBVUGLES2, test "$with_libvugles2" = "yes")
 
+AC_ARG_WITH(libhiaccel,
+	AS_HELP_STRING([--with-libhiaccel],[use libhiaccel, yes or no]),
+	[with_libhiaccel=$withval],[with_libhiaccel=no])
+if test "$with_libhiaccel" = "yes"; then
+	PKG_CHECK_MODULES(LIBHIACCEL, [libhiaccel])
+	HIACCEL_CFLAGS="-DUSE_LIBHIACCEL"
+fi
+
+if test x"$with_libhiaccel" != xno ; then
+	AC_DEFINE(HAVE_HISILICON_ACCEL, 1,[define add HISILICON ACCEL])
+fi
+
 AC_ARG_WITH(osdanimation,
 	AC_HELP_STRING([--with-osdanimation], [use osd animation, yes or no]),
 	[[withosdanimation=$withval]],
@@ -477,7 +536,7 @@ if test "$BOXTYPE" == "dm7080" -o "$BOXTYPE" == "dm820"  -o "$BOXTYPE" == "dm900
 	AC_DEFINE(CONFIG_ION, 1,[define BOX use ION Allocator])
 fi
 
-if test "$BOXTYPE" == "vusolo4k" -o "$BOXTYPE" == "vuuno4k" -o "$BOXTYPE" == "vuuno4kse" -o "$BOXTYPE" == "vuultimo4k" -o "$BOXTYPE" == "vuzero4k"; then
+if test "$BOXTYPE" == "vusolo4k" -o "$BOXTYPE" == "vuuno4k" -o "$BOXTYPE" == "vuuno4kse" -o "$BOXTYPE" == "vuultimo4k" -o "$BOXTYPE" == "vuzero4k" -o "$BOXTYPE" == "vuduo4k" -o "$BOXTYPE" == "cc1" -o "$BOXTYPE" == "sf8008" -o "$BOXTYPE" == "ustym4kpro"; then
 	AC_DEFINE(VMSG_TYPE2, 1,[define vtuner_message type 2])
 fi
 
@@ -485,10 +544,27 @@ if test "$BOXTYPE" == "vuzero" -o "$BOXTYPE" == "vuuno" -o "$BOXTYPE" == "vuulti
 	AC_DEFINE(FORCE_AUTO_INV, 1,[force Inversion auto for vu mipsel boxes])
 fi
 
-if test "$BOXTYPE" == "u5" -o "$BOXTYPE" == "u5pvr"; then
+if test "$BOXTYPE" == "u5" -o "$BOXTYPE" == "u5pvr" -o "$BOXTYPE" == "u51" -o "$BOXTYPE" == "u52" -o "$BOXTYPE" == "u53" -o "$BOXTYPE" == "u54"; then
 	AC_DEFINE(HAVE_HISILICON, 1,[define add HISILICON chip])
 fi
 
+if test "$BOXTYPE" == "u53"; then
+	AC_DEFINE(KEY_F6_TO_KEY_FAVORITES, 1,[define when rc FAV key sends a KEY_F6 event for its KEY_FAVORITES key])
+	AC_DEFINE(KEY_CONTEXT_MENU_TO_KEY_BACK, 1,[define when rc MOUSE key sends a KEY_CONTEXT_MENU event for its KEY_BACK key])
+	AC_DEFINE(KEY_WWW_TO_KEY_FILE, 1,[define when rc HOME key sends a KEY_WWW event for its KEY_FILE key])
+	AC_DEFINE(KEY_HELP_TO_KEY_AUDIO, 1,[define when rc SETTINGS key sends a KEY_HELP event for its KEY_AUDIO key])
+fi
+
+if test "$BOXTYPE" == "cc1" -o "$BOXTYPE" == "sf8008" -o "$BOXTYPE" == "ustym4kpro"; then
+	AC_DEFINE(HAVE_HISILICON, 1,[define add HISILICON chip])
+	AC_DEFINE(CONFIG_HISILICON_FB, 1,[define add HISILICON framebuffer blit])
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+fi
+
+if test "$BOXTYPE" == "alien5"; then
+	AC_DEFINE(HAVE_ALIEN5, 1,[enable Alien5 Tuner Hack only for testing])
+fi
+
 if test "$BOXTYPE" == "wetekplay" -o "$BOXTYPE" == "wetekplay2" -o "$BOXTYPE" == "wetekhub"; then
 	AC_DEFINE(KEY_F7_TO_KEY_MENU, 1,[define when rc sends a KEY_F7 event for its KEY_MENU])
 	AC_DEFINE(KEY_F1_TO_KEY_MEDIA, 1,[define when rc sends a KEY_F1 event for its KEY_MEDIA])
@@ -528,39 +604,50 @@ if test "$BOXTYPE" == "ebox5000" -o "$BOXTYPE" == "ebox7358" -o "$BOXTYPE" == "e
 fi
 
 
-if test "$BOXTYPE" == "et4x00" -o "$BOXTYPE" == "et5x00" -o "$BOXTYPE" == "et6x00"  -o "$BOXTYPE" == "et7x00" -o "$BOXTYPE" == "et9x00" -o "$BOXTYPE" == "et8000" -o "$BOXTYPE" == "et8500" -o "$BOXTYPE" == "et8500s" -o "$BOXTYPE" == "et10000" -o "$BOXTYPE" == "et13000" -o "$BOXTYPE" == "sf5008"; then
+if test "$BOXTYPE" == "et4x00" -o "$BOXTYPE" == "et5x00" -o "$BOXTYPE" == "et6x00"  -o "$BOXTYPE" == "et7x00" -o "$BOXTYPE" == "et9x00" -o "$BOXTYPE" == "et8000" -o "$BOXTYPE" == "et8500" -o "$BOXTYPE" == "et8500s" -o "$BOXTYPE" == "et10000"; then
 	AC_DEFINE(KEY_PLAY_ACTUALLY_IS_KEY_PLAYPAUSE, 1,[define when rc sends a KEY_PLAY event for its KEY_PLAYPAUSE key])
 	AC_DEFINE(KEY_F3_TO_KEY_LIST, 1,[define when rc sends a KEY_F3 event for its KEY_LIST key])
 fi
 
 if test "$BOXTYPE" == "et8500" -o "$BOXTYPE" == "et8500s"; then
-	AC_DEFINE(FORCE_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
 fi
 
 if test "$BOXTYPE" == "ultramini" -o "$BOXTYPE" == "et1x000" -o "$BOXTYPE" == "et7x00"; then
 	AC_DEFINE(KEY_F1_TO_KEY_F2, 1,[define when rc sends a KEY_F1 event for its KEY_F2 key])
-	AC_DEFINE(FORCE_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
 fi
 
 if test "$BOXTYPE" == "9900lx"; then
 	AC_DEFINE(KEY_F1_TO_KEY_F2, 1,[define when rc sends a KEY_F1 event for its KEY_F2 key])
-	AC_DEFINE(FORCE_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
 fi
 
-if test "$BOXTYPE" == "g300" -o "$BOXTYPE" == "g100" -o "$BOXTYPE" == "sf4008" -o "$BOXTYPE" == "g101" -o "$BOXTYPE" == "et1x000" -o "$BOXTYPE" == "et13000" -o "$BOXTYPE" == "sf5008"; then
-	AC_DEFINE(FORCE_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+if test "$BOXTYPE" == "g300" -o "$BOXTYPE" == "g100" -o "$BOXTYPE" == "sf4008" -o "$BOXTYPE" == "g101" -o "$BOXTYPE" == "et1x000"; then
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+fi
+
+if test "$BOXTYPE" == "et13000"; then
+	AC_DEFINE(KEY_PLAY_ACTUALLY_IS_KEY_PLAYPAUSE, 1,[define when rc sends a KEY_PLAY event for its KEY_PLAYPAUSE key])
+	AC_DEFINE(KEY_BOOKMARKS_IS_KEY_DIRECTORY, 1,[define when rc sends a KEY_BOOKMARKS but other box use this key for different mapping we remap to KEY_DIRECTORY])
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+fi
+
+if test "$BOXTYPE" == "sf5008"; then
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+	AC_DEFINE(KEY_LIST_TO_KEY_PVR, 1,[define when rc sends a KEY_LIST event for its KEY_PVR key])
 fi
 
 if test "$BOXTYPE" == "xc7362" -o "$BOXTYPE" == "xc7346" -o "$BOXTYPE" == "xc7439"; then
 	AC_DEFINE(KEY_MEDIA_TO_KEY_LIST, 1,[define MEDIA to LIST])
 fi
 
-if test "$BOXTYPE" == "osnino" -o "$BOXTYPE" == "osninoplus"; then
+if test "$BOXTYPE" == "osnino" -o "$BOXTYPE" == "osninoplus" -o "$BOXTYPE" == "osninopro" -o "$BOXTYPE" == "osmio4k"; then
 	AC_DEFINE(KEY_MEDIA_TO_KEY_LIST, 1,[define MEDIA to LIST])
 	AC_DEFINE(KEY_VIDEO_TO_KEY_ANGLE, 1,[define VIDEO to ANGLE])
 fi
 
-if test "$BOXTYPE" == "hd2400" -o "$BOXTYPE" == "hd11" -o "$BOXTYPE" == "hd1100" -o "$BOXTYPE" == "hd1200" -o "$BOXTYPE" == "hd500c" -o "$BOXTYPE" == "hd530c" -o "$BOXTYPE" == "hd1265" -o "$BOXTYPE" == "hd1500" -o "$BOXTYPE" == "hd51" -o "$BOXTYPE" == "hd52" -o "$BOXTYPE" == "vs1000" -o "$BOXTYPE" == "vs1500"; then
+if test "$BOXTYPE" == "hd2400" -o "$BOXTYPE" == "hd11" -o "$BOXTYPE" == "hd1100" -o "$BOXTYPE" == "hd1200" -o "$BOXTYPE" == "hd500c" -o "$BOXTYPE" == "hd530c" -o "$BOXTYPE" == "hd1265" -o "$BOXTYPE" == "hd1500" -o "$BOXTYPE" == "hd51" -o "$BOXTYPE" == "hd60" -o "$BOXTYPE" == "hd52" -o "$BOXTYPE" == "vs1000" -o "$BOXTYPE" == "vs1500"; then
 	AC_DEFINE(KEY_PLAY_ACTUALLY_IS_KEY_PLAYPAUSE, 1,[define when rc sends a KEY_PLAY event for its KEY_PLAYPAUSE key])
 	AC_DEFINE(KEY_F3_TO_KEY_LIST, 1,[define when rc sends a KEY_F3 event for its KEY_LIST key])
 fi
@@ -589,11 +676,15 @@ if test "$BOXTYPE" == "sh1" -o "$BOXTYPE" == "lc"; then
 	AC_DEFINE(KEY_PLAY_ACTUALLY_IS_KEY_PLAYPAUSE, 1,[define when rc sends a KEY_PLAY event for its KEY_PLAYPAUSE key])
 fi
 
-if test "$BOXTYPE" == "7000s" -o "$BOXTYPE" == "7100s" -o "$BOXTYPE" == "7105s" -o "$BOXTYPE" == "7200s" -o "$BOXTYPE" == "7205s" -o "$BOXTYPE" == "7210s" -o "$BOXTYPE" == "7215s" -o "$BOXTYPE" == "7300s" -o "$BOXTYPE" == "7400s" -o "$BOXTYPE" == "8100s"; then
+if test "$BOXTYPE" == "7000s" -o "$BOXTYPE" == "7100s" -o "$BOXTYPE" == "7105s" -o "$BOXTYPE" == "7200s" -o "$BOXTYPE" == "7205s" -o "$BOXTYPE" == "7210s" -o "$BOXTYPE" == "7215s" -o "$BOXTYPE" == "7300s" -o "$BOXTYPE" == "7400s"; then
 	AC_DEFINE(KEY_PLAY_ACTUALLY_IS_KEY_PLAYPAUSE, 1,[define when rc sends a KEY_PLAY event for its KEY_PLAYPAUSE key])
 	AC_DEFINE(LCD_COLOR_BITORDER_RGB565, 1,[define if lcd uses RGB565 bitorder])
 fi
 
+if test "$BOXTYPE" == "8100s"; then
+	AC_DEFINE(KEY_VIDEO_TO_KEY_BOOKMARKS, 1,[define when rc sends a KEY_VIDEO event for its KEY_BOOKMARKS])
+fi
+
 if test "$MACHINEBUILD" == "e4hd" -o "$MACHINEBUILD" == "e4hdhybrid"; then
 	AC_DEFINE(KEY_POWER2_TO_KEY_WWW, 1,[define when rc sends a KEY_POWER2 event for its KEY_WWW key])
 	AC_DEFINE(KEY_DIRECTORY_TO_KEY_FILE, 1,[define when rc sends a KEY_DIRECTORY event for its KEY_FILE key])
@@ -605,18 +696,18 @@ if test "$BOXTYPE" == "odinm9"; then
 fi
 
 if test "$BOXTYPE" == "odinm7" ; then
-	AC_DEFINE(FORCE_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
 	AC_DEFINE(KEY_POWER2_TO_KEY_WWW, 1,[define when rc sends a KEY_POWER2 event for its KEY_WWW key])
 	AC_DEFINE(KEY_DIRECTORY_TO_KEY_FILE, 1,[define when rc sends a KEY_DIRECTORY event for its KEY_FILE key])
 fi
 
 if test "$BOXTYPE" == "e3hd"; then
-	AC_DEFINE(FORCE_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
+	AC_DEFINE(FORCE_ALPHABLENDING_ACCELERATION, 1,[define when the framebuffer acceleration has alphablending support, but detection slow down all])
 	AC_DEFINE(KEY_POWER2_TO_KEY_WWW, 1,[define when rc sends a KEY_POWER2 event for its KEY_WWW key])
 	AC_DEFINE(KEY_DIRECTORY_TO_KEY_FILE, 1,[define when rc sends a KEY_DIRECTORY event for its KEY_FILE key])
 fi
 
-if test "$BOXTYPE" == "vuduo" -o "$BOXTYPE" == "vusolo" -o "$BOXTYPE" == "vuduo2" -o "$BOXTYPE" == "vusolo2" -o "$BOXTYPE" == "vuuno" -o "$BOXTYPE" == "vuultimo" -o "$BOXTYPE" == "vusolose" -o "$BOXTYPE" == "vuzero" -o "$BOXTYPE" == "vusolo4k" -o "$BOXTYPE" == "vuuno4k" -o "$BOXTYPE" == "vuuno4kse" -o "$BOXTYPE" == "vuultimo4k" -o "$BOXTYPE" == "vuzero4k"; then
+if test "$BOXTYPE" == "vuduo" -o "$BOXTYPE" == "vusolo" -o "$BOXTYPE" == "vuduo2" -o "$BOXTYPE" == "vusolo2" -o "$BOXTYPE" == "vuuno" -o "$BOXTYPE" == "vuultimo" -o "$BOXTYPE" == "vusolose" -o "$BOXTYPE" == "vuzero" -o "$BOXTYPE" == "vusolo4k" -o "$BOXTYPE" == "vuuno4k" -o "$BOXTYPE" == "vuuno4kse" -o "$BOXTYPE" == "vuultimo4k" -o "$BOXTYPE" == "vuzero4k" -o "$BOXTYPE" == "vuduo4k"; then
 	AC_DEFINE(FORCE_NO_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration does not have alphablending support, though the autodetection might indicate that it does])
 	AC_DEFINE(FORCE_ADVANCED_REMOTE, 1,[define to fixup the input device identification when the remote control is actually an 'advanced' remote (with play/forward/rewind keys)])
 	AC_DEFINE(KEY_HELP_TO_KEY_INFO, 1,[define when rc sends a KEY_HELP event we need KEY_INFO])
@@ -634,7 +725,6 @@ if test "$BOXTYPE" == "gb800solo" -o "$BOXTYPE" == "gb800se" -o "$BOXTYPE" == "g
 	AC_DEFINE(KEY_GUIDE_TO_KEY_EPG, 1,[define when rc sends a KEY_HELP event for its KEY_EPG key])
 	AC_DEFINE(KEY_F2_TO_KEY_F6, 1,[define when rc sends a KEY_F2 event for its KEY_F6 key])
 	AC_DEFINE(KEY_SCREEN_TO_KEY_MODE, 1,[define when rc sends a KEY_MODE event for its KEY_ASPECT key])
-	AC_DEFINE(LCD_COLOR_BITORDER_RGB565, 1,[define if lcd uses RGB565 bitorder])
 fi
 
 if test "$BOXTYPE" == "gb7252"; then
@@ -681,7 +771,7 @@ if test "$BOXTYPE" == "blackbox7405"; then
 	AC_DEFINE(KEY_TIME_TO_KEY_SLOW, 1,[define when rc sends a KEY_TOME event for its KEY_SLOW key])
 fi
 
-if test "$BOXTYPE" == "dags7335" -o "$BOXTYPE" == "dags7356" -o "$BOXTYPE" == "dags7362" -o "$BOXTYPE" == "dags73625" -o "$BOXTYPE" == "dags7252"; then
+if test "$BOXTYPE" == "dags7335" -o "$BOXTYPE" == "dags7356" -o "$BOXTYPE" == "dags7362" -o "$BOXTYPE" == "dags73625" -o "$BOXTYPE" == "dags7252" -o "$BOXTYPE" == "dags72604"; then
 	AC_DEFINE(HAVE_LINUXSOCKADDR, 1,[define it use sockaddr_un instead of sockaddr_in on linux domain socket.])
 	AC_DEFINE(FORCE_NO_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration does not have alphablending support, though the autodetection might indicate that it does])
 	AC_DEFINE(FORCE_ADVANCED_REMOTE, 1,[define to fixup the input device identification when the remote control is actually an 'advanced' remote (with play/forward/rewind keys)])
@@ -792,9 +882,9 @@ lib/python/Plugins/Extensions/SocketMMI/meta/Makefile
 lib/python/Plugins/Extensions/SocketMMI/src/Makefile
 lib/python/Plugins/Extensions/TuxboxPlugins/Makefile
 lib/python/Plugins/Extensions/TuxboxPlugins/meta/Makefile
-lib/python/Plugins/Extensions/Openpanel/Makefile
-lib/python/Plugins/Extensions/Openpanel/meta/Makefile
-lib/python/Plugins/Extensions/Openpanel/icons/Makefile
+-lib/python/Plugins/Extensions/Openpanel/Makefile
+-lib/python/Plugins/Extensions/Openpanel/meta/Makefile
+-lib/python/Plugins/Extensions/Openpanel/icons/Makefile
 lib/python/Plugins/Extensions/Volume_adjust/Makefile
 lib/python/Plugins/Extensions/StartKodi/Makefile
 lib/python/Plugins/Extensions/QuadPip/Makefile
diff --git a/lib/actions/action.cpp b/lib/actions/action.cpp
index eb0e380..3c071f9 100644
--- a/lib/actions/action.cpp
+++ b/lib/actions/action.cpp
@@ -42,7 +42,7 @@ RESULT eActionMap::getInstance(ePtr<eActionMap> &ptr)
 	return 0;
 }
 
-void eActionMap::bindAction(const std::string &context, int priority, int id, eWidget *widget)
+void eActionMap::bindAction(const std::string &context, long priority, int id, eWidget *widget)
 {
 	eActionBinding bnd;
 
@@ -50,10 +50,10 @@ void eActionMap::bindAction(const std::string &context, int priority, int id, eW
 	bnd.m_context = context;
 	bnd.m_widget = widget;
 	bnd.m_id = id;
-	m_bindings.insert(std::pair<int,eActionBinding>(priority, bnd));
+	m_bindings.insert(std::pair<long,eActionBinding>(priority, bnd));
 }
 
-void eActionMap::bindAction(const std::string &context, int priority, ePyObject function)
+void eActionMap::bindAction(const std::string &context, long priority, ePyObject function)
 {
 	eActionBinding bnd;
 
@@ -62,13 +62,13 @@ void eActionMap::bindAction(const std::string &context, int priority, ePyObject
 	bnd.m_widget = 0;
 	Py_INCREF(function);
 	bnd.m_fnc = function;
-	m_bindings.insert(std::pair<int,eActionBinding>(priority, bnd));
+	m_bindings.insert(std::pair<long,eActionBinding>(priority, bnd));
 }
 
 void eActionMap::unbindAction(eWidget *widget, int id)
 {
 	//eDebug("[eActionMap] unbind widget id=%d", id);
-	for (std::multimap<int, eActionBinding>::iterator i(m_bindings.begin()); i != m_bindings.end(); ++i)
+	for (std::multimap<long, eActionBinding>::iterator i(m_bindings.begin()); i != m_bindings.end(); ++i)
 		if (i->second.m_widget == widget && i->second.m_id == id)
 		{
 			m_bindings.erase(i);
@@ -79,7 +79,7 @@ void eActionMap::unbindAction(eWidget *widget, int id)
 void eActionMap::unbindAction(const std::string &context, ePyObject function)
 {
 	//eDebug("[eActionMap] unbind function from %s", context.c_str());
-	for (std::multimap<int, eActionBinding>::iterator i(m_bindings.begin()); i != m_bindings.end(); ++i)
+	for (std::multimap<long, eActionBinding>::iterator i(m_bindings.begin()); i != m_bindings.end(); ++i)
 	{
 		if (i->second.m_fnc && (PyObject_Compare(i->second.m_fnc, function) == 0))
 		{
@@ -249,7 +249,7 @@ void eActionMap::keyPressed(const std::string &device, int key, int flags)
 
 	std::vector<call_entry> call_list;
 	// iterate active contexts
-	for (std::multimap<int,eActionBinding>::iterator c(m_bindings.begin());
+	for (std::multimap<long,eActionBinding>::iterator c(m_bindings.begin());
 		c != m_bindings.end(); ++c)
 	{
 		if (flags == eRCKey::flagMake)
diff --git a/lib/actions/action.h b/lib/actions/action.h
index 9a830c6..f34fb7c 100644
--- a/lib/actions/action.h
+++ b/lib/actions/action.h
@@ -22,11 +22,11 @@ public:
 #ifndef SWIG
 	eActionMap();
 	~eActionMap();
-	void bindAction(const std::string &context, int priority, int id, eWidget *widget);
+	void bindAction(const std::string &context, long priority, int id, eWidget *widget);
 	void unbindAction(eWidget *widget, int id);
 #endif
 
-	void bindAction(const std::string &context, int priority, SWIG_PYOBJECT(ePyObject) function);
+	void bindAction(const std::string &context, long priority, SWIG_PYOBJECT(ePyObject) function);
 	void unbindAction(const std::string &context, SWIG_PYOBJECT(ePyObject) function);
 
 	void bindKey(const std::string &domain, const std::string &device, int key, int flags, const std::string &context, const std::string &action);
@@ -58,7 +58,7 @@ private:
 		int m_prev_seen_make_key;
 	};
 
-	std::multimap<int, eActionBinding> m_bindings;
+	std::multimap<long, eActionBinding> m_bindings;
 
 	struct eTranslationBinding
 	{
diff --git a/lib/base/Makefile.inc b/lib/base/Makefile.inc
index cdd1079..3c2bdb2 100644
--- a/lib/base/Makefile.inc
+++ b/lib/base/Makefile.inc
@@ -19,6 +19,7 @@ base_libenigma_base_a_SOURCES = \
 	base/init.cpp \
 	base/ioprio.cpp \
 	base/message.cpp \
+	base/modelinformation.cpp \
 	base/nconfig.cpp \
 	base/rawfile.cpp \
 	base/smartptr.cpp \
@@ -53,6 +54,7 @@ baseinclude_HEADERS = \
 	base/init_num.h \
 	base/ioprio.h \
 	base/message.h \
+	base/modelinformation.h \
 	base/nconfig.h \
 	base/object.h \
 	base/rawfile.h \
diff --git a/lib/base/encoding.cpp b/lib/base/encoding.cpp
index 41e81f9..6b3140b 100644
--- a/lib/base/encoding.cpp
+++ b/lib/base/encoding.cpp
@@ -16,37 +16,40 @@ inline char tolower(char c)
 int mapEncoding(char *s_table)
 {
 	int encoding = -1;
-	int no_table_id = 0;
+	int ex_table_flag = 0;
 
 	//if encoding string has a option 'N' or 'NOID' first split by ':' , it indicates that the string has no
 	//     encoding id char in the first byte, and the bit 0x80 of encoding id will be set.
 	char *colon=strrchr(s_table, ':');
 	if(colon != NULL){
 		if(strncmp(s_table,"n:",2) == 0 || strncmp(s_table,"noid:",5) == 0 )
-			no_table_id = NOTABLEID;
+			ex_table_flag |= MASK_NO_TABLEID;
+                else if(strncmp(s_table,"e:",2) == 0 || strncmp(s_table,"enforce:",8) == 0 )
+			ex_table_flag |= MASK_IGNORE_TABLEID;
 		s_table = colon + 1;
 	}
 
 	// table name will be in lowercase!
 	if (sscanf(s_table, "iso8859-%d", &encoding) == 1)
-		return no_table_id | encoding;
+		return ex_table_flag | encoding;
 	if (sscanf(s_table, "iso%d", &encoding) == 1 and encoding == 6937)
-		return no_table_id;
+		return ex_table_flag;
 	if (strcmp(s_table, "gb2312") == 0 || strcmp(s_table, "gbk") == 0
 		|| strcmp(s_table, "gb18030") == 0 || strcmp(s_table, "cp936") == 0)
-		return no_table_id | GB18030_ENCODING;
+		return ex_table_flag | GB18030_ENCODING;
 	if (strcmp(s_table, "big5") == 0 || strcmp(s_table, "cp950") == 0)
-		return no_table_id | BIG5_ENCODING;
+		return ex_table_flag | BIG5_ENCODING;
 	if (strcmp(s_table, "utf8") == 0 || strcmp(s_table, "utf-8") == 0)
-		return no_table_id | UTF8_ENCODING;
+		return ex_table_flag | UTF8_ENCODING;
 	if (strcmp(s_table, "unicode") == 0)
-		return no_table_id | UNICODE_ENCODING;
+		return ex_table_flag | UNICODE_ENCODING;
 	if (strcmp(s_table, "utf16be") == 0)
-		return no_table_id | UTF16BE_ENCODING;
+		return ex_table_flag | UTF16BE_ENCODING;
 	if (strcmp(s_table, "utf16le") == 0)
-		return no_table_id | UTF16LE_ENCODING;
+		return ex_table_flag | UTF16LE_ENCODING;
 	else
 		eDebug("[eDVBTextEncodingHandler] unsupported table in encoding.conf: %s. ", s_table);
+
 	return -1;
 }
 
diff --git a/lib/base/encoding.h b/lib/base/encoding.h
index 4b9e6b9..0e313c4 100644
--- a/lib/base/encoding.h
+++ b/lib/base/encoding.h
@@ -24,8 +24,10 @@
 #define UTF8_ENCODING			0x15	// ISO10646 Basic Multilingual Plane in UTF8 encoding
 #define UTF16BE_ENCODING		0x16
 #define UTF16LE_ENCODING		0x17
+#define HUFFMAN_ENCODING		0x1F
 
-#define NOTABLEID			0x80
+#define MASK_NO_TABLEID			0x0800
+#define MASK_IGNORE_TABLEID		0x0100
 
 class eDVBTextEncodingHandler
 {
diff --git a/lib/base/estring.cpp b/lib/base/estring.cpp
index 077a0fd..94076ba 100644
--- a/lib/base/estring.cpp
+++ b/lib/base/estring.cpp
@@ -1,4 +1,5 @@
 #include <algorithm>
+#include <regex>
 #include <cctype>
 #include <climits>
 #include <string>
@@ -9,17 +10,19 @@
 #include "big5.h"
 #include "gb18030.h"
 
+extern bool verbose;
+
 std::string buildShortName( const std::string &str )
 {
 	std::string tmp;
 	static char stropen[3] = { char(0xc2), char(0x86), 0x00 };
 	static char strclose[3] = { char(0xc2), char(0x87), 0x00 };
 	size_t open=std::string::npos-1;
-	while ( (open = str.find(stropen, open+2)) != std::string::npos )
+	while ((open = str.find(stropen, open+2)) != std::string::npos)
 	{
 		size_t close = str.find(strclose, open);
-		if ( close != std::string::npos )
-			tmp+=str.substr( open+2, close-(open+2) );
+		if (close != std::string::npos)
+			tmp += str.substr(open+2, close-(open+2));
 	}
 	return tmp.length() ? tmp : str;
 }
@@ -330,42 +333,24 @@ static inline unsigned int recode(unsigned char d, int cp)
 		return d;
 	switch (cp)
 	{
-	case 0:		// ISO6937
-		return iso6937[d-0xA0];
-	case 1:		// 8859-1 <-> unicode mapping
-		return d;
-	case 2:		// 8859-2 -> unicode mapping
-		return c88592[d-0xA0];
-	case 3:		// 8859-3 -> unicode mapping
-		return c88593[d-0xA0];
-	case 4:		// 8859-2 -> unicode mapping
-		return c88594[d-0xA0];
-	case 5:		// 8859-5 -> unicode mapping
-		return c88595[d-0xA0];
-	case 6:		// 8859-6 -> unicode mapping
-		return c88596[d-0xA0];
-	case 7:		// 8859-7 -> unicode mapping
-		return c88597[d-0xA0];
-	case 8:		// 8859-8 -> unicode mapping
-		return c88598[d-0xA0];
-	case 9:		// 8859-9 -> unicode mapping
-		return c88599[d-0xA0];
-	case 10:// 8859-10 -> unicode mapping
-		return c885910[d-0xA0];
-	case 11:// 8859-11 -> unicode mapping
-		return c885911[d-0xA0];
-/*	case 12:// 8859-12 -> unicode mapping  // reserved for indian use..
-		return c885912[d-0xA0];*/
-	case 13:// 8859-13 -> unicode mapping
-		return c885913[d-0xA0];
-	case 14:// 8859-14 -> unicode mapping
-		return c885914[d-0xA0];
-	case 15:// 8859-15 -> unicode mapping
-		return c885915[d-0xA0];
-	case 16:// 8859-16 -> unicode mapping
-		return c885916[d-0xA0];
-	default:
-		return d;
+	case 0:  return iso6937[d-0xA0]; // ISO6937
+	case 1:  return d;		 // 8859-1 -> unicode mapping
+	case 2:  return c88592[d-0xA0];  // 8859-2 -> unicode mapping
+	case 3:  return c88593[d-0xA0];  // 8859-3 -> unicode mapping
+	case 4:  return c88594[d-0xA0];  // 8859-2 -> unicode mapping
+	case 5:  return c88595[d-0xA0];  // 8859-5 -> unicode mapping
+	case 6:  return c88596[d-0xA0];  // 8859-6 -> unicode mapping
+	case 7:  return c88597[d-0xA0];  // 8859-7 -> unicode mapping
+	case 8:  return c88598[d-0xA0];  // 8859-8 -> unicode mapping
+	case 9:  return c88599[d-0xA0];  // 8859-9 -> unicode mapping
+	case 10: return c885910[d-0xA0]; // 8859-10 -> unicode mapping
+	case 11: return c885911[d-0xA0]; // 8859-11 -> unicode mapping
+//	case 12: return c885912[d-0xA0]; // 8859-12 -> unicode mapping  reserved for indian use..
+	case 13: return c885913[d-0xA0]; // 8859-13 -> unicode mapping
+	case 14: return c885914[d-0xA0]; // 8859-14 -> unicode mapping
+	case 15: return c885915[d-0xA0]; // 8859-15 -> unicode mapping
+	case 16: return c885916[d-0xA0]; // 8859-16 -> unicode mapping
+	default: return d;
 	}
 }
 
@@ -455,93 +440,108 @@ std::string convertDVBUTF8(const unsigned char *data, int len, int table, int ts
 		return "";
 	}
 
-	int i=0, t=0;
+	int i = 0;
+        int convertedLen=0;
 	std::string output = "";
-	int no_table_id = 0;
-	if (table >= NOTABLEID){
-		no_table_id = NOTABLEID;
-		table &= ~NOTABLEID;
+	int mask_no_tableid = 0;
+	bool ignore_tableid = false;
+
+	if (tsidonid)
+		encodingHandler.getTransponderDefaultMapping(tsidonid, table);
+
+	if (table >= 0 && (table & MASK_NO_TABLEID)){
+		mask_no_tableid = MASK_NO_TABLEID;
+		table &= ~MASK_NO_TABLEID;
 	}
 
+	if (table >= 0 && (table & MASK_IGNORE_TABLEID)){
+		ignore_tableid = true;
+		table &= ~MASK_IGNORE_TABLEID;
+	}
 
-	if ( tsidonid )
-		encodingHandler.getTransponderDefaultMapping(tsidonid, table);
+        int table_preset = table;
 
 	// first byte in strings may override general encoding table.
-	if (!no_table_id){
-		switch(data[0])
+	switch(data[0] | mask_no_tableid)
+	{
+		case ISO8859_5 ... ISO8859_15:
+			// For Thai providers, encoding char is present but faulty.
+			if (table != 11)
+				table = data[i] + 4;
+			++i;
+			// eDebug("[convertDVBUTF8] (1..11)text encoded in ISO-8859-%d", table);
+			break;
+		case ISO8859_xx:
 		{
-			case ISO8859_5 ... ISO8859_15:
-				// For Thai providers, encoding char is present but faulty.
-				if (table != 11)
-					table = data[i] + 4;
-				++i;
-				// eDebug("[convertDVBUTF8] (1..11)text encoded in ISO-8859-%d", table);
-				break;
-			case ISO8859_xx:
+			int n = data[++i] << 8;
+			n |= (data[++i]);
+			// eDebug("[convertDVBUTF8] (0x10)text encoded in ISO-8859-%d", n);
+			++i;
+			switch(n)
 			{
-				int n = data[++i] << 8;
-				n |= (data[++i]);
-				// eDebug("[convertDVBUTF8] (0x10)text encoded in ISO-8859-%d", n);
-				++i;
-				switch(n)
-				{
-					case ISO8859_12:
-						eDebug("[convertDVBUTF8] ISO8859-12 encoding unsupported");
-						break;
-					default:
-						table = n;
-						break;
-				}
-				break;
+				case ISO8859_12:
+					eDebug("[convertDVBUTF8] ISO8859-12 encoding unsupported");
+					break;
+				default:
+					table = n;
+					break;
 			}
-			case UNICODE_ENCODING: //  Basic Multilingual Plane of ISO/IEC 10646-1 enc  (UTF-16... Unicode)
-				table = UNICODE_ENCODING;
-				tsidonid = 0;
-				++i;
-				break;
-			case KSX1001_ENCODING:
-				++i;
-				eDebug("[convertDVBUTF8] KSC 5601 encing unsupported.");
-				break;
-			case GB18030_ENCODING: // GB-2312-1980 enc.
-				++i;
-				table = GB18030_ENCODING;
-				break;
-			case BIG5_ENCODING: // Big5 subset of ISO/IEC 10646-1 enc.
-				++i;
-				table = BIG5_ENCODING;
-				break;
-			case UTF8_ENCODING: // UTF-8 encoding of ISO/IEC 10646-1
-				++i;
-				table = UTF8_ENCODING;
-				break;
-			case UTF16BE_ENCODING:
-				++i;
-				table = UTF16BE_ENCODING;
-				break;
-			case UTF16LE_ENCODING:
-				++i;
-				table = UTF16LE_ENCODING;
-				break;
-			case 0x1F:
-				{
-					// Attempt to decode Freesat Huffman encoded string
-					std::string decoded_string = huffmanDecoder.decode(data, len);
-					if (!decoded_string.empty())
-						return decoded_string;
-				}
-				++i;
-				eDebug("[convertDVBUTF8] failed to decode bbc freesat huffman");
-				break;
-			case 0x0:
-			case 0xC ... 0xF:
-			case 0x18 ... 0x1E:
-				eDebug("[convertDVBUTF8] reserved %d", data[0]);
-				++i;
-				break;
+			break;
 		}
+		case UNICODE_ENCODING: //  Basic Multilingual Plane of ISO/IEC 10646-1 enc  (UTF-16... Unicode)
+			table = UNICODE_ENCODING;
+			tsidonid = 0;
+			++i;
+			break;
+		case KSX1001_ENCODING:
+			++i;
+			eDebug("[convertDVBUTF8] KSC 5601 encing unsupported.");
+			break;
+		case GB18030_ENCODING: // GB-2312-1980 enc.
+			++i;
+			table = GB18030_ENCODING;
+			break;
+		case BIG5_ENCODING: // Big5 subset of ISO/IEC 10646-1 enc.
+			++i;
+			table = BIG5_ENCODING;
+			break;
+		case UTF8_ENCODING: // UTF-8 encoding of ISO/IEC 10646-1
+			++i;
+			table = UTF8_ENCODING;
+			break;
+		case UTF16BE_ENCODING:
+			++i;
+			table = UTF16BE_ENCODING;
+			break;
+		case UTF16LE_ENCODING:
+			++i;
+			table = UTF16LE_ENCODING;
+			break;
+		case HUFFMAN_ENCODING:
+			{
+				// Attempt to decode Freesat Huffman encoded string
+				std::string decoded_string = huffmanDecoder.decode(data, len);
+				if (!decoded_string.empty()){
+					table = HUFFMAN_ENCODING;
+					output = decoded_string;
+					break;
+				}
+			}
+			++i;
+			eDebug("[convertDVBUTF8] failed to decode bbc freesat huffman");
+			break;
+		case 0x0:
+		case 0xC ... 0xF:
+		case 0x18 ... 0x1E:
+			eDebug("[convertDVBUTF8] reserved %d", data[0]);
+			++i;
+			break;
 	}
+
+	if (ignore_tableid && table != UTF8_ENCODING) {
+		table = table_preset;
+	}
+
 	bool useTwoCharMapping = !table || (tsidonid && encodingHandler.getTransponderUseTwoCharMapping(tsidonid));
 
 	if (useTwoCharMapping && table == 5) { // i hope this dont break other transponders which realy use ISO8859-5 and two char byte mapping...
@@ -553,23 +553,33 @@ std::string convertDVBUTF8(const unsigned char *data, int len, int table, int ts
 
 	switch(table)
 	{
+		case HUFFMAN_ENCODING:
+			{
+				if (output.empty()){
+					// Attempt to decode Freesat Huffman encoded string
+					std::string decoded_string = huffmanDecoder.decode(data, len);
+					if (!decoded_string.empty())
+						output = decoded_string;
+				}
+				if (!output.empty())
+					convertedLen += len;
+			}
+			break;
 		case UTF8_ENCODING:
 			output = std::string((char*)data + i, len - i);
-			if (pconvertedLen)
-				*pconvertedLen += len;
+			convertedLen += i;
 			break;
 		case GB18030_ENCODING:
-			output = GB18030ToUTF8((const char *)(data + i), len - i, pconvertedLen);
-			if (pconvertedLen)
-				*pconvertedLen += len;
+			output = GB18030ToUTF8((const char *)(data + i), len - i, &convertedLen);
+			convertedLen += i;
 			break;
 		case BIG5_ENCODING:
-			output = Big5ToUTF8((const char *)(data + i), len - i, pconvertedLen);
-			if (pconvertedLen)
-				*pconvertedLen += len;
+			output = Big5ToUTF8((const char *)(data + i), len - i, &convertedLen);
+			convertedLen += i;
 			break;
 		default:
-			char res[2048];
+			char res[4096];
+			int t = 0;
 			while (i < len && t < sizeof(res))
 			{
 				unsigned long code = 0;
@@ -622,15 +632,23 @@ std::string convertDVBUTF8(const unsigned char *data, int len, int table, int ts
 					continue;
 				t += UnicodeToUTF8(code, res + t, sizeof(res) - t);
 			}
-			if (pconvertedLen)
-				*pconvertedLen = i;
+			convertedLen = i;
 			output = std::string((char*)res, t);
 			break;
 	}
 
-	if (pconvertedLen && *pconvertedLen < len)
-		eDebug("[convertDVBUTF8] %d chars converted, and %d chars left..", *pconvertedLen, len-*pconvertedLen);
-	//eDebug("[convertDVBUTF8] table=0x%02X twochar=%d output:%s\n", table, useTwoCharMapping, output.c_str());
+//	if (convertedLen < len)
+//		eDebug("[convertDVBUTF8] %d chars converted, and %d chars left..", convertedLen, len-convertedLen);
+
+	if (pconvertedLen)
+		*pconvertedLen = convertedLen;
+
+	if (verbose)
+		eDebug("[convertDVBUTF8] table=0x%02X tsid:onid=0x%X:0x%X data[0..14]=%s   output:%s\n",
+			table, (unsigned int)tsidonid >> 16, tsidonid & 0xFFFFU,
+			string_to_hex(std::string((char*)data, len < 15 ? len : 15)).c_str(),
+			output.c_str());
+
 	return output;
 }
 
@@ -700,7 +718,7 @@ std::string convertLatin1UTF8(const std::string &string)
 {
 	unsigned int t = 0, i = 0, len = string.size();
 
-	char res[2048];
+	char res[4096];
 
 	while (i < len)
 	{
@@ -753,10 +771,11 @@ int isUTF8(const std::string &string)
 unsigned int truncateUTF8(std::string &s, unsigned int newsize)
 {
         unsigned int len = s.size();
+        unsigned char* const data = (unsigned char*)s.data();
 
         // Assume s is a real UTF8 string!!!
         while (len > newsize) {
-                while (len-- > 0  && (s[len] & 0xC0) == 0x80)
+                while (len-- > 0  && (data[len] & 0xC0) == 0x80)
                         ; // remove UTF data bytes,  e.g. range 0x80 - 0xBF
                 if (len > 0)   // remove the UTF startbyte, or normal ascii character
                          --len;
@@ -896,3 +915,28 @@ std::string urlDecode(const std::string &s)
 	return res;
 }
 
+std::string string_to_hex(const std::string& input)
+{
+    static const char* const lut = "0123456789ABCDEF";
+    size_t len = input.length();
+
+    std::string output;
+    output.reserve(3 * len);
+    for (size_t i = 0; i < len; ++i)
+    {
+        const unsigned char c = input[i];
+        if (i)
+		output.push_back(' ');
+        output.push_back(lut[c >> 4]);
+        output.push_back(lut[c & 15]);
+    }
+    return output;
+}
+
+std::string strip_non_graph(std::string s)
+{
+	s = std::regex_replace(s, std::regex("[[^:graph:]]"), " ");
+	s = std::regex_replace(s, std::regex("\\s{2,}"), " ");
+	s = std::regex_replace(s, std::regex("^\\s+|\\s+$"), "");
+	return s;
+}
diff --git a/lib/base/estring.h b/lib/base/estring.h
index ca68e68..ac38f39 100644
--- a/lib/base/estring.h
+++ b/lib/base/estring.h
@@ -15,7 +15,7 @@ std::string getNum(int num, int base=10);
 std::string GB18030ToUTF8(const char *szIn, int len,int *pconvertedLen=0);
 std::string Big5ToUTF8(const char *szIn, int len,int *pconvertedLen=0);
 
-std::string convertDVBUTF8(const unsigned char *data, int len, int table=0, int tsidonid=1,int *pconvertedLen=0); // with default encoding
+std::string convertDVBUTF8(const unsigned char *data, int len, int table=-1, int tsidonid=1,int *pconvertedLen=0);
 std::string convertLatin1UTF8(const std::string &string);
 int isUTF8(const std::string &string);
 unsigned int truncateUTF8(std::string &s, unsigned int newsize);
@@ -24,11 +24,13 @@ std::string removeDVBChars(const std::string &s);
 void makeUpper(std::string &s);
 std::string replace_all(const std::string &in, const std::string &entity, const std::string &symbol,int table=-1);
 
-inline std::string convertDVBUTF8(const std::string &string, int table=0, int tsidonid=1,int *pconvertedLen=0) // with default encoding
+inline std::string convertDVBUTF8(const std::string &string, int table=-1, int tsidonid=1,int *pconvertedLen=0)
 {
 	return convertDVBUTF8((const unsigned char*)string.c_str(), string.length(), table, tsidonid,pconvertedLen);
 }
 
 std::string urlDecode(const std::string &s);
+std::string string_to_hex(const std::string& input);
+std::string strip_non_graph(std::string s);
 
 #endif // __E_STRING__
diff --git a/lib/base/httpsstream.cpp b/lib/base/httpsstream.cpp
index e406c01..159ab58 100644
--- a/lib/base/httpsstream.cpp
+++ b/lib/base/httpsstream.cpp
@@ -3,7 +3,6 @@
 #include <lib/base/httpsstream.h>
 #include <lib/base/eerror.h>
 #include <lib/base/wrappers.h>
-#include <lib/base/nconfig.h> // access to python config
 
 // for shutdown
 #include <sys/socket.h>
@@ -311,8 +310,7 @@ int eHttpsStream::open(const char *url)
 void eHttpsStream::thread()
 {
 	hasStarted();
-	if (eConfigManager::getConfigBoolValue("config.usage.remote_fallback_enabled", false))
-		usleep(500000); // wait half a second
+	usleep(500000); // wait half a second in general as not only fallback receiver needs this.
 	std::string currenturl, newurl;
 	currenturl = streamUrl;
 	for (unsigned int i = 0; i < 5; i++)
diff --git a/lib/base/httpstream.cpp b/lib/base/httpstream.cpp
index 715a28e..e55ff07 100644
--- a/lib/base/httpstream.cpp
+++ b/lib/base/httpstream.cpp
@@ -4,7 +4,6 @@
 #include <lib/base/httpstream.h>
 #include <lib/base/eerror.h>
 #include <lib/base/wrappers.h>
-#include <lib/base/nconfig.h> // access to python config
 
 DEFINE_REF(eHttpStream);
 
@@ -44,7 +43,7 @@ int eHttpStream::openUrl(const std::string &url, std::string &newurl)
 
 	close();
 
-	std::string user_agent = "Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;OpenPlus;;;)";
+	std::string user_agent = "Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;openPlus;;;)";
 	std::string extra_headers = "";
 	size_t pos = uri.find('#');
 	if (pos != std::string::npos)
@@ -253,8 +252,7 @@ int eHttpStream::open(const char *url)
 void eHttpStream::thread()
 {
 	hasStarted();
-	if (eConfigManager::getConfigBoolValue("config.usage.remote_fallback_enabled", false))
-		usleep(500000); // wait half a second
+	usleep(500000); // wait half a second in general as not only fallback receiver needs this.
 	std::string currenturl, newurl;
 	currenturl = streamUrl;
 	for (unsigned int i = 0; i < 5; i++)
diff --git a/lib/components/scan.h b/lib/components/scan.h
index bf06e92..c21f428 100644
--- a/lib/components/scan.h
+++ b/lib/components/scan.h
@@ -46,7 +46,7 @@ public:
 	void addInitial(const eDVBFrontendParametersATSC &p);
 
 		/* please keep the flags in sync with lib/dvb/scan.h ! */
-	enum { scanNetworkSearch=1, scanRemoveServices=4, scanDontRemoveFeeds=8, scanDontRemoveUnscanned=16, clearToScanOnFirstNIT = 32, scanOnlyFree = 64 };
+	enum { scanNetworkSearch=1, scanRemoveServices=4, scanDontRemoveFeeds=8, scanDontRemoveUnscanned=16, clearToScanOnFirstNIT = 32, scanOnlyFree = 64, scanBlindSearch = 128 };
 
 	int start(int feid, int flags=0, int networkid = 0 );
 	SWIG_VOID(RESULT) getFrontend(ePtr<iDVBFrontend> &SWIG_OUTPUT);
diff --git a/lib/driver/hdmi_cec.cpp b/lib/driver/hdmi_cec.cpp
index 28c87fd..260b66a 100644
--- a/lib/driver/hdmi_cec.cpp
+++ b/lib/driver/hdmi_cec.cpp
@@ -374,6 +374,7 @@ void eHdmiCEC::hdmiEvent(int what)
 			static unsigned char pressedkey = 0;
 
 			eDebugNoNewLineStart("[eHdmiCEC] received message");
+			eDebugNoNewLine(" %02X", rxmessage.address);
 			for (int i = 0; i < rxmessage.length; i++)
 			{
 				eDebugNoNewLine(" %02X", rxmessage.data[i]);
@@ -527,6 +528,7 @@ void eHdmiCEC::sendMessage(struct cec_message &message)
 	if (hdmiFd >= 0)
 	{
 		eDebugNoNewLineStart("[eHdmiCEC] send message");
+		eDebugNoNewLine(" %02X", message.address);
 		for (int i = 0; i < message.length; i++)
 		{
 			eDebugNoNewLine(" %02X", message.data[i]);
diff --git a/lib/driver/rc.cpp b/lib/driver/rc.cpp
index d827690..71172cf 100644
--- a/lib/driver/rc.cpp
+++ b/lib/driver/rc.cpp
@@ -128,7 +128,7 @@ eRCInputEventDriver::eRCInputEventDriver(const char *filename): eRCDriver(eRCInp
 			eDebugNoNewLine(" %02X", evCaps[i]);
 		eDebugNoNewLine("\n");
 #endif
-
+	m_remote_control = getDeviceName().find("remote control") != std::string::npos; /* assume remote control when name says so */
 	}
 }
 
@@ -161,21 +161,17 @@ bool eRCInputEventDriver::hasCap(unsigned char *caps, int bit)
 
 bool eRCInputEventDriver::isKeyboard()
 {
-#ifdef VUPLUS_RC_WORKAROUND
-	return(false);
-#else
+	if (m_remote_control)
+		return false;
 	/* check whether the input device has KEY_A, in which case we assume it is a keyboard */
 	return hasCap(keyCaps, KEY_A);
-#endif
 }
 
 bool eRCInputEventDriver::isPointerDevice()
 {
-#ifdef VUPLUS_RC_WORKAROUND
-	return(false);
-#else
+	if (m_remote_control)
+		return false;
 	return hasCap(evCaps, EV_REL) || hasCap(evCaps, EV_ABS);
-#endif
 }
 
 eRCInputEventDriver::~eRCInputEventDriver()
diff --git a/lib/driver/rc.h b/lib/driver/rc.h
index be49469..685d168 100644
--- a/lib/driver/rc.h
+++ b/lib/driver/rc.h
@@ -111,6 +111,7 @@ public:
 class eRCInputEventDriver: public eRCDriver
 {
 protected:
+	bool m_remote_control;
 	int handle;
 	unsigned char evCaps[(EV_MAX / 8) + 1];
 	unsigned char keyCaps[(KEY_MAX / 8) + 1];
diff --git a/lib/driver/rcinput.cpp b/lib/driver/rcinput.cpp
index 32bc2fa..31826cd 100644
--- a/lib/driver/rcinput.cpp
+++ b/lib/driver/rcinput.cpp
@@ -213,6 +213,31 @@ void eRCDeviceInputDev::handleCode(long rccode)
 */
 #endif
 
+#if KEY_F6_TO_KEY_FAVORITES
+	if (ev->code == KEY_F6) {
+		ev->code = KEY_FAVORITES;
+	}
+#endif
+
+#if KEY_HELP_TO_KEY_AUDIO
+	if (ev->code == KEY_HELP) {
+		ev->code = KEY_AUDIO;
+	}
+#endif
+
+
+#if KEY_WWW_TO_KEY_FILE
+	if (ev->code == KEY_WWW) {
+		ev->code = KEY_FILE;
+	}
+#endif
+
+#if KEY_CONTEXT_MENU_TO_KEY_BACK
+	if (ev->code == KEY_CONTEXT_MENU) {
+		ev->code = KEY_BACK;
+	}
+#endif
+
 #if KEY_VIDEO_TO_KEY_ANGLE
 	if (ev->code == KEY_VIDEO) {
 		ev->code = KEY_ANGLE;
@@ -638,6 +663,22 @@ void eRCDeviceInputDev::handleCode(long rccode)
 	}
 #endif
 
+#if KEY_BOOKMARKS_IS_KEY_DIRECTORY
+	if (ev->code == KEY_BOOKMARKS)
+	{
+		/* Beyonwiz U4 RCU workaround to open pluginbrowser */
+		ev->code = KEY_DIRECTORY;
+	}
+#endif
+
+#if KEY_VIDEO_TO_KEY_BOOKMARKS
+	if (ev->code == KEY_VIDEO)
+	{
+		/* Axas Ultra have two keys open Movie folder , use Media key to open Mediaportal */
+		ev->code = KEY_BOOKMARKS;
+	}
+#endif
+
 	switch (ev->value)
 	{
 		case 0:
diff --git a/lib/dvb/Makefile.inc b/lib/dvb/Makefile.inc
index 9ccc621..896200c 100644
--- a/lib/dvb/Makefile.inc
+++ b/lib/dvb/Makefile.inc
@@ -29,6 +29,7 @@ dvb_libenigma_dvb_a_SOURCES = \
 	dvb/tstools.cpp \
 	dvb/volume.cpp \
 	dvb/streamserver.cpp \
+	dvb/rtspstreamserver.cpp \
 	dvb/pmtparse.cpp \
 	dvb/encoder.cpp \
 	dvb/fbc.cpp \
@@ -73,6 +74,7 @@ dvbinclude_HEADERS = \
 	dvb/tstools.h \
 	dvb/volume.h \
 	dvb/streamserver.h \
+	dvb/rtspstreamserver.h \
 	dvb/pmtparse.h \
 	dvb/encoder.h \
 	dvb/fbc.h \
diff --git a/lib/dvb/amldecoder.cpp b/lib/dvb/amldecoder.cpp
index 8617587..cd959ed 100644
--- a/lib/dvb/amldecoder.cpp
+++ b/lib/dvb/amldecoder.cpp
@@ -177,6 +177,11 @@ RESULT eAMLTSMPEGDecoder::setVideoPID(int vpid, int type)
 #endif
 		}
 		eDebug("%s() vpid=%d, type=%d",__PRETTY_FUNCTION__, vpid, type);
+		
+#if HAVE_ALIEN5
+
+		aml_change_vpid(vpid, m_codec.video_type);
+#endif
 	}
 	return 0;
 }
@@ -202,6 +207,10 @@ RESULT eAMLTSMPEGDecoder::setAudioPID(int apid, int type)
 			m_codec.audio_type = AFORMAT_AC3;
 			eDebug("%s() audio type: AC3",__PRETTY_FUNCTION__);
 			break;
+		case aDDP:
+			m_codec.audio_type = AFORMAT_EAC3;
+			eDebug("%s() audio type: AC3",__PRETTY_FUNCTION__);
+			break;
 		case aAAC:
 			m_codec.audio_type = AFORMAT_AAC;
 			eDebug("%s() audio type: AAC",__PRETTY_FUNCTION__);
@@ -263,6 +272,7 @@ RESULT eAMLTSMPEGDecoder::setSyncMaster(int who)
 RESULT eAMLTSMPEGDecoder::set()
 {
 	TRACE__
+
 	return 0;
 }
 
@@ -582,3 +592,11 @@ int eAMLTSMPEGDecoder::getVideoAspect()
 
 	return m_aspect == 1 ? 2 : 3;
 }
+int eAMLTSMPEGDecoder::getVideoGamma()
+{
+	//if (m_video)
+	//	return m_video->getGamma();
+	return -1;
+}
+
+
diff --git a/lib/dvb/amldecoder.h b/lib/dvb/amldecoder.h
index 89ffc15..a09ba11 100644
--- a/lib/dvb/amldecoder.h
+++ b/lib/dvb/amldecoder.h
@@ -125,6 +125,7 @@ public:
 	int getVideoProgressive();
 	int getVideoFrameRate();
 	int getVideoAspect();
+	int getVideoGamma();
 	static RESULT setHwPCMDelay(int delay);
 	static RESULT setHwAC3Delay(int delay);
 };
diff --git a/lib/dvb/cahandler.cpp b/lib/dvb/cahandler.cpp
index 49b8258..9608133 100644
--- a/lib/dvb/cahandler.cpp
+++ b/lib/dvb/cahandler.cpp
@@ -847,6 +847,7 @@ int eDVBCAService::buildCAPMT(ePtr<eDVBService> &dvbservice)
 	pidtype[eDVBService::cTPID]      = 0x06; // Data-/Audiostream (Subtitles/VBI and AC-3)
 	pidtype[eDVBService::cPCRPID]    = 0x06;
 	pidtype[eDVBService::cAC3PID]    = 0x06;
+	pidtype[eDVBService::cAC4PID]    = 0x06;
 	pidtype[eDVBService::cSUBTITLE]  = 0x06;
 	pidtype[eDVBService::cAACHEAPID] = 0x06;
 	pidtype[eDVBService::cDDPPID]    = 0x06;
diff --git a/lib/dvb/db.cpp b/lib/dvb/db.cpp
index 8c2d5a6..0e018e9 100644
--- a/lib/dvb/db.cpp
+++ b/lib/dvb/db.cpp
@@ -18,6 +18,28 @@
 #include <dvbsi++/s2_satellite_delivery_system_descriptor.h>
 #include <dirent.h>
 
+/*
+ * Copyright (C) 2017 Marcus Metzler <mocm@metzlerbros.de>
+ *                    Ralph Metzler <rjkm@metzlerbros.de>
+ *
+ * https://github.com/DigitalDevices/dddvb/blob/master/apps/pls.c
+ */
+static int root2gold(int root)
+{
+	int x, g;
+
+	if (root < 0 || root > 0x3ffff)
+		return 0;
+
+	for (g = 0, x = 1; g < 0x3ffff; g++)
+	{
+		if (root == x)
+			return g;
+		x = (((x ^ (x >> 7)) & 1) << 17) | (x >> 1);
+	}
+	return 0;
+}
+
 DEFINE_REF(eDVBService);
 
 RESULT eBouquet::addService(const eServiceReference &ref, eServiceReference before)
@@ -444,10 +466,9 @@ static ePtr<eDVBFrontendParameters> parseFrontendData(char* line, int version)
 				modulation=eDVBFrontendParametersSatellite::Modulation_QPSK,
 				rolloff=eDVBFrontendParametersSatellite::RollOff_alpha_0_35,
 				pilot=eDVBFrontendParametersSatellite::Pilot_Unknown,
-				is_id = 0, //NO_STREAM_ID_FILTER
-				pls_mode = eDVBFrontendParametersSatellite::PLS_Root,
-				pls_code = 1;
-
+				is_id = NO_STREAM_ID_FILTER,
+				pls_code = 0,
+				pls_mode = eDVBFrontendParametersSatellite::PLS_Gold;
 			sscanf(line+2, "%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
 				&frequency, &symbol_rate, &polarisation, &fec, &orbital_position,
 				&inversion, &flags, &system, &modulation, &rolloff, &pilot,
@@ -462,9 +483,6 @@ static ePtr<eDVBFrontendParameters> parseFrontendData(char* line, int version)
 			sat.modulation = modulation;
 			sat.rolloff = rolloff;
 			sat.pilot = pilot;
-			sat.is_id = is_id;
-			sat.pls_mode = pls_mode & 3;
-			sat.pls_code = pls_code & 0x3FFFF;
 			// Process optional features
 			while (options) {
 				char * next = strchr(options, ',');
@@ -477,8 +495,19 @@ static ePtr<eDVBFrontendParameters> parseFrontendData(char* line, int version)
 				//	sat.parm3 = parm3;
 				//}
 				//else ...
+				if (strncmp(options, "MIS/PLS:", 8) == 0)
+					sscanf(options+8, "%d:%d:%d", &is_id, &pls_code, &pls_mode);
 				options = next;
 			}
+			sat.is_id = is_id;
+			sat.pls_mode = pls_mode & 3;
+			sat.pls_code = pls_code & 0x3FFFF;
+			/* convert Root to Gold */
+			if (sat.pls_mode == eDVBFrontendParametersSatellite::PLS_Root)
+			{
+				sat.pls_mode = eDVBFrontendParametersSatellite::PLS_Gold;
+				sat.pls_code = root2gold(sat.pls_code);
+			}
 			feparm->setDVBS(sat);
 			feparm->setFlags(flags);
 			break;
@@ -600,6 +629,7 @@ void eDVBDB::loadServiceListV5(FILE * f)
 	int scount = 0;
 	while (fgets(line, 1024, f)) {
 		int len = strlen(line);
+		if (!len) continue;
 		if (line[len - 1] == '\n')
 			line[len - 1] = '\0';
 		if (!strncmp(line, "t:", 2)) {		// Transponder/Channel data
@@ -754,7 +784,7 @@ void eDVBDB::saveServicelist(const char *file)
 		fprintf(g, "eDVB services /5/\n");
 		fprintf(g, "# Transponders: t:dvb_namespace:transport_stream_id:original_network_id,FEPARMS\n");
 		fprintf(g, "#     DVBS  FEPARMS:   s:frequency:symbol_rate:polarisation:fec:orbital_position:inversion:flags\n");
-		fprintf(g, "#     DVBS2 FEPARMS:   s:frequency:symbol_rate:polarisation:fec:orbital_position:inversion:flags:system:modulation:rolloff:pilot\n");
+		fprintf(g, "#     DVBS2 FEPARMS:   s:frequency:symbol_rate:polarisation:fec:orbital_position:inversion:flags:system:modulation:rolloff:pilot[,MIS/PLS:is_id:pls_code:pls_mode]\n");
 		fprintf(g, "#     DVBT  FEPARMS:   t:frequency:bandwidth:code_rate_HP:code_rate_LP:modulation:transmission_mode:guard_interval:hierarchy:inversion:flags:system:plp_id\n");
 		fprintf(g, "#     DVBC  FEPARMS:   c:frequency:symbol_rate:inversion:modulation:fec_inner:flags:system\n");
 		fprintf(g, "#     ATSC  FEPARMS:   a:frequency:inversion:modulation:flags:system\n");
@@ -793,15 +823,18 @@ void eDVBDB::saveServicelist(const char *file)
 			if (sat.system == eDVBFrontendParametersSatellite::System_DVB_S2)
 			{
 				fprintf(f, ":%d:%d:%d:%d", sat.system, sat.modulation, sat.rolloff, sat.pilot);
+				if (g)
+					fprintf(g, ":%d:%d:%d:%d", sat.system, sat.modulation, sat.rolloff, sat.pilot);
+
 				if (static_cast<unsigned int>(sat.is_id) != NO_STREAM_ID_FILTER ||
 					(sat.pls_code & 0x3FFFF) != 0 ||
-					(sat.pls_mode & 3) != eDVBFrontendParametersSatellite::PLS_Root)
+					(sat.pls_mode & 3) != eDVBFrontendParametersSatellite::PLS_Gold)
 				{
-					fprintf(f, ":%d:%d:%d",
-						sat.is_id, sat.pls_code & 0x3FFFF, sat.pls_mode & 3);
+					fprintf(f, ":%d:%d:%d", sat.is_id, sat.pls_code & 0x3FFFF, sat.pls_mode & 3);
+					if (g)
+						fprintf(g, ",MIS/PLS:%d:%d:%d", sat.is_id, sat.pls_code & 0x3FFFF, sat.pls_mode & 3);
 				}
-				if (g)
-					fprintf(g, ":%d:%d:%d:%d", sat.system, sat.modulation, sat.rolloff, sat.pilot);
+
 			}
 			fprintf(f, "\n");
 			if (g)
@@ -1347,9 +1380,10 @@ PyObject *eDVBDB::readSatellites(ePyObject sat_list, ePyObject sat_dict, ePyObje
 				inv = eDVBFrontendParametersSatellite::Inversion_Unknown;
 				pilot = eDVBFrontendParametersSatellite::Pilot_Unknown;
 				rolloff = eDVBFrontendParametersSatellite::RollOff_alpha_0_35;
-				is_id = 0; //NO_STREAM_ID_FILTER
-				pls_mode = eDVBFrontendParametersSatellite::PLS_Root;
-				pls_code = 1;
+				is_id = NO_STREAM_ID_FILTER;
+
+				pls_code = 0;
+				pls_mode = eDVBFrontendParametersSatellite::PLS_Gold;
 				tsid = -1;
 				onid = -1;
 
@@ -1384,6 +1418,12 @@ PyObject *eDVBDB::readSatellites(ePyObject sat_list, ePyObject sat_dict, ePyObje
 
 				if (freq && sr && pol != -1)
 				{
+					/* convert Root to Gold */
+					if (pls_mode == eDVBFrontendParametersSatellite::PLS_Root)
+					{
+						pls_mode = eDVBFrontendParametersSatellite::PLS_Gold;
+						pls_code = root2gold(pls_code);
+					}
 					tuple = PyTuple_New(15);
 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(0));
 					PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(freq));
@@ -1527,6 +1567,7 @@ PyObject *eDVBDB::readCables(ePyObject cab_list, ePyObject tp_dict)
 					else if (name == "inversion") dest = &inversion;
 					else if (name == "system") dest = &system;
 					else continue;
+
 					if (dest)
 					{
 						tmp = strtol((const char*)attr->children->content, &end_ptr, 10);
@@ -2039,6 +2080,18 @@ PyObject *eDVBDB::getFlag(const eServiceReference &ref)
 	return PyInt_FromLong(0);
 }
 
+PyObject *eDVBDB::getCachedPid(const eServiceReference &ref, int id)
+{
+	if (ref.type == eServiceReference::idDVB)
+	{
+		eServiceReferenceDVB &service = (eServiceReferenceDVB&)ref;
+		std::map<eServiceReferenceDVB, ePtr<eDVBService> >::iterator it(m_services.find(service));
+		if (it != m_services.end())
+			return PyInt_FromLong(it->second->getCacheEntry((eDVBService::cacheID)id));
+	}
+	return PyInt_FromLong(-1);
+}
+
 bool eDVBDB::isCrypted(const eServiceReference &ref)
 {
 	if (ref.type == eServiceReference::idDVB)
@@ -2109,6 +2162,15 @@ RESULT eDVBDB::removeFlag(const eServiceReference &ref, unsigned int flagmask)
 	return -1;
 }
 
+void eDVBDB::removeServicesFlag(unsigned int flagmask)
+{
+	for (std::map<eServiceReferenceDVB, ePtr<eDVBService> >::iterator i(m_services.begin());
+		i != m_services.end(); ++i)
+	{
+		i->second->m_flags &= ~flagmask;
+	}
+}
+
 RESULT eDVBDB::removeFlags(unsigned int flagmask, int dvb_namespace, int tsid, int onid, unsigned int orb_pos)
 {
 	return removeFlags(flagmask, eDVBChannelID(eDVBNamespace(dvb_namespace), eTransportStreamID(tsid), eOriginalNetworkID(onid)), orb_pos);
diff --git a/lib/dvb/db.h b/lib/dvb/db.h
index 8e3f98d..92064e7 100644
--- a/lib/dvb/db.h
+++ b/lib/dvb/db.h
@@ -18,6 +18,7 @@ class eDVBDB: public iDVBChannelList
 	friend class eDVBDBBouquetQuery;
 	friend class eDVBDBSatellitesQuery;
 	friend class eDVBDBProvidersQuery;
+	friend class eRTSPStreamClient;
 
 	struct channel
 	{
@@ -43,11 +44,13 @@ public:
 	RESULT removeServices(int dvb_namespace=-1, int tsid=-1, int onid=-1, unsigned int orb_pos=0xFFFFFFFF);
 	RESULT removeService(const eServiceReference &service);
 	PyObject *getFlag(const eServiceReference &service);
+	PyObject *getCachedPid(const eServiceReference &service, int id);
 	bool isCrypted(const eServiceReference &service);
 	bool hasCAID(const eServiceReference &service, unsigned int caid);
 	RESULT addCAID(const eServiceReference &service, unsigned int caid);
 	RESULT addFlag(const eServiceReference &service, unsigned int flagmask);
 	RESULT removeFlag(const eServiceReference &service, unsigned int flagmask);
+	void removeServicesFlag(unsigned int flagmask);
 	PyObject *readSatellites(SWIG_PYOBJECT(ePyObject) sat_list, SWIG_PYOBJECT(ePyObject) sat_dict, SWIG_PYOBJECT(ePyObject) tp_dict);
 	PyObject *readTerrestrials(SWIG_PYOBJECT(ePyObject) ter_list, SWIG_PYOBJECT(ePyObject) tp_dict);
 	PyObject *readCables(SWIG_PYOBJECT(ePyObject) cab_list, SWIG_PYOBJECT(ePyObject) tp_dict);
diff --git a/lib/dvb/decoder.cpp b/lib/dvb/decoder.cpp
index a559b7f..7c0130f 100644
--- a/lib/dvb/decoder.cpp
+++ b/lib/dvb/decoder.cpp
@@ -109,6 +109,7 @@ int eDVBAudio::startPid(int pid, int type)
 			bypass = 1;
 			break;
 		case aAC3:
+		case aAC4: /* FIXME: AC4 most probably will use other bypass value */
 			bypass = 0;
 			break;
 		case aDTS:
@@ -126,6 +127,9 @@ int eDVBAudio::startPid(int pid, int type)
 		case aDTSHD:
 			bypass = 0x10;
 			break;
+		case aDRA:
+			bypass = 0x40;
+			break;			
 		case aDDP:
 #ifdef DREAMBOX
 		bypass = 7;
@@ -253,7 +257,7 @@ int eDVBVideo::m_close_invalidates_attributes = -1;
 
 eDVBVideo::eDVBVideo(eDVBDemux *demux, int dev)
 	: m_demux(demux), m_dev(dev),
-	m_width(-1), m_height(-1), m_framerate(-1), m_aspect(-1), m_progressive(-1)
+	m_width(-1), m_height(-1), m_framerate(-1), m_aspect(-1), m_progressive(-1), m_gamma(-1)
 {
 	char filename[128];
 	sprintf(filename, "/dev/dvb/adapter%d/video%d", demux ? demux->adapter : 0, dev);
@@ -574,6 +578,21 @@ void eDVBVideo::video_event(int)
 				eDebugNoNewLine("PROGRESSIVE_CHANGED %d\n", m_progressive);
 				/* emit */ m_event(event);
 			}
+			else if (evt.type == 17 /*VIDEO_EVENT_GAMMA_CHANGED*/)
+			{
+				struct iTSMPEGDecoder::videoEvent event;
+				event.type = iTSMPEGDecoder::videoEvent::eventGammaChanged;
+				/*
+				 * Possible gamma values
+				 * 0: Traditional gamma - SDR luminance range
+				 * 1: Traditional gamma - HDR luminance range
+				 * 2: SMPTE ST2084 (aka HDR10)
+				 * 3: Hybrid Log-gamma
+				 */
+				m_gamma = event.gamma = evt.u.frame_rate;
+				eDebugNoNewLine("GAMMA_CHANGED %d\n", m_gamma);
+				/* emit */ m_event(event);
+			}
 			else
 				eDebugNoNewLine("unhandled DVBAPI Video Event %d\n", evt.type);
 		}
@@ -663,6 +682,21 @@ int eDVBVideo::getFrameRate()
 	return m_framerate;
 }
 
+int eDVBVideo::getGamma()
+{
+	/* when closing the video device invalidates the attributes, we can rely on VIDEO_EVENTs */
+	if (!m_close_invalidates_attributes)
+	{
+		if (m_gamma == -1)
+		{
+			char tmp[64];
+			sprintf(tmp, "/proc/stb/vmpeg/%d/gamma", m_dev);
+			CFile::parseIntHex(&m_gamma, tmp);
+		}
+	}
+	return m_gamma;
+}
+
 DEFINE_REF(eDVBPCR);
 
 eDVBPCR::eDVBPCR(eDVBDemux *demux, int dev): m_demux(demux), m_dev(dev)
@@ -1390,3 +1424,10 @@ int eTSMPEGDecoder::getVideoAspect()
 		return m_video->getAspect();
 	return -1;
 }
+
+int eTSMPEGDecoder::getVideoGamma()
+{
+	if (m_video)
+		return m_video->getGamma();
+	return -1;
+}
diff --git a/lib/dvb/decoder.h b/lib/dvb/decoder.h
index b8ea31a..3f51a92 100644
--- a/lib/dvb/decoder.h
+++ b/lib/dvb/decoder.h
@@ -13,7 +13,7 @@ private:
 	ePtr<eDVBDemux> m_demux;
 	int m_fd, m_fd_demux, m_dev, m_is_freezed;
 public:
-	enum { aMPEG, aAC3, aDTS, aAAC, aAACHE, aLPCM, aDTSHD, aDDP };
+	enum { aMPEG, aAC3, aDTS, aAAC, aAACHE, aLPCM, aDTSHD, aDDP, aDRA, aAC4 };
 	eDVBAudio(eDVBDemux *demux, int dev);
 	enum { aMonoLeft, aStereo, aMonoRight };
 	void setChannel(int channel);
@@ -37,10 +37,10 @@ private:
 	ePtr<eSocketNotifier> m_sn;
 	void video_event(int what);
 	sigc::signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
-	int m_width, m_height, m_framerate, m_aspect, m_progressive;
+	int m_width, m_height, m_framerate, m_aspect, m_progressive, m_gamma;
 	static int readApiSize(int fd, int &xres, int &yres, int &aspect);
 public:
-	enum { MPEG2, MPEG4_H264, MPEG1, MPEG4_Part2, VC1, VC1_SM, H265_HEVC, AVS };
+	enum { UNKNOWN = -1, MPEG2, MPEG4_H264, VC1 = 3, MPEG4_Part2, VC1_SM, MPEG1, H265_HEVC, AVS = 16 };
 	eDVBVideo(eDVBDemux *demux, int dev);
 	void stop();
 	int startPid(int pid, int type=MPEG2);
@@ -57,6 +57,7 @@ public:
 	int getProgressive();
 	int getFrameRate();
 	int getAspect();
+	int getGamma();
 };
 
 class eDVBPCR: public iObject
@@ -173,6 +174,7 @@ public:
 	int getVideoProgressive();
 	int getVideoFrameRate();
 	int getVideoAspect();
+	int getVideoGamma();
 	static RESULT setHwPCMDelay(int delay);
 	static RESULT setHwAC3Delay(int delay);
 };
diff --git a/lib/dvb/demux.cpp b/lib/dvb/demux.cpp
index 1a50141..a008688 100644
--- a/lib/dvb/demux.cpp
+++ b/lib/dvb/demux.cpp
@@ -438,8 +438,8 @@ RESULT eDVBPESReader::connectRead(const sigc::slot2<void,const uint8_t*,int> &r,
 
 eDVBRecordFileThread::eDVBRecordFileThread(int packetsize, int bufferCount):
 	eFilePushThreadRecorder(
-		/* buffer */ (unsigned char*) ::mmap(NULL, bufferCount * packetsize * 1024, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, /*ignored*/-1, 0),
-		/*buffersize*/ packetsize * 1024),
+		/* buffer */ (unsigned char*) ::mmap(NULL, bufferCount * packetsize * 1050, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, /*ignored*/-1, 0),
+		/*buffersize*/ packetsize * 1050),        // the buffer should be higher than the hardware buffer size, accounts for RTSP header
 	 m_ts_parser(packetsize),
 	 m_current_offset(0),
 	 m_fd_dest(-1),
@@ -563,8 +563,8 @@ int eDVBRecordFileThread::asyncWrite(int len)
 	suseconds_t diff;
 	gettimeofday(&starttime, NULL);
 #endif
-
-	m_ts_parser.parseData(m_current_offset, m_buffer, len);
+	if(!getProtocol())
+		m_ts_parser.parseData(m_current_offset, m_buffer, len);
 
 #ifdef SHOW_WRITE_TIME
 	gettimeofday(&now, NULL);
diff --git a/lib/dvb/demux.h b/lib/dvb/demux.h
index 6ae694b..ead3a08 100644
--- a/lib/dvb/demux.h
+++ b/lib/dvb/demux.h
@@ -188,6 +188,7 @@ private:
 	eDVBRecordFileThread *m_thread;
 	std::string m_target_filename;
 	int m_packetsize;
+	friend class eRTSPStreamClient;
 };
 
 #endif
diff --git a/lib/dvb/dvb.cpp b/lib/dvb/dvb.cpp
index ed27da6..30e6854 100644
--- a/lib/dvb/dvb.cpp
+++ b/lib/dvb/dvb.cpp
@@ -1794,7 +1794,11 @@ class eDVBChannelFilePush: public eFilePushThread
 {
 public:
 	eDVBChannelFilePush(int packetsize = 188):
+#if HAVE_ALIEN5
+		eFilePushThread(IOPRIO_CLASS_BE, 0, packetsize, packetsize * 64),
+#else
 		eFilePushThread(IOPRIO_CLASS_BE, 0, packetsize, packetsize * 512),
+#endif
 		m_iframe_search(0),
 		m_iframe_state(0),
 		m_pid(0),
diff --git a/lib/dvb/dvb.h b/lib/dvb/dvb.h
index 993d44f..5d9c216 100644
--- a/lib/dvb/dvb.h
+++ b/lib/dvb/dvb.h
@@ -191,6 +191,8 @@ private:
 
 	friend class eDVBChannel;
 	friend class eFBCTunerManager;
+	friend class eRTSPStreamClient;
+
 	RESULT addChannel(const eDVBChannelID &chid, eDVBChannel *ch);
 	RESULT removeChannel(eDVBChannel *ch);
 
diff --git a/lib/dvb/encoder.cpp b/lib/dvb/encoder.cpp
index 7e684d2..af06336 100644
--- a/lib/dvb/encoder.cpp
+++ b/lib/dvb/encoder.cpp
@@ -49,7 +49,7 @@ eEncoder::~eEncoder()
 	instance = NULL;
 }
 
-int eEncoder::allocateEncoder(const std::string &serviceref, const int bitrate, const int width, const int height, const int framerate, const int interlaced, const int aspectratio)
+int eEncoder::allocateEncoder(const std::string &serviceref, const int bitrate, const int width, const int height, const int framerate, const int interlaced, const int aspectratio, const std::string &vcodec, const std::string &acodec)
 {
 	unsigned int i;
 	int encoderfd = -1;
@@ -70,6 +70,24 @@ int eEncoder::allocateEncoder(const std::string &serviceref, const int bitrate,
 			CFile::writeInt(filename, interlaced);
 			snprintf(filename, sizeof(filename), "/proc/stb/encoder/%d/aspectratio", i);
 			CFile::writeInt(filename, aspectratio);
+			if (!vcodec.empty())
+			{
+				snprintf(filename, sizeof(filename), "/proc/stb/encoder/%d/vcodec_choices", i);
+				if (CFile::contains_word(filename, vcodec))
+				{
+					snprintf(filename, sizeof(filename), "/proc/stb/encoder/%d/vcodec", i);
+					CFile::write(filename, vcodec.c_str());
+				}
+			}
+			if (!acodec.empty())
+			{
+				snprintf(filename, sizeof(filename), "/proc/stb/encoder/%d/acodec_choices", i);
+				if (CFile::contains_word(filename, acodec))
+				{
+					snprintf(filename, sizeof(filename), "/proc/stb/encoder/%d/acodec", i);
+					CFile::write(filename, acodec.c_str());
+				}
+			}
 			snprintf(filename, sizeof(filename), "/proc/stb/encoder/%d/apply", i);
 			CFile::writeInt(filename, 1);
 			if (navigationInstances[i]->playService(serviceref) >= 0)
diff --git a/lib/dvb/encoder.h b/lib/dvb/encoder.h
index 161bc10..88fbf42 100644
--- a/lib/dvb/encoder.h
+++ b/lib/dvb/encoder.h
@@ -18,7 +18,7 @@ public:
 	eEncoder();
 	~eEncoder();
 
-	int allocateEncoder(const std::string &serviceref, const int bitrate, const int width, const int height, const int framerate, const int interlaced, const int aspectratio);
+	int allocateEncoder(const std::string &serviceref, const int bitrate, const int width, const int height, const int framerate, const int interlaced, const int aspectratio, const std::string &vcodec = "", const std::string &acodec = "");
 	void freeEncoder(int encoderfd);
 	int getUsedEncoderCount();
 
diff --git a/lib/dvb/fastscan.cpp b/lib/dvb/fastscan.cpp
index 54843e0..9871585 100644
--- a/lib/dvb/fastscan.cpp
+++ b/lib/dvb/fastscan.cpp
@@ -509,8 +509,8 @@ void eFastScan::parseResult()
 			fesat.rolloff = (*it)->getRollOff();
 			fesat.pilot = eDVBFrontendParametersSatellite::Pilot_Unknown;
 			fesat.is_id = NO_STREAM_ID_FILTER;
-			fesat.pls_mode = eDVBFrontendParametersSatellite::PLS_Root;
-			fesat.pls_code = 1;
+			fesat.pls_mode = eDVBFrontendParametersSatellite::PLS_Gold;
+			fesat.pls_code = 0;
 
 			parm->setDVBS(fesat);
 			db->addChannelToList(chid, parm);
diff --git a/lib/dvb/filepush.cpp b/lib/dvb/filepush.cpp
index 12ee650..140bb63 100644
--- a/lib/dvb/filepush.cpp
+++ b/lib/dvb/filepush.cpp
@@ -7,27 +7,27 @@
 #if defined(__sh__) // this allows filesystem tasks to be prioritised
 #include <sys/vfs.h>
 #define USBDEVICE_SUPER_MAGIC 0x9fa2
-#define EXT2_SUPER_MAGIC      0xEF53
-#define EXT3_SUPER_MAGIC      0xEF53
-#define SMB_SUPER_MAGIC       0x517B
-#define NFS_SUPER_MAGIC       0x6969
-#define MSDOS_SUPER_MAGIC     0x4d44 /* MD */
+#define EXT2_SUPER_MAGIC 0xEF53
+#define EXT3_SUPER_MAGIC 0xEF53
+#define SMB_SUPER_MAGIC 0x517B
+#define NFS_SUPER_MAGIC 0x6969
+#define MSDOS_SUPER_MAGIC 0x4d44 /* MD */
 #endif
 //#define SHOW_WRITE_TIME
 
 DEFINE_REF(eFilePushThread);
 eFilePushThread::eFilePushThread(int io_prio_class, int io_prio_level, int blocksize, size_t buffersize)
-	:prio_class(io_prio_class),
-	 prio(io_prio_level),
-	 m_sg(NULL),
-	 m_stop(1),
-	 m_send_pvr_commit(0),
-	 m_stream_mode(0),
-	 m_blocksize(blocksize),
-	 m_buffersize(buffersize),
-	 m_buffer((unsigned char *)malloc(buffersize)),
-	 m_messagepump(eApp, 0),
-	 m_run_state(0)
+	: prio_class(io_prio_class),
+	  prio(io_prio_level),
+	  m_sg(NULL),
+	  m_stop(1),
+	  m_send_pvr_commit(0),
+	  m_stream_mode(0),
+	  m_blocksize(blocksize),
+	  m_buffersize(buffersize),
+	  m_buffer((unsigned char *)malloc(buffersize)),
+	  m_messagepump(eApp, 0),
+	  m_run_state(0)
 {
 	if (m_buffer == NULL)
 		eFatal("[eFilePushThread] Failed to allocate %d bytes", buffersize);
@@ -62,100 +62,101 @@ void eFilePushThread::thread()
 
 	do
 	{
-	int eofcount = 0;
-	int buf_end = 0;
-	size_t bytes_read = 0;
-	off_t current_span_offset = 0;
-	size_t current_span_remaining = 0;
+		int eofcount = 0;
+		int buf_end = 0;
+		size_t bytes_read = 0;
+		off_t current_span_offset = 0;
+		size_t current_span_remaining = 0;
 
 #if defined(__sh__)
-// opens video device for the reverse playback workaround
-// Changes in this file are cause e2 doesnt tell the player to play reverse
-	int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
-// Fix to ensure that event evtEOF is called at end of playbackl part 1/3
-	bool already_empty = false;
+		// opens video device for the reverse playback workaround
+		// Changes in this file are cause e2 doesnt tell the player to play reverse
+		int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+		// Fix to ensure that event evtEOF is called at end of playbackl part 1/3
+		bool already_empty = false;
 #endif
 
-	while (!m_stop)
-	{
-		if (m_sg && !current_span_remaining)
+		while (!m_stop)
 		{
-#if defined (__sh__) // tells the player to play in reverse
-#define VIDEO_DISCONTINUITY                   _IO('o', 84)
-#define DVB_DISCONTINUITY_SKIP                0x01
-#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
-			if ((m_sg->getSkipMode() != 0))
+			if (m_sg && !current_span_remaining)
 			{
-				// inform the player about the jump in the stream data
-				// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
-				int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
-				int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
-			}
+#if defined(__sh__) // tells the player to play in reverse
+#define VIDEO_DISCONTINUITY _IO('o', 84)
+#define DVB_DISCONTINUITY_SKIP 0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE 0x02
+				if ((m_sg->getSkipMode() != 0))
+				{
+					// inform the player about the jump in the stream data
+					// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+					int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+					int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void *)param);
+				}
 #endif
-			m_sg->getNextSourceSpan(m_current_position, bytes_read, current_span_offset, current_span_remaining, m_blocksize);
-			ASSERT(!(current_span_remaining % m_blocksize));
-			m_current_position = current_span_offset;
-			bytes_read = 0;
-		}
+				m_sg->getNextSourceSpan(m_current_position, bytes_read, current_span_offset, current_span_remaining, m_blocksize);
+				ASSERT(!(current_span_remaining % m_blocksize));
+				m_current_position = current_span_offset;
+				bytes_read = 0;
+			}
 
-		size_t maxread = m_buffersize;
+			size_t maxread = m_buffersize;
 
 			/* if we have a source span, don't read past the end */
-		if (m_sg && maxread > current_span_remaining)
-			maxread = current_span_remaining;
+			if (m_sg && maxread > current_span_remaining)
+				maxread = current_span_remaining;
 
 			/* align to blocksize */
-		maxread -= maxread % m_blocksize;
+			maxread -= maxread % m_blocksize;
 
-		if (maxread)
-		{
+			if (maxread)
+			{
 #ifdef SHOW_WRITE_TIME
-			struct timeval starttime;
-			struct timeval now;
-			gettimeofday(&starttime, NULL);
+				struct timeval starttime;
+				struct timeval now;
+				gettimeofday(&starttime, NULL);
 #endif
-			buf_end = m_source->read(m_current_position, m_buffer, maxread);
+				buf_end = m_source->read(m_current_position, m_buffer, maxread);
 #ifdef SHOW_WRITE_TIME
-			gettimeofday(&now, NULL);
-			suseconds_t diff = (1000000 * (now.tv_sec - starttime.tv_sec)) + now.tv_usec - starttime.tv_usec;
-			eDebug("[eFilePushThread] read %d bytes time: %9u us", buf_end, (unsigned int)diff);
+				gettimeofday(&now, NULL);
+				suseconds_t diff = (1000000 * (now.tv_sec - starttime.tv_sec)) + now.tv_usec - starttime.tv_usec;
+				eDebug("[eFilePushThread] read %d bytes time: %9u us", buf_end, (unsigned int)diff);
 #endif
-		}
-		else
-			buf_end = 0;
-
-		if (buf_end < 0)
-		{
-			buf_end = 0;
-			/* Check m_stop after interrupted syscall. */
-			if (m_stop) {
-				break;
 			}
-			if (errno == EINTR || errno == EBUSY || errno == EAGAIN)
-				continue;
-			if (errno == EOVERFLOW)
+			else
+				buf_end = 0;
+
+			if (buf_end < 0)
 			{
-				eWarning("[eFilePushThread] OVERFLOW while playback?");
-				continue;
+				buf_end = 0;
+				/* Check m_stop after interrupted syscall. */
+				if (m_stop)
+				{
+					break;
+				}
+				if (errno == EINTR || errno == EBUSY || errno == EAGAIN)
+					continue;
+				if (errno == EOVERFLOW)
+				{
+					eWarning("[eFilePushThread] OVERFLOW while playback?");
+					continue;
+				}
+				eDebug("[eFilePushThread] read error: %m");
 			}
-			eDebug("[eFilePushThread] read error: %m");
-		}
 
 			/* a read might be mis-aligned in case of a short read. */
-		int d = buf_end % m_blocksize;
-		if (d)
-			buf_end -= d;
+			int d = buf_end % m_blocksize;
+			if (d)
+				buf_end -= d;
 
-		if (buf_end == 0)
-		{
-				/* on EOF, try COMMITting once. */
-			if (m_send_pvr_commit)
+			if (buf_end == 0)
 			{
-				struct pollfd pfd;
-				pfd.fd = m_fd_dest;
-				pfd.events = POLLIN;
-				switch (poll(&pfd, 1, 250)) // wait for 250ms
+#ifndef HAVE_ALIEN5				/* on EOF, try COMMITting once. */
+				if (m_send_pvr_commit)
 				{
+					struct pollfd pfd;
+					pfd.fd = m_fd_dest;
+					pfd.events = POLLIN;
+					switch (poll(&pfd, 1, 250)) // wait for 250ms
+					{
 					case 0:
 						eDebug("[eFilePushThread] wait for driver eof timeout");
 #if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 2/3
@@ -180,92 +181,112 @@ void eFilePushThread::thread()
 						if (m_stop)
 							break;
 						continue;
+					}
 				}
-			}
-
-			if (m_stop)
-				break;
+#endif
+				if (m_stop)
+					break;
 
 				/* in stream_mode, we are sending EOF events
 				   over and over until somebody responds.
 
 				   in stream_mode, think of evtEOF as "buffer underrun occurred". */
-			sendEvent(evtEOF);
+				sendEvent(evtEOF);
 
-			if (m_stream_mode)
-			{
-				eDebug("[eFilePushThread] reached EOF, but we are in stream mode. delaying 1 second.");
-				sleep(1);
-				continue;
+				if (m_stream_mode)
+				{
+					eDebug("[eFilePushThread] reached EOF, but we are in stream mode. delaying 1 second.");
+#if HAVE_ALIEN5
+				usleep(50000);
+#else
+					sleep(1);
+#endif
+					continue;
+				}
+				else if (++eofcount < 10)
+				{
+					eDebug("[eFilePushThread] reached EOF, but the file may grow. delaying 1 second.");
+#if HAVE_ALIEN5
+								usleep(50000);
+#else
+					sleep(1);
+#endif
+					continue;
+				}
+				break;
 			}
-			else if (++eofcount < 10)
+			else
 			{
-				eDebug("[eFilePushThread] reached EOF, but the file may grow. delaying 1 second.");
-				sleep(1);
-				continue;
-			}
-			break;
-		} else
-		{
-			/* Write data to mux */
-			int buf_start = 0;
-			filterRecordData(m_buffer, buf_end);
-			while ((buf_start != buf_end) && !m_stop)
-			{
-				int w = write(m_fd_dest, m_buffer + buf_start, buf_end - buf_start);
-
-				if (w <= 0)
+				/* Write data to mux */
+				int buf_start = 0;
+				filterRecordData(m_buffer, buf_end);
+				while ((buf_start != buf_end) && !m_stop)
 				{
-					/* Check m_stop after interrupted syscall. */
-					if (m_stop) {
-						w = 0;
-						buf_start = 0;
-						buf_end = 0;
-						break;
-					}
-					if (w < 0 && (errno == EINTR || errno == EAGAIN || errno == EBUSY))
+					int w = write(m_fd_dest, m_buffer + buf_start, buf_end - buf_start);
+
+					if (w <= 0)
 					{
+						/* Check m_stop after interrupted syscall. */
+						if (m_stop)
+						{
+							w = 0;
+							buf_start = 0;
+							buf_end = 0;
+							break;
+						}
+						if (w < 0 && (errno == EINTR || errno == EAGAIN || errno == EBUSY))
+						{
 #if HAVE_CPULOADFIX
-						sleep(2);
+							sleep(2);
 #endif
 #if HAVE_HISILICON
-						usleep(100000);
+							usleep(100000);
 #endif
-						continue;
+#if HAVE_ALIEN5
+							usleep(100000);
+#endif
+							continue;
+						}
+#if HAVE_ALIEN5
+						usleep(50000);
+#endif
+						eDebug("[eFilePushThread] write: %m");
+						sendEvent(evtWriteError);
+						break;
 					}
-					eDebug("[eFilePushThread] write: %m");
-					sendEvent(evtWriteError);
-					break;
+					buf_start += w;
 				}
-				buf_start += w;
-			}
 
-			eofcount = 0;
+				eofcount = 0;
 #if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 3/3
-			already_empty = false;
+				already_empty = false;
+#endif
+				m_current_position += buf_end;
+				bytes_read += buf_end;
+				if (m_sg)
+					current_span_remaining -= buf_end;
+			}
+#if HAVE_ALIEN5
+			usleep(10);
 #endif
-			m_current_position += buf_end;
-			bytes_read += buf_end;
-			if (m_sg)
-				current_span_remaining -= buf_end;
 		}
-	}
 #if defined(__sh__) // closes video device for the reverse playback workaround
-	close(fd_video);
+		close(fd_video);
 #endif
-	sendEvent(evtStopped);
+		sendEvent(evtStopped);
 
-	{ /* mutex lock scope */
-		eSingleLocker lock(m_run_mutex);
-		m_run_state = 0;
-		m_run_cond.signal(); /* Tell them we're here */
-		while (m_stop == 2) {
-			eDebug("[eFilePushThread] PAUSED");
-			m_run_cond.wait(m_run_mutex);
+		{ /* mutex lock scope */
+			eSingleLocker lock(m_run_mutex);
+			m_run_state = 0;
+			m_run_cond.signal(); /* Tell them we're here */
+			while (m_stop == 2)
+			{
+				eDebug("[eFilePushThread] PAUSED");
+				m_run_cond.wait(m_run_mutex);
+			}
+			if (m_stop == 0)
+				m_run_state = 1;
 		}
-		if (m_stop == 0)
-			m_run_state = 1;
-	}
 
 	} while (m_stop == 0);
 	eDebug("[eFilePushThread] STOP");
@@ -306,7 +327,8 @@ void eFilePushThread::pause()
 	m_stop = 2;
 	sendSignal(SIGUSR1);
 	m_run_cond.signal(); /* Trigger if in weird state */
-	while (m_run_state) {
+	while (m_run_state)
+	{
 		eDebug("[eFilePushThread] waiting for pause");
 		m_run_cond.wait(m_run_mutex);
 	}
@@ -359,18 +381,158 @@ void eFilePushThread::filterRecordData(const unsigned char *data, int len)
 {
 }
 
+eFilePushThreadRecorder::eFilePushThreadRecorder(unsigned char *buffer, size_t buffersize) : m_fd_source(-1),
+																							 m_buffersize(buffersize),
+																							 m_buffer(buffer),
+																							 m_overflow_count(0),
+																							 m_stop(1),
+																							 m_messagepump(eApp, 0)
+{
+	m_protocol = m_stream_id = m_session_id = m_packet_no = 0;
+	CONNECT(m_messagepump.recv_msg, eFilePushThreadRecorder::recvEvent);
+}
 
+#define copy16(a, i, v)           \
+	{                             \
+		a[i] = ((v) >> 8) & 0xFF; \
+		a[i + 1] = (v)&0xFF;      \
+	}
+#define copy32(a, i, v)                \
+	{                                  \
+		a[i] = ((v) >> 24) & 0xFF;     \
+		a[i + 1] = ((v) >> 16) & 0xFF; \
+		a[i + 2] = ((v) >> 8) & 0xFF;  \
+		a[i + 3] = (v)&0xFF;           \
+	}
+#define _PROTO_RTSP_UDP 1
+#define _PROTO_RTSP_TCP 2
 
+int eFilePushThreadRecorder::pushReply(void *buf, int len)
+{
+	m_reply.insert(m_reply.end(), (unsigned char *)buf, (unsigned char *)buf + len);
+	eDebug("pushed reply of %d bytes", len);
+	return 0;
+}
+
+static int errs;
+
+int64_t eFilePushThreadRecorder::getTick()
+{ //ms
+	struct timespec ts;
+	clock_gettime(CLOCK_MONOTONIC, &ts);
+	return (ts.tv_nsec / 1000000) + (ts.tv_sec * 1000);
+}
 
-eFilePushThreadRecorder::eFilePushThreadRecorder(unsigned char* buffer, size_t buffersize):
-	m_fd_source(-1),
-	m_buffersize(buffersize),
-	m_buffer(buffer),
-	m_overflow_count(0),
-	m_stop(1),
-	m_messagepump(eApp, 0)
+// wrapper around ::read, to read multiple of 188 or error (it does not block)
+int eFilePushThreadRecorder::read_ts(int fd, unsigned char *buf, int size)
 {
-	CONNECT(m_messagepump.recv_msg, eFilePushThreadRecorder::recvEvent);
+	int rb = 0, bytes = 0;
+	int left = size;
+	do
+	{
+		rb = ::read(fd, buf + bytes, left);
+		if (rb > 0 && ((bytes % 188) != 0))
+			eDebug("%s read %d out of %d bytes, total %d, size %d, fd %d", ((bytes + rb) % 188) ? "incomplete" : "completed", rb, left, bytes, size, fd);
+
+		if (rb <= 0 && errno != EAGAIN && errno != EINTR)
+			return rb;
+
+		if (rb > 0)
+		{
+			bytes += rb;
+			left -= rb;
+		}
+		if ((bytes % 188) != 0)
+		{
+			left = 188 - (bytes % 188);
+		}
+
+	} while ((bytes % 188) != 0);
+
+	if (bytes == 0)
+		return rb;
+
+	return bytes;
+}
+int eFilePushThreadRecorder::read_dmx(int fd, void *m_buffer, int size)
+{
+	unsigned char *buf;
+	int it = 0, pos = 0, bytes = 0;
+	int max_pack = 42;
+	int i, left;
+	static int cnt;
+	unsigned char *b;
+	uint64_t start = getTick();
+	while (size - pos > 188 + 16)
+	{
+		left = size - pos - 16;
+		left = (left > 188 * max_pack) ? 188 * max_pack : (((int)(left / 188) - 1) * 188);
+		if (left < 188)
+			break;
+
+		buf = (unsigned char *)m_buffer + pos;
+
+		bytes = read_ts(fd, buf + 16, left);
+
+		if (bytes <= 0 && errno != EAGAIN && errno != EINTR)
+		{
+			eDebug("error reading from DMX handle %d, errno %d: %m", fd, errno);
+			break;
+		}
+
+		if (bytes > 0)
+		{
+			if ((bytes % 188) != 0)
+				eDebug("incomplete packet read from %d with size %d", fd, bytes);
+
+			m_packet_no++;
+			it++;
+			for (i = 0; i < bytes; i += 188)
+			{
+				b = buf + 16 + i;
+				int pid = (b[1] & 0x1F) * 256 + b[2];
+
+				if ((b[3] & 0x80)) // mark decryption failed if not decrypted by enigma
+				{
+					if ((errs++ % 100) == 0)
+						eDebug("decrypt errs %d, pid %d, m_buffer %p, pos %d, buf %p, i %d: %02X %02X %02X %02X", errs, pid, m_buffer, pos, buf, i, b[0], b[1], b[2], b[3]);
+					b[1] |= 0x1F;
+					b[2] |= 0xFF;
+				}
+			}
+			buf[0] = 0x24;
+			buf[1] = 0;
+			copy16(buf, 2, (uint16_t)(bytes + 12));
+			copy16(buf, 4, 0x8021);
+			copy16(buf, 6, m_stream_id);
+			copy32(buf, 8, cnt);
+			copy32(buf, 12, m_session_id);
+			cnt++;
+			pos += bytes + 16;
+		}
+		if (m_reply.size() > 0)
+		{
+			pos = m_reply.size();
+			buf[0] = 0;
+			memcpy(m_buffer, m_reply.data(), pos);
+			eDebug("added reply of %d bytes", pos, m_buffer);
+			m_reply.clear();
+			break; // reply to the server ASAP
+		}
+		uint64_t ts = getTick() - start;
+
+		if ((pos > 0) && (bytes == -1) && (ts > 50)) // do not block more than 50ms if there is available data
+			break;
+
+		if (bytes < 0)
+			usleep(5000);
+	}
+	uint64_t ts = getTick() - start;
+	if (ts > 1000)
+		eDebug("returning %d bytes from %d, last read %d bytes in %jd ms (iteration %d)", pos, size, bytes, ts, m_packet_no);
+	if (pos == 0)
+		return bytes;
+	return pos;
 }
 
 void eFilePushThreadRecorder::thread()
@@ -387,23 +549,34 @@ void eFilePushThreadRecorder::thread()
 	sigaction(SIGUSR1, &act, 0);
 
 	hasStarted();
-
+	if (m_protocol == _PROTO_RTSP_TCP)
+	{
+		int flags = fcntl(m_fd_source, F_GETFL, 0);
+		flags |= O_NONBLOCK;
+		if (fcntl(m_fd_source, F_SETFL, flags) == -1)
+			eDebug("failed setting DMX handle %d in non-blocking mode, error %d: %s", m_fd_source, errno, strerror(errno));
+	}
 	/* m_stop must be evaluated after each syscall. */
 	while (!m_stop)
 	{
-		ssize_t bytes = ::read(m_fd_source, m_buffer, m_buffersize);
+		ssize_t bytes;
+		if (m_protocol == _PROTO_RTSP_TCP)
+			bytes = read_dmx(m_fd_source, m_buffer, m_buffersize);
+		else
+			bytes = ::read(m_fd_source, m_buffer, m_buffersize);
 		if (bytes < 0)
 		{
 			bytes = 0;
 			/* Check m_stop after interrupted syscall. */
-			if (m_stop) {
+			if (m_stop)
+			{
 				break;
 			}
 			if (errno == EINTR || errno == EBUSY || errno == EAGAIN)
 #if HAVE_HISILICON
 				usleep(100000);
 #endif
-				continue;
+			continue;
 			if (errno == EOVERFLOW)
 			{
 				eWarning("[eFilePushThreadRecorder] OVERFLOW while recording");
diff --git a/lib/dvb/filepush.h b/lib/dvb/filepush.h
index 923612c..81887cd 100644
--- a/lib/dvb/filepush.h
+++ b/lib/dvb/filepush.h
@@ -82,7 +82,14 @@ public:
 	enum { evtEOF, evtReadError, evtWriteError, evtUser, evtStopped };
 	sigc::signal1<void,int> m_event;
 
+	int getProtocol() { return m_protocol;}
+        void setProtocol(int i){ m_protocol = i;}
+        void setSession(int se, int st) { m_session_id = se; m_stream_id = st;}
+	int read_dmx(int fd, void *m_buffer, int size);
+	int pushReply(void *buf, int len);	
 	void sendEvent(int evt);
+	static int64_t getTick();
+	static int read_ts(int fd, unsigned char *buf, int size);
 protected:
 	// This method should write the data out and return the number of bytes written.
 	// If result <0, set 'errno'. The simplest implementation is just "::write(m_buffer, ...)"
@@ -100,6 +107,8 @@ private:
 	int m_stop;
 	eFixedMessagePump<int> m_messagepump;
 	void recvEvent(const int &evt);
+	int m_protocol, m_session_id, m_stream_id, m_packet_no;
+	std::vector<unsigned char> m_reply;
 };
 
 #endif
diff --git a/lib/dvb/frontend.cpp b/lib/dvb/frontend.cpp
index c8f2254..c03c828 100644
--- a/lib/dvb/frontend.cpp
+++ b/lib/dvb/frontend.cpp
@@ -103,17 +103,17 @@ void eDVBDiseqcCommand::setCommandString(const char *str)
 
 void eDVBFrontendParametersSatellite::set(const S2SatelliteDeliverySystemDescriptor &descriptor)
 {
-	if(descriptor.getScramblingSequenceSelector())
+	if(descriptor.getScramblingSequenceSelector()) // EN 300 468 table 41
 	{
 		is_id = descriptor.getInputStreamIdentifier();
-		pls_mode = eDVBFrontendParametersSatellite::PLS_Root;
+		pls_mode = eDVBFrontendParametersSatellite::PLS_Gold;
 		pls_code = descriptor.getScramblingSequenceIndex();
 	}
-	else
+	else // default DVB-S2 physical layer scrambling sequence of index n = 0 is used
 	{
-		is_id = 0; //NO_STREAM_ID_FILTER;
-		pls_mode = eDVBFrontendParametersSatellite::PLS_Root;
-		pls_code = 1;
+		is_id = NO_STREAM_ID_FILTER;
+		pls_mode = eDVBFrontendParametersSatellite::PLS_Gold;
+		pls_code = 0;
 	}
 }
 
@@ -141,9 +141,9 @@ void eDVBFrontendParametersSatellite::set(const SatelliteDeliverySystemDescripto
 		modulation = Modulation_QPSK;
 	}
 	rolloff = descriptor.getRollOff();
-	is_id = 0; //NO_STREAM_ID_FILTER;
-	pls_mode = eDVBFrontendParametersSatellite::PLS_Root;
-	pls_code = 1;
+	is_id = NO_STREAM_ID_FILTER;
+	pls_mode = eDVBFrontendParametersSatellite::PLS_Gold;
+	pls_code = 0;
 	if (system == System_DVB_S2)
 	{
 		eDebug("[eDVBFrontendParametersSatellite] SAT DVB-S2 freq %d, %s, pos %d, sr %d, fec %d, modulation %d, rolloff %d, is_id %d, pls_mode %d, pls_code %d",
@@ -578,8 +578,11 @@ int eDVBFrontend::PreferredFrontendIndex = -1;
 
 eDVBFrontend::eDVBFrontend(const char *devicenodename, int fe, int &ok, bool simulate, eDVBFrontend *simulate_fe)
 	:m_simulate(simulate), m_enabled(false), m_fbc(false), m_simulate_fe(simulate_fe), m_type(-1), m_dvbid(fe), m_slotid(fe)
-	,m_fd(-1), m_teakover(0), m_waitteakover(0), m_break_teakover(0), m_break_waitteakover(0), m_dvbversion(0), m_rotor_mode(false)
+	,m_fd(-1), m_teakover(0), m_waitteakover(0), m_break_teakover(0), m_break_waitteakover(0), m_dvbversion(0), m_configRetuneNoPatEntry(0), m_rotor_mode(false)
 	,m_need_rotor_workaround(false), m_need_delivery_system_workaround(false), m_multitype(false), m_state(stateClosed), m_timeout(0), m_tuneTimer(0)
+#if HAVE_ALIEN5
+	,m_looptimeout(100)
+#endif
 {
 	m_DebugOptions = (1ULL << static_cast<int>(enumDebugOptions::DEBUG_DELIVERY_SYSTEM));
 	m_filename = devicenodename;
@@ -1020,6 +1023,9 @@ void eDVBFrontend::feEvent(int w)
 	eDVBFrontend *sec_fe = this;
 	long tmp = m_data[LINKED_PREV_PTR];
 #if HAVE_AMLOGIC
+#if HAVE_ALIEN5
+static int timeoutNum = 0;
+#endif
 			if (w < 0)
 				return;
 #endif
@@ -1035,6 +1041,9 @@ void eDVBFrontend::feEvent(int w)
 		int res;
 		int state;
 #if HAVE_AMLOGIC
+#if HAVE_ALIEN5
+		usleep(20000);
+#endif
 		if((res = ::ioctl(m_fd, FE_READ_STATUS, &event.status)) != 0)
 		{
 			break;
@@ -1072,6 +1081,27 @@ void eDVBFrontend::feEvent(int w)
 #endif
 		else
 		{
+#if HAVE_ALIEN5
+			if (m_tuning) {
+				state = stateTuning;
+				if (event.status & FE_TIMEDOUT) {
+				//if (m_tuning >=100) {
+					if (m_looptimeout == 0){
+						eDebug("[eDVBFrontend] FE_TIMEDOUT! ..abort");
+						m_tuneTimer->stop();
+						timeout();
+						//m_looptimeout=0;
+						return;
+					}
+					else{
+						m_looptimeout--;
+					}
+				
+				}
+				++m_tuning;
+				break;
+			}
+#else
 			if (m_tuning) {
 				state = stateTuning;
 				if (event.status & FE_TIMEDOUT) {
@@ -1082,12 +1112,17 @@ void eDVBFrontend::feEvent(int w)
 				}
 				++m_tuning;
 			}
+#endif
 			else
 			{
 				eDebug("[eDVBFrontend] stateLostLock");
 				state = stateLostLock;
 				if (!m_rotor_mode)
 					sec_fe->m_data[CSW] = sec_fe->m_data[UCSW] = sec_fe->m_data[TONEBURST] = -1; // reset diseqc
+#if HAVE_ALIEN5
+				if(m_state == state)
+					break; /* I do not see any other way out */
+#endif
 			}
 		}
 		if (m_state != state)
@@ -1103,10 +1138,33 @@ void eDVBFrontend::timeout()
 	m_tuning = 0;
 	if (m_state == stateTuning)
 	{
-		m_state = stateFailed;
-		m_data[CSW] = m_data[UCSW] = m_data[TONEBURST] = -1; // reset diseqc
-		m_stateChanged(this);
+		retune();
+	}
+}
+
+void eDVBFrontend::setConfigRetuneNoPatEntry(int value)
+{
+	eDebug("[eDVBFrontend::setConfigRetuneNoPatEntry] %d",value);
+	m_configRetuneNoPatEntry = value;
+}
+
+void eDVBFrontend::checkRetune()
+{
+	if (m_configRetuneNoPatEntry)
+	{
+		eDebug("[eDVBFrontend] start retune after tune error 3 (noPatEntry)");
+		retune();
 	}
+	else
+		eDebug("[eDVBFrontend] not retuning after tune error 3 (noPatEntry) - disabled");
+}
+
+void eDVBFrontend::retune()
+{
+	m_timeout->stop();
+	m_state = stateFailed;
+	m_data[CSW] = m_data[UCSW] = m_data[TONEBURST] = -1; // reset diseqc
+	m_stateChanged(this);
 }
 
 #define INRANGE(X,Y,Z) (((X<=Y) && (Y<=Z))||((Z<=Y) && (Y<=X)) ? 1 : 0)
@@ -1367,18 +1425,28 @@ void eDVBFrontend::calculateSignalQuality(int snr, int &signalquality, int &sign
 		|| !strcmp(m_description, "BCM7362 DVB-S2 NIM (internal)")
 		|| !strcmp(m_description, "GIGA DVB-S2 NIM (Internal)")
 		|| !strcmp(m_description, "GIGA DVB-S2 NIM (SP2246T)")
-		) // Gigablue
+		|| !strcmp(m_description, "GIGA DVB-S2 NIM (TS2M08)")
+		)
 	{
-		ret = (int)((((double(snr) / (65535.0 / 100.0)) * 0.1800) - 1.0000) * 100);
+		ret = (int)((((double(snr) / (65535.0 / 100.0)) * 0.1710) - 1.0000) * 100);
 	}
-	else if (!strcmp(m_description, "DVB-S2 NIM(45208 FBC)"))
+	else if (!strcmp(m_description, "DVB-S2 NIM(45208 FBC)")
+		|| !strcmp(m_description, "DVB-S2 NIM(45308 FBC)")
+		)
 	{
 		ret = (int)((((double(snr) / (65535.0 / 100.0)) * 0.1950) - 1.0000) * 100);
 	}
-	else if (strstr(m_description, "GIGA DVB-C/T NIM (SP8221L)")
-		|| strstr(m_description, "GIGA DVB-C/T NIM (SI4765)")
-		|| strstr(m_description, "GIGA DVB-C/T NIM (SI41652)")
-		|| strstr(m_description, "GIGA DVB-C/T2 NIM (SI4768)")
+	else if (!strcmp(m_description, "DVB-C NIM(3128 FBC)"))
+	{
+		ret = (int)(snr / 17);
+	}
+	else if (!strcmp(m_description, "GIGA DVB-C/T NIM (SP8221L)")
+		|| !strcmp(m_description, "GIGA DVB-C/T NIM (SI4765)")
+		|| !strcmp(m_description, "GIGA DVB-C/T NIM (SI41652)")
+		|| !strcmp(m_description, "GIGA DVB-C/T2 NIM (SI4768)")
+		|| !strcmp(m_description, "GIGA DVB-C/T2 NIM (SI41682)")
+		|| !strcmp(m_description, "GIGA DVB-T2/C NIM (TT2L10)")
+		|| !strcmp(m_description, "GIGA DVB-T2/C NIM (TT3L10)")
 		)
 	{
 		int type = -1;
@@ -1390,7 +1458,7 @@ void eDVBFrontend::calculateSignalQuality(int snr, int &signalquality, int &sign
 				cab_max = 4200;
 				break;
 			case feTerrestrial:
-				ret = (int)(snr / 75);
+				ret = (int)(snr / 30);
 				ter_max = 1700;
 				break;
 		}
@@ -1510,6 +1578,11 @@ void eDVBFrontend::calculateSignalQuality(int snr, int &signalquality, int &sign
 				break;
 		}
 	}
+	else if (!strncmp(m_description, "Si2166D", 7)) // SF8008 S2
+	{
+		ret = snr;
+		sat_max = 1620;
+	}
 	else if (!strncmp(m_description, "Si216", 5)) // all new Models with SI Tuners
 	{
 		ret = snr;
@@ -1689,10 +1762,29 @@ int eDVBFrontend::readFrontendData(int type)
 			if (!m_simulate)
 			{
 				ioctlMeasureStart;
+#if HAVE_ALIEN5
+				//static int timeoutNum =0 ;
+				usleep(20000);
+				if ( ioctl(m_fd, FE_READ_STATUS, &status) < 0 && errno != ERANGE )
+					eDebug("[eDVBFrontend] FE_READ_STATUS failed (%m)");
+				if (status & FE_TIMEDOUT) {
+				//if (m_tuning >=100) {
+					if (m_looptimeout == 0){
+					
+						ioctlMeasureEval("FE_READ_STATUS");
+						return (int)status;
+					}
+					else{
+						m_looptimeout--;
+					}
+				
+				}
+#else
 				if ( ioctl(m_fd, FE_READ_STATUS, &status) < 0 && errno != ERANGE )
 					eDebug("[eDVBFrontend] FE_READ_STATUS failed (%m)");
 				ioctlMeasureEval("FE_READ_STATUS");
 				return (int)status;
+#endif
 			}
 			return (FE_HAS_SYNC | FE_HAS_LOCK);
 		}
@@ -2146,6 +2238,64 @@ int eDVBFrontend::tuneLoopInt()  // called by m_tuneTimer
 					setSecSequencePos(m_sec_sequence.current()->steps);
 				break;
 			}
+			case eSecCommand::IF_LOCK_TIMEOUT_GOTO:
+				if (!m_simulate)
+				{
+					bool timeout = false;
+					while (1)
+					{
+						dvb_frontend_event event;
+						int res;
+#if HAVE_ALIEN5
+						usleep(20000);
+						if((res = ::ioctl(m_fd, FE_READ_STATUS, &event.status)) != 0)
+						{
+							break;
+						}
+						else
+						{
+							if(event.status == 0)
+							{
+								break;
+							}
+						}
+						if (event.status & FE_TIMEDOUT) {
+						//if (m_tuning >=100) {
+							if (m_looptimeout == 0){
+								eDebugNoSimulate("[eDVBFrontend] IF_LOCK_TIMEOUT_GOTO: got FE_TIMEDOUT");
+								setSecSequencePos(m_sec_sequence.current()->steps);
+								timeout = true;
+								//m_looptimeout=100;
+								break;
+							}
+							else{
+								m_looptimeout--;
+							}
+							break;
+						}
+						if (event.status & FE_HAS_LOCK)
+						{
+							break; /* I do not see any other way out */
+						}
+#else
+						res = ::ioctl(m_fd, FE_GET_EVENT, &event);
+
+						if (res && (errno == EAGAIN))
+							break;
+
+						if (event.status & FE_TIMEDOUT)
+						{
+							eDebugNoSimulate("[eDVBFrontend] IF_LOCK_TIMEOUT_GOTO: got FE_TIMEDOUT");
+							setSecSequencePos(m_sec_sequence.current()->steps);
+							timeout = true;
+							break;
+						}
+#endif
+					}
+					if (timeout) break;
+				}
+				++m_sec_sequence.current();
+				break;
 			case eSecCommand::MEASURE_RUNNING_INPUTPOWER:
 				m_runningInputpower = sec_fe->readInputpower();
 				eDebugNoSimulate("[SEC] runningInputpower is %d", m_runningInputpower);
@@ -2453,6 +2603,9 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 		cmdseq.props = p;
 		cmdseq.num = 0;
 		p[cmdseq.num].cmd = DTV_CLEAR, cmdseq.num++;
+#if HAVE_ALIEN5
+		m_looptimeout = 100;
+#endif
 		if (type == iDVBFrontend::feSatellite)
 		{
 			eDVBFrontendParametersSatellite parm;
@@ -2461,7 +2614,15 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 			fe_modulation_t modulation = QPSK;
 			fe_delivery_system_t system = SYS_DVBS;
 			oparm.getDVBS(parm);
-
+#if HAVE_ALIEN5
+			if (parm.symbol_rate < 5000000)
+		        m_looptimeout = 250;
+		    else if (parm.symbol_rate < 10000000)
+		        m_looptimeout = 60;
+		    else
+		        m_looptimeout = 50;
+			//m_looptimeout(100);
+#endif
 			//p[cmdseq.num].cmd = DTV_LNA, p[cmdseq.num].u.data = 0, cmdseq.num++;
 			p[cmdseq.num].cmd = DTV_INVERSION;
 			switch (parm.inversion)
@@ -2543,6 +2704,9 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 		{
 			eDVBFrontendParametersCable parm;
 			oparm.getDVBC(parm);
+#if HAVE_ALIEN5
+			m_looptimeout = 300;
+#endif
 			//p[cmdseq.num].cmd = DTV_LNA, p[cmdseq.num].u.data = 0, cmdseq.num++;
 			p[cmdseq.num].cmd = DTV_FREQUENCY, p[cmdseq.num].u.data = parm.frequency * 1000, cmdseq.num++;
 
@@ -2614,6 +2778,9 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 			eDVBFrontendParametersTerrestrial parm;
 			fe_delivery_system_t system = SYS_DVBT;
 			oparm.getDVBT(parm);
+#if HAVE_ALIEN5
+			m_looptimeout = 100;
+#endif
 			switch (parm.system)
 			{
 				default:
@@ -2967,7 +3134,7 @@ RESULT eDVBFrontend::prepare_atsc(const eDVBFrontendParametersATSC &feparm)
 	return 0;
 }
 
-RESULT eDVBFrontend::tune(const iDVBFrontendParameters &where)
+RESULT eDVBFrontend::tune(const iDVBFrontendParameters &where, bool blindscan)
 {
 	unsigned int timeout = 5000;
 	int type;
@@ -3087,7 +3254,16 @@ RESULT eDVBFrontend::tune(const iDVBFrontendParameters &where)
 	}
 
 
-	where.calcLockTimeout(timeout);
+	m_blindscan = blindscan;
+	if (m_blindscan)
+	{
+		/* blindscan iterations can take a long time, use a long timeout */
+		timeout = 60000;
+	}
+	else
+	{
+		where.calcLockTimeout(timeout);
+	}
 
 	switch (type)
 	{
diff --git a/lib/dvb/frontend.h b/lib/dvb/frontend.h
index 76e3dc6..e6da9b1 100644
--- a/lib/dvb/frontend.h
+++ b/lib/dvb/frontend.h
@@ -100,6 +100,9 @@ private:
 	bool m_fbc;
 	eDVBFrontend *m_simulate_fe; // only used to set frontend type in dvb.cpp
 	int m_type;
+#if HAVE_ALIEN5
+	int m_looptimeout;
+#endif
 	int m_dvbid;
 	int m_slotid;
 	int m_fd;
@@ -112,6 +115,7 @@ private:
 	bool m_rotor_mode;
 	bool m_need_rotor_workaround;
 	bool m_need_delivery_system_workaround;
+	bool m_blindscan;
 	bool m_multitype;
 	std::map<fe_delivery_system_t, int> m_modelist;
 	std::map<fe_delivery_system_t, bool> m_delsys, m_delsys_whitelist;
@@ -137,6 +141,7 @@ private:
 
 	int m_timeoutCount; // needed for timeout
 	int m_retryCount; // diseqc retry for rotor
+	int m_configRetuneNoPatEntry;
 
 	void feEvent(int);
 	void timeout();
@@ -161,7 +166,7 @@ public:
 	int readInputpower();
 	int getCurrentType(){return m_type;}
 	void overrideType(int type){m_type = type;} //workaraound for dvb api < 5
-	RESULT tune(const iDVBFrontendParameters &where);
+	RESULT tune(const iDVBFrontendParameters &where, bool blindscan = false);
 	RESULT prepare_sat(const eDVBFrontendParametersSatellite &, unsigned int timeout);
 	RESULT prepare_cable(const eDVBFrontendParametersCable &);
 	RESULT prepare_terrestrial(const eDVBFrontendParametersTerrestrial &);
@@ -178,6 +183,9 @@ public:
 	RESULT getData(int num, long &data);
 	RESULT setData(int num, long val);
 	bool changeType(int type);
+	void checkRetune();
+	void retune();
+	void setConfigRetuneNoPatEntry(int value);
 
 	int readFrontendData(int type); // iFrontendInformation_ENUMS
 	void getFrontendStatus(ePtr<iDVBFrontendStatus> &dest);
diff --git a/lib/dvb/frontendparms.h b/lib/dvb/frontendparms.h
index 580f473..71d510d 100644
--- a/lib/dvb/frontendparms.h
+++ b/lib/dvb/frontendparms.h
@@ -58,6 +58,9 @@ struct eDVBFrontendParametersSatellite
 	enum {
 		PLS_Root, PLS_Gold, PLS_Combo, PLS_Unknown
 	};
+	enum {
+		No_Stream_Id_Filter = NO_STREAM_ID_FILTER
+	};
 
 	bool no_rotor_command_on_tune;
 	int frequency, symbol_rate;
diff --git a/lib/dvb/idvb.h b/lib/dvb/idvb.h
index 2decf92..724c3fc 100644
--- a/lib/dvb/idvb.h
+++ b/lib/dvb/idvb.h
@@ -281,7 +281,7 @@ public:
 		cVPID, cMPEGAPID, cTPID, cPCRPID, cAC3PID,
 		cVTYPE, cACHANNEL, cAC3DELAY, cPCMDELAY,
 		cSUBTITLE, cAACHEAPID=12, cDDPPID, cAACAPID,
-		cDATAPID, cPMTPID, cacheMax
+		cDATAPID, cPMTPID, cDRAAPID, cAC4PID, cacheMax
 	};
 
 	int getCacheEntry(cacheID);
@@ -430,6 +430,7 @@ public:
 	virtual SWIG_VOID(RESULT) getDVBT(eDVBFrontendParametersTerrestrial &SWIG_OUTPUT) const = 0;
 	virtual SWIG_VOID(RESULT) getATSC(eDVBFrontendParametersATSC &SWIG_OUTPUT) const = 0;
 	virtual SWIG_VOID(RESULT) getFlags(unsigned int &SWIG_OUTPUT) const = 0;
+	virtual RESULT setDVBT(const eDVBFrontendParametersTerrestrial &p) = 0;
 #ifndef SWIG
 	virtual SWIG_VOID(RESULT) calculateDifference(const iDVBFrontendParameters *parm, int &, bool exact) const = 0;
 	virtual SWIG_VOID(RESULT) getHash(unsigned long &) const = 0;
@@ -521,7 +522,7 @@ public:
 class iDVBFrontend: public iDVBFrontend_ENUMS, public iObject
 {
 public:
-	virtual RESULT tune(const iDVBFrontendParameters &where)=0;
+	virtual RESULT tune(const iDVBFrontendParameters &where, bool blindscan = false)=0;
 	virtual int closeFrontend(bool force = false, bool no_delayed = false)=0;
 	virtual void reopenFrontend()=0;
 #ifndef SWIG
@@ -763,13 +764,15 @@ public:
 		enum { eventUnknown = 0,
 			eventSizeChanged = VIDEO_EVENT_SIZE_CHANGED,
 			eventFrameRateChanged = VIDEO_EVENT_FRAME_RATE_CHANGED,
-			eventProgressiveChanged = 16
+			eventProgressiveChanged = 16,
+			eventGammaChanged = 17
 		} type;
 		unsigned char aspect;
 		unsigned short height;
 		unsigned short width;
 		bool progressive;
 		unsigned short framerate;
+		unsigned short gamma;
 	};
 
 	virtual RESULT connectVideoEvent(const sigc::slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection) = 0;
@@ -779,6 +782,7 @@ public:
 	virtual int getVideoProgressive() = 0;
 	virtual int getVideoFrameRate() = 0;
 	virtual int getVideoAspect() = 0;
+	virtual int getVideoGamma() = 0;
 };
 
 #endif //SWIG
diff --git a/lib/dvb/pmt.cpp b/lib/dvb/pmt.cpp
index 6a330b2..0db0a18 100644
--- a/lib/dvb/pmt.cpp
+++ b/lib/dvb/pmt.cpp
@@ -200,6 +200,13 @@ void eDVBServicePMTHandler::PMTready(int error)
 void eDVBServicePMTHandler::sendEventNoPatEntry()
 {
 	serviceEvent(eventNoPATEntry);
+	
+	ePtr<iDVBFrontend> fe;
+	if (!m_channel->getFrontend(fe))
+	{
+		eDVBFrontend *frontend = (eDVBFrontend*)&(*fe);
+		frontend->checkRetune();
+	}
 }
 
 void eDVBServicePMTHandler::PATready(int)
@@ -278,7 +285,7 @@ void saveData(int orgid, unsigned char* data, int sectionLength)
 		data[7] = data[6];
 	}
 
-	if((fd = open(fileName, O_RDWR|O_CREAT|O_TRUNC)) < 0)
+	if((fd = open(fileName, O_RDWR|O_CREAT|O_TRUNC, 0644)) < 0)
 	{
 		eDebug("[eDVBServicePMTHandler] Fail to save a AIT Data.");
 		return;
@@ -312,7 +319,7 @@ void eDVBServicePMTHandler::AITready(int error)
 			eDebug("[eDVBServicePMTHandler] Section Length : %d, Total Section Length : %d", (*it)->getSectionLength(), sectionLength);
 			for (; i != (*it)->getApplicationInformation()->end(); ++i)
 			{
-				std::string hbbtvUrl = "", applicaionName = "";
+				std::string hbbtvUrl = "", applicationName = "";
                                 std::string boundaryExtension = "";
 
 				int controlCode = (*i)->getApplicationControlCode();
@@ -354,8 +361,8 @@ void eDVBServicePMTHandler::AITready(int error)
 							ApplicationNameConstIterator interactionit = nameDescriptor->getApplicationNames()->begin();
 							for(; interactionit != nameDescriptor->getApplicationNames()->end(); ++interactionit)
 							{
-								applicaionName = (*interactionit)->getApplicationName();
-								if(controlCode == 1) m_ApplicationName = applicaionName;
+								applicationName = (*interactionit)->getApplicationName();
+								if(controlCode == 1) m_ApplicationName = applicationName;
 								break;
 							}
 							break;
@@ -406,7 +413,7 @@ void eDVBServicePMTHandler::AITready(int error)
 					const char* uu = hbbtvUrl.c_str();
 					struct aitInfo aitinfo;
 					aitinfo.id = appid;
-					aitinfo.name = applicaionName;
+					aitinfo.name = applicationName;
 					aitinfo.url = hbbtvUrl;
 					m_aitInfoList.push_back(aitinfo);
 					if(!strncmp(uu, "http://", 7) || !strncmp(uu, "dvb://", 6) || !strncmp(uu, "https://", 8))
@@ -416,12 +423,12 @@ void eDVBServicePMTHandler::AITready(int error)
 						{
 							case 65793:
 							case 66049:
-								m_HbbTVApplications.push_back(new HbbTVApplicationInfo(controlCode, orgid, appid, hbbtvUrl, applicaionName, profilecode));
+								m_HbbTVApplications.push_back(new HbbTVApplicationInfo(controlCode, orgid, appid, hbbtvUrl, applicationName, profilecode));
 								break;
 							case 1280:
 							case 65538:
 							default:
-								m_HbbTVApplications.push_back(new HbbTVApplicationInfo((-1)*controlCode, orgid, appid, hbbtvUrl, applicaionName, profilecode));
+								m_HbbTVApplications.push_back(new HbbTVApplicationInfo((-1)*controlCode, orgid, appid, hbbtvUrl, applicationName, profilecode));
 								break;
 						}
 					}
@@ -437,12 +444,12 @@ void eDVBServicePMTHandler::AITready(int error)
 						{
 							case 65793:
 							case 66049:
-								m_HbbTVApplications.push_back(new HbbTVApplicationInfo(controlCode, orgid, appid, boundaryExtension, applicaionName, profilecode));
+								m_HbbTVApplications.push_back(new HbbTVApplicationInfo(controlCode, orgid, appid, boundaryExtension, applicationName, profilecode));
 								break;
 							case 1280:
 							case 65538:
 							default:
-								m_HbbTVApplications.push_back(new HbbTVApplicationInfo((-1)*controlCode, orgid, appid, boundaryExtension, applicaionName, profilecode));
+								m_HbbTVApplications.push_back(new HbbTVApplicationInfo((-1)*controlCode, orgid, appid, boundaryExtension, applicationName, profilecode));
 								break;
 						}
 					}
@@ -526,10 +533,12 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 {
 //	ePtr<eTable<ProgramMapSection> > ptr;
 	int cached_apid_ac3 = -1;
+	int cached_apid_ac4 = -1;
 	int cached_apid_ddp = -1;
 	int cached_apid_mpeg = -1;
 	int cached_apid_aache = -1;
 	int cached_apid_aac = -1;
+	int cached_apid_dra = -1;
 	int cached_vpid = -1;
 	int cached_tpid = -1;
 	int ret = -1;
@@ -548,9 +557,11 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 		cached_vpid = m_service->getCacheEntry(eDVBService::cVPID);
 		cached_apid_mpeg = m_service->getCacheEntry(eDVBService::cMPEGAPID);
 		cached_apid_ac3 = m_service->getCacheEntry(eDVBService::cAC3PID);
+		cached_apid_ac4 = m_service->getCacheEntry(eDVBService::cAC4PID);
 		cached_apid_ddp = m_service->getCacheEntry(eDVBService::cDDPPID);
 		cached_apid_aache = m_service->getCacheEntry(eDVBService::cAACHEAPID);
 		cached_apid_aac = m_service->getCacheEntry(eDVBService::cAACAPID);
+		cached_apid_dra = m_service->getCacheEntry(eDVBService::cDRAAPID);
 		cached_tpid = m_service->getCacheEntry(eDVBService::cTPID);
 	}
 
@@ -561,24 +572,27 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 		int audio_cached = -1;
 		int autoaudio_mpeg = -1;
 		int autoaudio_ac3 = -1;
+		int autoaudio_ac4 = -1;
 		int autoaudio_ddp = -1;
 		int autoaudio_aache = -1;
 		int autoaudio_aac = -1;
+		int autoaudio_dra = -1;
 		int autoaudio_level = 4;
+		int *autoaudio = NULL;
 
 		std::string configvalue;
 		std::vector<std::string> autoaudio_languages;
 		configvalue = eConfigManager::getConfigValue("config.autolanguage.audio_autoselect1");
-		if (configvalue != "" && configvalue != "None")
+		if (configvalue != "" && configvalue != "---")
 			autoaudio_languages.push_back(configvalue);
 		configvalue = eConfigManager::getConfigValue("config.autolanguage.audio_autoselect2");
-		if (configvalue != "" && configvalue != "None")
+		if (configvalue != "" && configvalue != "---")
 			autoaudio_languages.push_back(configvalue);
 		configvalue = eConfigManager::getConfigValue("config.autolanguage.audio_autoselect3");
-		if (configvalue != "" && configvalue != "None")
+		if (configvalue != "" && configvalue != "---")
 			autoaudio_languages.push_back(configvalue);
 		configvalue = eConfigManager::getConfigValue("config.autolanguage.audio_autoselect4");
-		if (configvalue != "" && configvalue != "None")
+		if (configvalue != "" && configvalue != "---")
 			autoaudio_languages.push_back(configvalue);
 
 		int autosub_txt_normal = -1;
@@ -624,10 +638,12 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 		for (i = 0; i < program.audioStreams.size(); i++)
 		{
 			if (program.audioStreams[i].pid == cached_apid_ac3
+			 || program.audioStreams[i].pid == cached_apid_ac4
 			 || program.audioStreams[i].pid == cached_apid_ddp
 			 || program.audioStreams[i].pid == cached_apid_mpeg
 			 || program.audioStreams[i].pid == cached_apid_aache
-			 || program.audioStreams[i].pid == cached_apid_aac)
+			 || program.audioStreams[i].pid == cached_apid_aac
+			 || program.audioStreams[i].pid == cached_apid_dra)
 			{
 				/* if we find the cached pids, this will be our default stream */
 				audio_cached = i;
@@ -635,9 +651,11 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 			/* also, we need to know the first non-mpeg (i.e. "ac3"/dts/...) stream */
 			if ((program.audioStreams[i].type != audioStream::atMPEG) && ((first_non_mpeg == -1)
 				|| (program.audioStreams[i].pid == cached_apid_ac3)
+				|| (program.audioStreams[i].pid == cached_apid_ac4)
 				|| (program.audioStreams[i].pid == cached_apid_ddp)
 				|| (program.audioStreams[i].pid == cached_apid_aache)
-				|| (program.audioStreams[i].pid == cached_apid_aac)))
+				|| (program.audioStreams[i].pid == cached_apid_aac)
+				|| (program.audioStreams[i].pid == cached_apid_dra)))
 			{
 				first_non_mpeg = i;
 			}
@@ -646,18 +664,36 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 				int x = 1;
 				for (std::vector<std::string>::iterator it = autoaudio_languages.begin();x <= autoaudio_level && it != autoaudio_languages.end();x++,it++)
 				{
-					if ((*it).find(program.audioStreams[i].language_code) != std::string::npos)
+					if ((*it).find(program.audioStreams[i].language_code.substr(0, program.audioStreams[i].language_code.find('/'))) != std::string::npos)
 					{
-						if (program.audioStreams[i].type == audioStream::atMPEG && (autoaudio_level > x || autoaudio_mpeg == -1))
+						if (program.audioStreams[i].type == audioStream::atMPEG && (autoaudio_level >= x || autoaudio_mpeg == -1)) {
 							autoaudio_mpeg = i;
-						else if (program.audioStreams[i].type == audioStream::atAC3 && (autoaudio_level > x || autoaudio_ac3 == -1))
+							autoaudio = &autoaudio_mpeg;
+						}
+						else if (program.audioStreams[i].type == audioStream::atAC3 && (autoaudio_level >= x || autoaudio_ac3 == -1)) {
 							autoaudio_ac3 = i;
-						else if (program.audioStreams[i].type == audioStream::atDDP && (autoaudio_level > x || autoaudio_ddp == -1))
+							autoaudio = &autoaudio_ac3;
+						}
+						else if (program.audioStreams[i].type == audioStream::atAC4 && (autoaudio_level > x || autoaudio_ac4 == -1)) {
+								autoaudio_ac4 = i;
+								autoaudio = &autoaudio_ac4;
+						}
+						else if (program.audioStreams[i].type == audioStream::atDDP && (autoaudio_level >= x || autoaudio_ddp == -1)) {
 							autoaudio_ddp = i;
-						else if (program.audioStreams[i].type == audioStream::atAACHE && (autoaudio_level > x || autoaudio_aache == -1))
+							autoaudio = &autoaudio_ddp;
+						}
+						else if (program.audioStreams[i].type == audioStream::atAACHE && (autoaudio_level >= x || autoaudio_aache == -1)) {
 							autoaudio_aache = i;
-						else if (program.audioStreams[i].type == audioStream::atAAC && (autoaudio_level > x || autoaudio_aac == -1))
+							autoaudio = &autoaudio_aache;
+						}
+						else if (program.audioStreams[i].type == audioStream::atAAC && (autoaudio_level >= x || autoaudio_aac == -1)) {
 							autoaudio_aac = i;
+							autoaudio = &autoaudio_aac;
+						}
+						else if (program.audioStreams[i].type == audioStream::atDRA && (autoaudio_level >= x || autoaudio_dra == -1)) {
+							autoaudio_dra = i;
+							autoaudio = &autoaudio_dra;
+						}
 						autoaudio_level = x;
 						break;
 					}
@@ -704,20 +740,14 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 			program.defaultAudioStream = audio_cached;
 		else if (defaultac3 && autoaudio_ac3 != -1)
 			program.defaultAudioStream = autoaudio_ac3;
+		else if (autoaudio_ac4 != -1)
+				program.defaultAudioStream = autoaudio_ac4;
 		else if (defaultddp && autoaudio_ddp != -1)
 			program.defaultAudioStream = autoaudio_ddp;
 		else
 		{
-			if (autoaudio_mpeg != -1)
-				program.defaultAudioStream = autoaudio_mpeg;
-			else if (autoaudio_ac3 != -1)
-				program.defaultAudioStream = autoaudio_ac3;
-			else if (autoaudio_ddp != -1)
-				program.defaultAudioStream = autoaudio_ddp;
-			else if (autoaudio_aache != -1)
-				program.defaultAudioStream = autoaudio_aache;
-			else if (autoaudio_aac != -1)
-				program.defaultAudioStream = autoaudio_aac;
+			if (autoaudio != NULL)
+				program.defaultAudioStream = *autoaudio;
 			else if (first_non_mpeg != -1 && (defaultac3 || defaultddp))
 				program.defaultAudioStream = first_non_mpeg;
 		}
@@ -792,6 +822,15 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 			program.audioStreams.push_back(s);
 			++cnt;
 		}
+		if ( cached_apid_ac4 != -1 )
+		{
+			audioStream s;
+			s.type = audioStream::atAC4;
+			s.pid = cached_apid_ac4;
+			s.rdsPid = -1;
+			program.audioStreams.push_back(s);
+			++cnt;
+		}
 		if ( cached_apid_ddp != -1 )
 		{
 			audioStream s;
@@ -819,6 +858,15 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 			program.audioStreams.push_back(s);
 			++cnt;
 		}
+		if ( cached_apid_dra != -1 )
+		{
+			audioStream s;
+			s.type = audioStream::atDRA;
+			s.pid = cached_apid_dra;
+			s.rdsPid = -1;
+			program.audioStreams.push_back(s);
+			++cnt;
+		}
 		if ( cached_apid_mpeg != -1 )
 		{
 			audioStream s;
diff --git a/lib/dvb/pmt.h b/lib/dvb/pmt.h
index 4da7198..bb7664d 100644
--- a/lib/dvb/pmt.h
+++ b/lib/dvb/pmt.h
@@ -66,6 +66,7 @@ class eDVBServicePMTHandler: public eDVBPMTParser
 {
 #ifndef SWIG
 	friend class eDVBCAService;
+	friend class eRTSPStreamClient;
 	eServiceReferenceDVB m_reference;
 	ePtr<eDVBService> m_service;
 
diff --git a/lib/dvb/pmtparse.cpp b/lib/dvb/pmtparse.cpp
index d647bee..3ae8492 100644
--- a/lib/dvb/pmtparse.cpp
+++ b/lib/dvb/pmtparse.cpp
@@ -46,7 +46,7 @@ void eDVBPMTParser::processCaDescriptor(program &program, CaDescriptor *descr)
 	pair.databytes.clear();
 	for(std::vector<unsigned char>::const_iterator it = descr->getCaDataBytes()->begin(); it != descr->getCaDataBytes()->end(); ++it)
 	{
-		char t[2];
+		char t[3];
 		sprintf(t, "%02X", *it);
 		pair.databytes += t;
 	}
@@ -230,8 +230,8 @@ int eDVBPMTParser::getProgramInfo(program &program)
 									s.subtitling_type = (*it)->getSubtitlingType();
 									switch(s.subtitling_type)
 									{
-									case 0x10 ... 0x13: // dvb subtitles normal
-									case 0x20 ... 0x23: // dvb subtitles hearing impaired
+									case 0x10 ... 0x15: // dvb subtitles normal
+									case 0x20 ... 0x25: // dvb subtitles hearing impaired
 										break;
 									default:
 										eDebug("[eDVBPMTParser] dvb subtitle %s PID %04x with wrong subtitling type (%02x)... force 0x10!!",
@@ -316,6 +316,10 @@ int eDVBPMTParser::getProgramInfo(program &program)
 									isaudio = 1;
 									audio.type = audioStream::atLPCM;
 									break;
+								case 0x44524131: /*DRA is "DRA1"*/
+									isaudio = 1;
+									audio.type = audioStream::atDRA;
+									break;
 								case 0x56432d31: // == 'VC-1'
 								{
 									const AdditionalIdentificationInfoVector *vec = d->getAdditionalIdentificationInfo();
@@ -346,6 +350,24 @@ int eDVBPMTParser::getProgramInfo(program &program)
 								isvideo = 1;
 								video.type = videoStream::vtMPEG4_Part2;
 								break;
+							case EXTENSION_DESCRIPTOR:
+							{
+								ExtensionDescriptor &d = (ExtensionDescriptor&)*desc;
+								switch (d.getExtensionTag())
+								{
+								case 0x15: /* AC-4 descriptor */
+									if (!isvideo && !isaudio)
+									{
+										isaudio = 1;
+										audio.type = audioStream::atAC4;
+									}
+									break;
+								default:
+									eDebug("[eDVBPMTParser] TODO: Fix parsing for Extension descriptor with tag: %d", d.getExtensionTag());
+									break;
+								}
+								break;
+							}
 							default:
 								break;
 							}
@@ -388,6 +410,13 @@ int eDVBPMTParser::getProgramInfo(program &program)
 						prev_audio->rdsPid = (*es)->getPid();
 						eDebug("[eDVBPMTParser] Rds PID %04x detected ? ! ?", prev_audio->rdsPid);
 					}
+					//HEVC 4K for Topway
+					if (!num_descriptors && streamtype == 0xEA && !isvideo && !isaudio)
+					{
+						isvideo = 1;
+						video.type = videoStream::vtH265_HEVC;
+					}		
+					
 					prev_audio = 0;
 					break;
 				}
diff --git a/lib/dvb/pmtparse.h b/lib/dvb/pmtparse.h
index 8b57610..9ee59c9 100644
--- a/lib/dvb/pmtparse.h
+++ b/lib/dvb/pmtparse.h
@@ -24,7 +24,7 @@ public:
 	{
 		int pid;
 		int component_tag;
-		enum { vtMPEG2, vtMPEG4_H264, vtMPEG1, vtMPEG4_Part2, vtVC1, vtVC1_SM, vtH265_HEVC, vtCAVS };
+		enum { vtMPEG2, vtMPEG4_H264, vtVC1 = 3, vtMPEG4_Part2, vtVC1_SM, vtMPEG1, vtH265_HEVC, vtCAVS = 16 };
 		int type;
 	};
 
@@ -32,7 +32,7 @@ public:
 	{
 		int pid,
 		rdsPid; // hack for some radio services which transmit radiotext on different pid (i.e. harmony fm, HIT RADIO FFH, ...)
-		enum { atMPEG, atAC3, atDTS, atAAC, atAACHE, atLPCM, atDTSHD, atDDP };
+		enum { atMPEG, atAC3, atDTS, atAAC, atAACHE, atLPCM, atDTSHD, atDDP, atDRA, atAC4 };
 		int type; // mpeg2, ac3, dts, ...
 
 		int component_tag;
diff --git a/lib/dvb/pvrparse.cpp b/lib/dvb/pvrparse.cpp
index c0d0c4a..9abd7dd 100644
--- a/lib/dvb/pvrparse.cpp
+++ b/lib/dvb/pvrparse.cpp
@@ -1,4 +1,5 @@
 #include <lib/dvb/pvrparse.h>
+#include <lib/dvb/decoder.h>
 #include <lib/base/cfile.h>
 #include <lib/base/eerror.h>
 #include <sys/types.h>
@@ -943,85 +944,107 @@ int eMPEGStreamParserTS::processPacket(const unsigned char *pkt, off_t offset)
 //			eDebug("[eMPEGStreamParserTS] SC %02x %02x %02x %02x, %02x", pkt[0], pkt[1], pkt[2], pkt[3], pkt[4]);
 			unsigned int sc = pkt[3];
 
-			if (m_streamtype < 0) /* unknown */
+			if (m_streamtype == eDVBVideo::UNKNOWN)
 			{
 				if ((sc == 0x00) || (sc == 0xb3) || (sc == 0xb8))
 				{
 					eDebug("[eMPEGStreamParserTS] - detected MPEG2 stream");
-					m_streamtype = 0;
+					m_streamtype = eDVBVideo::MPEG2;
 				}
 				else if (sc == 0x09)
 				{
 					eDebug("[eMPEGStreamParserTS] - detected H264 stream");
-					m_streamtype =  1;
+					m_streamtype =  eDVBVideo::MPEG4_H264;
 				}
-				else
+				else /* TODO: detect H265 */
 					continue;
 			}
 
-			if (m_streamtype == 0) /* mpeg2 */
+
+			switch(m_streamtype)
 			{
-				if ((sc == 0x00) || (sc == 0xb3) || (sc == 0xb8)) /* picture, sequence, group start code */
+				case eDVBVideo::MPEG2:
 				{
-					if ((sc == 0xb3) && m_enable_accesspoints) /* sequence header */
+					if ((sc == 0x00) || (sc == 0xb3) || (sc == 0xb8)) /* picture, sequence, group start code */
 					{
-						if (ptsvalid)
+						if ((sc == 0xb3) && m_enable_accesspoints) /* sequence header */
+						{
+							if (ptsvalid)
+							{
+								addAccessPoint(offset, pts);
+								//eDebug("[eMPEGStreamParserTS] Sequence header at %llx, pts %llx", offset, pts);
+							}
+						}
+						if (pkt <= (end - 6))
 						{
-							addAccessPoint(offset, pts);
-							//eDebug("[eMPEGStreamParserTS] Sequence header at %llx, pts %llx", offset, pts);
+							unsigned long long data = sc | ((unsigned)pkt[4] << 8) | ((unsigned)pkt[5] << 16);
+							if (ptsvalid) // If available, add timestamp data as well. PTS = 33 bits
+								data |= (pts << 31) | 0x1000000;
+							writeStructureEntry(offset + pkt_offset, data);
+						}
+						else
+						{
+							// Returning non-zero suggests we need more data. This does not
+							// work, and never has, so we should make this a void function
+							// or fix that...
+							return 1;
 						}
 					}
-					if (pkt <= (end - 6))
+
+					break;
+				}
+
+				case eDVBVideo::MPEG4_H264:
+				{
+					if (sc == 0x09)
 					{
-						unsigned long long data = sc | ((unsigned)pkt[4] << 8) | ((unsigned)pkt[5] << 16);
+						/* store image type */
+						unsigned long long data = sc | (pkt[4] << 8);
 						if (ptsvalid) // If available, add timestamp data as well. PTS = 33 bits
 							data |= (pts << 31) | 0x1000000;
 						writeStructureEntry(offset + pkt_offset, data);
-					}
-					else
-					{
-						// Returning non-zero suggests we need more data. This does not
-						// work, and never has, so we should make this a void function
-						// or fix that...
-						return 1;
-					}
-				}
-			}
-			else if (m_streamtype == 6) /* H.265 */
-			{
-				int nal_unit_type = (sc >> 1);
-				if (nal_unit_type == 35) /* H265 NAL unit access delimiter */
-				{
-					unsigned long long data = sc | (pkt[5] << 8);
-					writeStructureEntry(offset + pkt_offset, data);
-
-					if ((pkt[5] >> 5) == 0) /* check pic_type for I-frame */
-					{
-						if (ptsvalid)
+						if ( //pkt[3] == 0x09 &&   /* MPEG4 AVC NAL unit access delimiter */
+							(pkt[4] >> 5) == 0) /* and I-frame */
 						{
-							addAccessPoint(offset, pts);
+							if (ptsvalid && m_enable_accesspoints)
+							{
+								addAccessPoint(offset, pts);
+								// eDebug("[eMPEGStreamParserTS] MPEG4 AVC UAD at %llx, pts %llx", offset, pts);
+							}
 						}
 					}
+
+					break;
 				}
-			}
-			else /* (m_streamtype == 1) means H.264 */
-			{
-				if (sc == 0x09)
+
+				case eDVBVideo::H265_HEVC:
 				{
-					/* store image type */
-					unsigned long long data = sc | (pkt[4] << 8);
-					if (ptsvalid) // If available, add timestamp data as well. PTS = 33 bits
-						data |= (pts << 31) | 0x1000000;
-					writeStructureEntry(offset + pkt_offset, data);
-					if ( //pkt[3] == 0x09 &&   /* MPEG4 AVC NAL unit access delimiter */
-						 (pkt[4] >> 5) == 0) /* and I-frame */
+					int nal_unit_type = (sc >> 1);
+					if (nal_unit_type == 35) /* H265 NAL unit access delimiter */
 					{
-						if (ptsvalid && m_enable_accesspoints)
+						unsigned long long data = sc | (pkt[5] << 8);
+						writeStructureEntry(offset + pkt_offset, data);
+
+						if ((pkt[5] >> 5) == 0) /* check pic_type for I-frame */
 						{
-							addAccessPoint(offset, pts);
-							// eDebug("[eMPEGStreamParserTS] MPEG4 AVC UAD at %llx, pts %llx", offset, pts);
+							if (ptsvalid)
+							{
+								addAccessPoint(offset, pts);
+							}
 						}
 					}
+
+					break;
+				}
+
+				case eDVBVideo::UNKNOWN:
+				case eDVBVideo::VC1:
+				case eDVBVideo::MPEG4_Part2:
+				case eDVBVideo::VC1_SM:
+				case eDVBVideo::MPEG1:
+				case eDVBVideo::AVS:
+				{
+					break; /* TODO: add parser for above codecs */
 				}
 			}
 		}
@@ -1048,7 +1071,7 @@ inline int eMPEGStreamParserTS::wantPacket(const unsigned char *pkt) const
 	if (hdr[1] & 0x40)	 /* pusi set: yes. */
 		return 1;
 
-	return m_streamtype == 0; /* we need all packets for MPEG2, but only PUSI packets for H.264 */
+	return m_streamtype == eDVBVideo::MPEG2; /* we need all packets for MPEG2, but only PUSI packets for H.264 */
 }
 
 void eMPEGStreamParserTS::parseData(off_t offset, const void *data, unsigned int len)
@@ -1182,12 +1205,14 @@ void eMPEGStreamParserTS::setPid(int _pid, iDVBTSRecorder::timing_pid_type pidty
 {
 	m_pktptr = 0;
 	/*
-	 * Currently, eMPEGStreamParserTS can only parse video, mpeg2 (streamtype 0), h264 (streamtype 1) and h265 (streamtype 6).
-	 * Also, streamtype -1 should be accepted, which will cause the streamtype to be autodetected.
+	 * Currently, eMPEGStreamParserTS can only parse video, mpeg2, h264 and h265.
+	 * Also, streamtype UNKNOWN should be accepted, which will cause the streamtype to be autodetected.
 	 * Do not try to parse audio pids, which might lead to false hits,
 	 * and waste cpu time.
 	 */
-	if (pidtype == iDVBTSRecorder::video_pid && (streamtype < 2 || streamtype == 6))
+	if (pidtype == iDVBTSRecorder::video_pid && (streamtype == eDVBVideo::UNKNOWN ||
+		streamtype == eDVBVideo::MPEG2 || streamtype == eDVBVideo::MPEG4_H264 ||
+		streamtype == eDVBVideo::H265_HEVC))
 	{
 		m_pid = _pid;
 		m_streamtype = streamtype;
@@ -1196,7 +1221,7 @@ void eMPEGStreamParserTS::setPid(int _pid, iDVBTSRecorder::timing_pid_type pidty
 	{
 		/* invalidate pid */
 		m_pid = -1;
-		m_streamtype = -1;
+		m_streamtype = eDVBVideo::UNKNOWN;
 	}
 }
 
diff --git a/lib/dvb/scan.cpp b/lib/dvb/scan.cpp
index b6a4184..860379b 100644
--- a/lib/dvb/scan.cpp
+++ b/lib/dvb/scan.cpp
@@ -153,6 +153,88 @@ void eDVBScan::stateChange(iDVBChannel *ch)
 
 	if (state == iDVBChannel::state_ok)
 	{
+		if (m_ch_current && m_channel)
+		{
+			int type;
+			m_ch_current->getSystem(type);
+			if (type == iDVBFrontend::feTerrestrial)
+			{
+				eDVBFrontendParametersTerrestrial parm;
+				m_ch_current->getDVBT(parm);
+				if (parm.system == eDVBFrontendParametersTerrestrial::System_DVB_T_T2)
+				{
+					/* we have a lock, this is a valid DVB-T transponder, set our system parameter */
+					parm.system = eDVBFrontendParametersTerrestrial::System_DVB_T;
+					m_ch_current->setDVBT(parm);
+				}
+			}
+		}
+		if (!m_ch_blindscan.empty())
+		{
+			/* update current blindscan iteration channel with scanned parameters */
+			if (m_ch_current && m_channel)
+			{
+				ePtr<iDVBFrontend> fe;
+				m_channel->getFrontend(fe);
+				if (fe)
+				{
+					ePtr<iDVBTransponderData> tp;
+					fe->getTransponderData(tp, false);
+					if (tp)
+					{
+						ePtr<eDVBFrontendParameters> feparm = new eDVBFrontendParameters;
+						int type;
+						m_ch_current->getSystem(type);
+						switch (type)
+						{
+						case iDVBFrontend::feSatellite:
+						{
+							eDVBFrontendParametersSatellite parm;
+							m_ch_current->getDVBS(parm);
+							parm.system = tp->getSystem();
+							parm.frequency = tp->getFrequency();
+							parm.symbol_rate = tp->getSymbolRate();
+							parm.modulation = tp->getModulation();
+							feparm->setDVBS(parm);
+							break;
+						}
+						case iDVBFrontend::feCable:
+						{
+							eDVBFrontendParametersCable parm;
+							m_ch_current->getDVBC(parm);
+							parm.system = tp->getSystem();
+							parm.frequency = tp->getFrequency();
+							parm.symbol_rate = tp->getSymbolRate();
+							parm.modulation = tp->getModulation();
+							feparm->setDVBC(parm);
+							break;
+						}
+						case iDVBFrontend::feTerrestrial:
+						{
+							eDVBFrontendParametersTerrestrial parm;
+							m_ch_current->getDVBT(parm);
+							parm.system = tp->getSystem();
+							parm.frequency = tp->getFrequency();
+							parm.bandwidth = tp->getBandwidth();
+							parm.modulation = tp->getConstellation();
+							feparm->setDVBT(parm);
+							break;
+						}
+						case iDVBFrontend::feATSC:
+						{
+							eDVBFrontendParametersATSC parm;
+							m_ch_current->getATSC(parm);
+							parm.system = tp->getSystem();
+							parm.frequency = tp->getFrequency();
+							feparm->setATSC(parm);
+							break;
+						}
+						}
+						m_ch_current = m_ch_blindscan_result = feparm;
+					}
+				}
+			}
+		}
 		startFilter();
 		m_channel_state = state;
 	} else if (state == iDVBChannel::state_failed)
@@ -186,6 +268,12 @@ void eDVBScan::stateChange(iDVBChannel *ch)
 				}
 			}
 		}
+		if (!m_ch_blindscan.empty())
+		{
+			/* tune failure, this means the blindscan channel iteration run has completed */
+			SCAN_eDebug("[eDVBScan] blindscan channel completed");
+			m_ch_blindscan.pop_front();
+		}
 		nextChannel();
 	}
 			/* unavailable will timeout, anyway. */
@@ -213,19 +301,27 @@ RESULT eDVBScan::nextChannel()
 	if (m_usePAT)
 		m_ready_all |= readyPAT;
 
-	if (m_ch_toScan.empty())
+	if (!m_ch_blindscan.empty())
 	{
-		SCAN_eDebug("[eDVBScan] no channels left to scan.");
-		SCAN_eDebug("[eDVBScan] %zd channels scanned, %zd were unavailable.",
-				m_ch_scanned.size(), m_ch_unavailable.size());
-		SCAN_eDebug("[eDVBScan] %zd channels in database.", m_new_channels.size());
-		m_event(evtFinish);
-		return -ENOENT;
+		/* keep iterating with the same 'channel' till we get a tune failure */
+		SCAN_eDebug("[eDVBScan] blindscan channel iteration");
+		m_ch_current = m_ch_blindscan.front();
 	}
+	else
+	{
+		m_ch_blindscan_result = NULL;
+		if (m_ch_toScan.empty())
+		{
+			SCAN_eDebug("[eDVBScan] no channels left: %zd scanned, %zd unavailable, %zd database.",
+				m_ch_scanned.size(), m_ch_unavailable.size(), m_new_channels.size());
+			m_event(evtFinish);
+			return -ENOENT;
+		}
 
-	m_ch_current = m_ch_toScan.front();
+		m_ch_current = m_ch_toScan.front();
 
-	m_ch_toScan.pop_front();
+		m_ch_toScan.pop_front();
+	}
 
 	if (m_channel->getFrontend(fe))
 	{
@@ -237,7 +333,7 @@ RESULT eDVBScan::nextChannel()
 
 	m_channel_state = iDVBChannel::state_idle;
 
-	if (fe->tune(*m_ch_current))
+	if (fe->tune(*m_ch_current, !m_ch_blindscan.empty()))
 		return nextChannel();
 
 	m_event(evtUpdate);
@@ -1040,10 +1136,10 @@ void eDVBScan::channelDone()
 					snprintf(pname, 255, "%s %s %d%c %d.%d%c",
 						parm.system ? "DVB-S2" : "DVB-S",
 						parm.modulation == eDVBFrontendParametersSatellite::Modulation_Auto ? "AUTO" :
-							eDVBFrontendParametersSatellite::Modulation_QPSK ? "QPSK" :
-							eDVBFrontendParametersSatellite::Modulation_8PSK ? "8PSK" :
-							eDVBFrontendParametersSatellite::Modulation_QAM16 ? "QAM16" :
-							eDVBFrontendParametersSatellite::Modulation_16APSK ? "16APSK" : "32APSK",
+						parm.modulation == eDVBFrontendParametersSatellite::Modulation_QPSK ? "QPSK" :
+						parm.modulation == eDVBFrontendParametersSatellite::Modulation_8PSK ? "8PSK" :
+						parm.modulation == eDVBFrontendParametersSatellite::Modulation_QAM16 ? "QAM16" :
+						parm.modulation == eDVBFrontendParametersSatellite::Modulation_16APSK ? "16APSK" : "32APSK",
 						parm.frequency/1000,
 						parm.polarisation ? 'V' : 'H',
 						parm.orbital_position/10,
@@ -1084,9 +1180,9 @@ void eDVBScan::channelDone()
 			if( m_chid_current )
 				tsonid = ( m_chid_current.transport_stream_id.get() << 16 )
 					| m_chid_current.original_network_id.get();
-			service->m_service_name = convertDVBUTF8(sname,0,tsonid,0);
+			service->m_service_name = strip_non_graph(convertDVBUTF8(sname,-1,tsonid,0));
 			service->genSortName();
-			service->m_provider_name = convertDVBUTF8(pname,0,tsonid,0);
+			service->m_provider_name = strip_non_graph(convertDVBUTF8(pname,-1,tsonid,0));
 		}
 
 		if (!(m_flags & scanOnlyFree) || !m_pmt_in_progress->second.scrambled) {
@@ -1152,11 +1248,13 @@ void eDVBScan::channelDone()
 
 void eDVBScan::start(const eSmartPtrList<iDVBFrontendParameters> &known_transponders, int flags, int networkid)
 {
+	std::list<ePtr<iDVBFrontendParameters> > *transponderlist = &m_ch_toScan;
 	m_flags = flags;
 	m_networkid = networkid;
 	m_ch_toScan.clear();
 	m_ch_scanned.clear();
 	m_ch_unavailable.clear();
+	m_ch_blindscan.clear();
 	m_new_channels.clear();
 	m_tuner_data.clear();
 	m_new_services.clear();
@@ -1181,10 +1279,45 @@ void eDVBScan::start(const eSmartPtrList<iDVBFrontendParameters> &known_transpon
 				eDebug("[eDVBScan] couldn't open file lcndb");
 		}
 	}
+
+	if (m_flags & scanBlindSearch)
+	{
+		/*
+		 * NOTE: for blindscan, the initial list of transponders does not need to contain valid transponders.
+		 * Each of the provided transponders will be iterated (i.e. tuned with blindscan parameter) several times
+		 * until a tune failure occurs. Each time a blindscan tune iteration returns ok,
+		 * a new transponder has been found and will be scanned.
+		 * Each transponder in the initial transponder list causes a full blindscan iteration run.
+		 *
+		 * Some of the parameters of the initial transponders will be used for the blindscan,
+		 * but most will be ignored.
+		 *
+		 * For DVB-S, you need to provide a list of 4 transponders for each orbital position:
+		 * one for each polarity (H/V or L/R), one for each band (hi/lo).
+		 * The frequency defines the starting frequency within the desired band.
+		 * The symbolrate defines the frequency search range, in MHz (frequency / 1000).
+		 * The polarity defines on which polarity the search should run.
+		 * All remaining transponder parameters will be ignored.
+		 * So for each orbital position, 4 blindscan iteration runs will be done, one for each polarity/band 'quadrant'.
+		 *
+		 * For DVB-C, only one initial transponder has to be provided.
+		 * The frequency defines the start of the blindscan.
+		 * The symbolrate defines the frequency search range, in MHz (frequency / 1000000).
+		 *
+		 * For DVB-T, usually only one initial transponder has to be provided.
+		 * The frequency defines the start of the blindscan.
+		 * The bandwidth defines both the search step as well as the search bandwidth.
+		 */
+
+		SCAN_eDebug("[eDVBScan] blind scan requested");
+		transponderlist = &m_ch_blindscan;
+	}
+
+
 	for (eSmartPtrList<iDVBFrontendParameters>::const_iterator i(known_transponders.begin()); i != known_transponders.end(); ++i)
 	{
 		bool exist=false;
-		for (std::list<ePtr<iDVBFrontendParameters> >::const_iterator ii(m_ch_toScan.begin()); ii != m_ch_toScan.end(); ++ii)
+		for (std::list<ePtr<iDVBFrontendParameters> >::const_iterator ii(transponderlist->begin()); ii != transponderlist->end(); ++ii)
 		{
 			if (sameChannel(*i, *ii, true))
 			{
@@ -1193,7 +1326,7 @@ void eDVBScan::start(const eSmartPtrList<iDVBFrontendParameters> &known_transpon
 			}
 		}
 		if (!exist)
-			m_ch_toScan.push_back(*i);
+			transponderlist->push_back(*i);
 	}
 
 	nextChannel();
@@ -1492,11 +1625,11 @@ RESULT eDVBScan::processSDT(eDVBNamespace dvbnamespace, const ServiceDescription
 
 					ref.setServiceType(servicetype);
 					int tsonid=(sdt.getTransportStreamId() << 16) | sdt.getOriginalNetworkId();
-					service->m_service_name = convertDVBUTF8(d.getServiceName(),0,tsonid,0);
+					service->m_service_name = strip_non_graph(convertDVBUTF8(d.getServiceName(),-1,tsonid,0));
 					service->genSortName();
 
-					service->m_provider_name = convertDVBUTF8(d.getServiceProviderName(),0,tsonid,0);
-					SCAN_eDebug("[eDVBScan] name '%s', provider_name '%s'", service->m_service_name.c_str(), service->m_provider_name.c_str());
+					service->m_provider_name = strip_non_graph(convertDVBUTF8(d.getServiceProviderName(),-1,tsonid,0));
+					SCAN_eDebug("[eDVBScan]   name '%s', provider_name '%s'", service->m_service_name.c_str(), service->m_provider_name.c_str());
 					break;
 				}
 				case CA_IDENTIFIER_DESCRIPTOR:
@@ -1685,7 +1818,12 @@ RESULT eDVBScan::getFrontend(ePtr<iDVBFrontend> &fe)
 
 RESULT eDVBScan::getCurrentTransponder(ePtr<iDVBFrontendParameters> &tp)
 {
-	if (m_ch_current)
+	if (m_ch_blindscan_result)
+	{
+		tp = m_ch_blindscan_result;
+		return 0;
+	}
+	else if (m_ch_current)
 	{
 		tp = m_ch_current;
 		return 0;
diff --git a/lib/dvb/scan.h b/lib/dvb/scan.h
index 07836c7..efcbb8b 100644
--- a/lib/dvb/scan.h
+++ b/lib/dvb/scan.h
@@ -63,8 +63,8 @@ class eDVBScan: public sigc::trackable, public iObject
 	bool m_pmt_running;
 	bool m_abort_current_pmt;
 
-	std::list<ePtr<iDVBFrontendParameters> > m_ch_toScan, m_ch_scanned, m_ch_unavailable;
-	ePtr<iDVBFrontendParameters> m_ch_current;
+	std::list<ePtr<iDVBFrontendParameters> > m_ch_toScan, m_ch_scanned, m_ch_unavailable, m_ch_blindscan;
+	ePtr<iDVBFrontendParameters> m_ch_current, m_ch_blindscan_result;
 	eDVBChannelID m_chid_current;
 	eTransportStreamID m_pat_tsid;
 
@@ -108,7 +108,8 @@ public:
 		scanNetworkSearch = 1, scanSearchBAT = 2,
 		scanRemoveServices = 4, scanDontRemoveFeeds = 8,
 		scanDontRemoveUnscanned = 16,
-		clearToScanOnFirstNIT = 32, scanOnlyFree = 64 };
+		clearToScanOnFirstNIT = 32, scanOnlyFree = 64,
+		scanBlindSearch = 128 };
 
 	void start(const eSmartPtrList<iDVBFrontendParameters> &known_transponders, int flags, int networkid = 0);
 
diff --git a/lib/dvb/sec.cpp b/lib/dvb/sec.cpp
index 20c170c..24e4a6e 100644
--- a/lib/dvb/sec.cpp
+++ b/lib/dvb/sec.cpp
@@ -516,6 +516,9 @@ RESULT eDVBSatelliteEquipmentControl::prepare(iDVBFrontend &frontend, const eDVB
 			}
 			else
 			{
+				if (!simulate)
+					((eDVBFrontend*)&frontend)->setConfigRetuneNoPatEntry(lnb_param.SatCR_RetuneNoPatEntry);
+
 				long curr_frq;
 				long curr_sym;
 				long curr_lof;
@@ -1209,17 +1212,18 @@ RESULT eDVBSatelliteEquipmentControl::prepare(iDVBFrontend &frontend, const eDVB
 					sec_sequence.push_back( eSecCommand(eSecCommand::IF_TONE_GOTO, compare) );
 					sec_sequence.push_back( eSecCommand(eSecCommand::SET_TONE, tone) );
 					sec_sequence.push_back( eSecCommand(eSecCommand::SLEEP, m_params[DELAY_AFTER_FINAL_CONT_TONE_CHANGE]) );
-					sec_sequence.push_back( eSecCommand(eSecCommand::SET_FRONTEND, 0) );
 
 					cmd.direction=1;  // check for running rotor
 					cmd.deltaA=0;
-					cmd.steps = +3;
+					cmd.steps = +4;
 					cmd.okcount=0;
 					sec_sequence.push_back( eSecCommand(eSecCommand::SET_TIMEOUT, mrt*4) );  // mrt is in seconds... our SLEEP time is 250ms.. so * 4
+					sec_sequence.push_back( eSecCommand(eSecCommand::SET_FRONTEND, 0) );
 					sec_sequence.push_back( eSecCommand(eSecCommand::SLEEP, 250) );  // 250msec delay
 					sec_sequence.push_back( eSecCommand(eSecCommand::IF_TUNER_LOCKED_GOTO, cmd ) );
-					sec_sequence.push_back( eSecCommand(eSecCommand::IF_TIMEOUT_GOTO, +5 ) );
-					sec_sequence.push_back( eSecCommand(eSecCommand::GOTO, -3) );  // goto loop start
+					sec_sequence.push_back( eSecCommand(eSecCommand::IF_TIMEOUT_GOTO, +6 ) );
+					sec_sequence.push_back( eSecCommand(eSecCommand::IF_LOCK_TIMEOUT_GOTO, -4) ); /* retune when lock timeout occurred */
+					sec_sequence.push_back( eSecCommand(eSecCommand::GOTO, -4) );  // goto loop start
 					sec_sequence.push_back( eSecCommand(eSecCommand::UPDATE_CURRENT_ROTORPARAMS) );
 					sec_sequence.push_back( eSecCommand(eSecCommand::SET_ROTOR_STOPPED) );
 					sec_sequence.push_back( eSecCommand(eSecCommand::GOTO, +4) );
@@ -1520,13 +1524,16 @@ RESULT eDVBSatelliteEquipmentControl::setLNBSatCRpositionnumber(int SatCR_positi
 	return 0;
 }
 
-RESULT eDVBSatelliteEquipmentControl::setLNBSatCRTuningAlgo(int SatCR_switch_reliable)
+RESULT eDVBSatelliteEquipmentControl::setLNBSatCRTuningAlgo(int value)
 {
-	eSecDebug("eDVBSatelliteEquipmentControl::setLNBSatCRTuningAlgo(%d)", SatCR_switch_reliable);
-	if(!((SatCR_switch_reliable >= 0) && (SatCR_switch_reliable <= 1)))
+	eSecDebug("eDVBSatelliteEquipmentControl::setLNBSatCRTuningAlgo(%d)", value);
+	if(!((value >= 0) && (value <= 3)))
 		return -EPERM;
 	if ( currentLNBValid() )
-		m_lnbs[m_lnbidx].SatCR_switch_reliable = SatCR_switch_reliable;
+		{
+			m_lnbs[m_lnbidx].SatCR_switch_reliable = value & 0x1;
+			m_lnbs[m_lnbidx].SatCR_RetuneNoPatEntry = (value >> 1) & 0x1;
+		}
 	else
 		return -ENOENT;
 	return 0;
diff --git a/lib/dvb/sec.h b/lib/dvb/sec.h
index 60d4fe3..db2018e 100644
--- a/lib/dvb/sec.h
+++ b/lib/dvb/sec.h
@@ -24,6 +24,7 @@ public:
 		UPDATE_CURRENT_SWITCHPARMS, INVALIDATE_CURRENT_SWITCHPARMS,
 		IF_ROTORPOS_VALID_GOTO,
 		IF_TUNER_LOCKED_GOTO,
+		IF_LOCK_TIMEOUT_GOTO,
 		IF_TONE_GOTO, IF_NOT_TONE_GOTO,
 		START_TUNE_TIMEOUT,
 		SET_ROTOR_MOVING,
@@ -277,6 +278,7 @@ public:
 	int SatCR_idx;
 	int SatCR_format;
 	int SatCR_switch_reliable;
+	int SatCR_RetuneNoPatEntry;
 	int BootUpTime;
 	unsigned int SatCRvco;
 	unsigned int TuningWord;
@@ -400,6 +402,7 @@ public:
 	PyObject *getFrequencyRangeList(int slot_no, int orbital_position);
 
 	friend class eFBCTunerManager;
+	friend class eRTSPStreamClient;
 
 };
 
diff --git a/lib/dvb/streamserver.cpp b/lib/dvb/streamserver.cpp
index a459b1b..71a4677 100644
--- a/lib/dvb/streamserver.cpp
+++ b/lib/dvb/streamserver.cpp
@@ -213,6 +213,7 @@ void eStreamClient::notifier(int what)
 						int framerate = 25000;
 						int interlaced = 0;
 						int aspectratio = 0;
+						std::string vcodec, acodec;
 						sscanf(request.substr(pos).c_str(), "?bitrate=%d", &bitrate);
 						pos = request.find("?width=");
 						if (pos != std::string::npos)
@@ -229,9 +230,29 @@ void eStreamClient::notifier(int what)
 						pos = request.find("?aspectratio=");
 						if (pos != std::string::npos)
 							sscanf(request.substr(pos).c_str(), "?aspectratio=%d", &aspectratio);
+						pos = request.find("?vcodec=");
+						if (pos != std::string::npos)
+						{
+							vcodec = request.substr(pos + 8);
+							pos = vcodec.find('?');
+							if (pos != std::string::npos)
+							{
+								vcodec = vcodec.substr(0, pos);
+							}
+						}
+						pos = request.find("?acodec=");
+						if (pos != std::string::npos)
+						{
+							acodec = request.substr(pos + 8);
+							pos = acodec.find('?');
+							if (pos != std::string::npos)
+							{
+								acodec = acodec.substr(0, pos);
+							}
+						}
 						encoderFd = -1;
 						if (eEncoder::getInstance())
-							encoderFd = eEncoder::getInstance()->allocateEncoder(serviceref, bitrate, width, height, framerate, !!interlaced, aspectratio);
+							encoderFd = eEncoder::getInstance()->allocateEncoder(serviceref, bitrate, width, height, framerate, !!interlaced, aspectratio, vcodec, acodec);
 						if (encoderFd >= 0)
 						{
 							running = true;
diff --git a/lib/dvb/subtitle.cpp b/lib/dvb/subtitle.cpp
index 76e7b0e..0030336 100644
--- a/lib/dvb/subtitle.cpp
+++ b/lib/dvb/subtitle.cpp
@@ -505,7 +505,7 @@ int eDVBSubtitleParser::subtitle_process_segment(uint8_t *segment)
 			object->object_horizontal_position |= *segment++;
 			processed_length += 2;
 
-			object->object_vertical_position  = *segment++ << 8;
+			object->object_vertical_position  = (*segment++ & 0xF) << 8;
 			object->object_vertical_position |= *segment++ ;
 			processed_length += 2;
 
diff --git a/lib/gdi/accel.cpp b/lib/gdi/accel.cpp
index b231356..e110420 100644
--- a/lib/gdi/accel.cpp
+++ b/lib/gdi/accel.cpp
@@ -15,11 +15,30 @@
 // #define ACCEL_DEBUG
 
 gAccel *gAccel::instance;
+
+#if not defined(HAVE_HISILICON_ACCEL)
 #if not defined(__sh__)
 #define BCM_ACCEL
 #else
 #define STMFB_ACCEL
 #endif
+#endif
+
+#ifdef HAVE_HISILICON_ACCEL 
+extern int  dinobot_accel_init(void);
+extern void dinobot_accel_close(void);
+extern void dinobot_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight,
+		int pal_addr,int pal_size, int flags);
+extern void dinobot_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+extern bool dinobot_accel_has_alphablending();
+#endif
 
 #ifdef STMFB_ACCEL
 extern int stmfb_accel_init(void);
@@ -47,6 +66,7 @@ extern void ati_accel_fill(
 		int x, int y, int width, int height,
 		unsigned long color);
 #endif
+
 #ifdef BCM_ACCEL
 extern int bcm_accel_init(void);
 extern void bcm_accel_close(void);
@@ -61,6 +81,8 @@ extern void bcm_accel_fill(
 		int x, int y, int width, int height,
 		unsigned long color);
 extern bool bcm_accel_has_alphablending();
+extern int bcm_accel_accumulate();
+extern int bcm_accel_sync();
 #endif
 
 gAccel::gAccel():
@@ -79,6 +101,9 @@ gAccel::gAccel():
 #ifdef BCM_ACCEL
 	m_bcm_accel_state = bcm_accel_init();
 #endif
+#ifdef HAVE_HISILICON_ACCEL
+	dinobot_accel_init();
+#endif
 }
 
 gAccel::~gAccel()
@@ -92,6 +117,9 @@ gAccel::~gAccel()
 #ifdef BCM_ACCEL
 	bcm_accel_close();
 #endif
+#ifdef HAVE_HISILICON_ACCEL
+	dinobot_accel_close();
+#endif
 	instance = 0;
 }
 
@@ -162,6 +190,9 @@ bool gAccel::hasAlphaBlendingSupport()
 {
 #ifdef BCM_ACCEL
 	return bcm_accel_has_alphablending();
+#endif
+#ifdef HAVE_HISILICON_ACCEL
+	return dinobot_accel_has_alphablending();
 #else
 	return false;
 #endif
@@ -243,7 +274,7 @@ int gAccel::blit(gUnmanagedSurface *dst, gUnmanagedSurface *src, const eRect &p,
 #ifdef BCM_ACCEL
 	if (!m_bcm_accel_state)
 	{
-		unsigned long pal_addr = 0;
+		unsigned int pal_addr = 0;
 		int src_format = 0;
 		if (src->bpp == 32)
 			src_format = 0;
@@ -255,7 +286,7 @@ int gAccel::blit(gUnmanagedSurface *dst, gUnmanagedSurface *src, const eRect &p,
 			{
 				/* sync pal */
 				pal_addr = src->stride * src->y;
-				unsigned long *pal = (unsigned long*)(((unsigned char*)src->data) + pal_addr);
+				unsigned int *pal = (unsigned int*)(((unsigned char*)src->data) + pal_addr);
 				pal_addr += src->data_phys;
 				for (int i = 0; i < src->clut.colors; ++i)
 					*pal++ = src->clut.data[i].argb() ^ 0xFF000000;
@@ -277,6 +308,51 @@ int gAccel::blit(gUnmanagedSurface *dst, gUnmanagedSurface *src, const eRect &p,
 		return 0;
 	}
 #endif
+#ifdef HAVE_HISILICON_ACCEL
+		unsigned long pal_addr = 0;
+		unsigned int  pal_size = 0;
+		int src_format = 0;
+		if (src->bpp == 32)
+			src_format = 0;
+		else if ((src->bpp == 8) && src->clut.data)
+		{
+			src_format = 1;
+			pal_size = src->clut.colors*4*16/16;
+			pal_addr = (unsigned long)new unsigned char [pal_size];
+			/* sync pal */
+			if (src->clut.data_phys == 0)
+			{
+				/* sync pal */
+				unsigned long *pal = (unsigned long*)pal_addr;
+				for (int i = 0; i < src->clut.colors; ++i)
+				    *pal++ = src->clut.data[i].argb() ^ 0xFF000000;
+				src->clut.data_phys = pal_addr;
+				eDebug("!!!!!!!!!![gAccel] pal_addr1 %x clors=%d!!!!!!!!!!",pal_addr,src->clut.colors);
+			}
+			else
+			{
+				//memcpy((void*)pal_addr ,(void *)src->clut.data_phys,pal_size);
+				unsigned long *pal = (unsigned long*)pal_addr;
+				for (int i = 0; i < src->clut.colors; ++i)
+				    *pal++ = src->clut.data[i].argb() ^ 0xFF000000;
+				eDebug("!!!!!!!!!![gAccel] pal_addr2 %x clors=%d!!!!!!!!!!",pal_addr,src->clut.colors);
+			}
+		} else
+			return -1; /* unsupported source format */
+
+		dinobot_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height(),
+			pal_addr, pal_size,flags);
+
+		if(pal_size && pal_addr)
+		{
+			delete (unsigned char *)pal_addr;
+		}
+		return 0;
+#endif
 	return -1;
 }
 
@@ -301,6 +377,36 @@ int gAccel::fill(gUnmanagedSurface *dst, const eRect &area, unsigned long col)
 		return 0;
 	}
 #endif
+
+#ifdef HAVE_HISILICON_ACCEL
+	dinobot_accel_fill(
+		dst->data_phys, dst->x, dst->y, dst->stride,
+		area.left(), area.top(), area.width(), area.height(),
+		col);
+	return 0;
+#endif
+	return -1;
+}
+
+int gAccel::accumulate()
+{
+#ifdef BCM_ACCEL
+	if (!m_bcm_accel_state)
+	{
+		return bcm_accel_accumulate();
+	}
+#endif
+	return -1;
+}
+
+int gAccel::sync()
+{
+#ifdef BCM_ACCEL
+	if (!m_bcm_accel_state)
+	{
+		return bcm_accel_sync();
+	}
+#endif
 	return -1;
 }
 
diff --git a/lib/gdi/accel.h b/lib/gdi/accel.h
index 39c0da7..4872f3b 100644
--- a/lib/gdi/accel.h
+++ b/lib/gdi/accel.h
@@ -21,6 +21,8 @@ public:
 	bool hasAlphaBlendingSupport();
 	int blit(gUnmanagedSurface *dst, gUnmanagedSurface *src, const eRect &p, const eRect &area, int flags);
 	int fill(gUnmanagedSurface *dst, const eRect &area, unsigned long col);
+	int accumulate();
+	int sync();
 
 	int accelAlloc(gUnmanagedSurface* surface);
 	void accelFree(gUnmanagedSurface* surface);
diff --git a/lib/gdi/bcm.cpp b/lib/gdi/bcm.cpp
index 6f7d025..076e4b5 100644
--- a/lib/gdi/bcm.cpp
+++ b/lib/gdi/bcm.cpp
@@ -14,8 +14,9 @@
 #define FBIO_ACCEL  0x23
 
 static unsigned int displaylist[1024];
-static int ptr;
+static int ptr = 0;
 static bool supportblendingflags = true;
+static bool accumulateoperations = false;
 
 #define P(x, y) do { displaylist[ptr++] = x; displaylist[ptr++] = y; } while (0)
 #define C(x) P(x, 0)
@@ -81,6 +82,31 @@ bool bcm_accel_has_alphablending()
 	return supportblendingflags;
 }
 
+int bcm_accel_accumulate()
+{
+#ifdef SUPPORT_ACCUMULATED_ACCELERATION_OPERATIONS
+	accumulateoperations = true;
+	return 0;
+#else
+	return -1;
+#endif
+}
+
+int bcm_accel_sync()
+{
+	int retval = 0;
+	if (accumulateoperations)
+	{
+		if (ptr)
+		{
+			eDebug("bcm_accel_sync: ptr %d", ptr);
+			retval = exec_list();
+		}
+		accumulateoperations = false;
+	}
+	return retval;
+}
+
 void bcm_accel_blit(
 		int src_addr, int src_width, int src_height, int src_stride, int src_format,
 		int dst_addr, int dst_width, int dst_height, int dst_stride,
@@ -88,6 +114,16 @@ void bcm_accel_blit(
 		int dst_x, int dst_y, int dwidth, int dheight,
 		int pal_addr, int flags)
 {
+	if (accumulateoperations)
+	{
+		if (((sizeof(displaylist) / sizeof(displaylist[0]) - ptr) / 2) < 40)
+		{
+			eDebug("bcm_accel_blit: not enough space to accumulate");
+			bcm_accel_sync();
+			bcm_accel_accumulate();
+		}
+	}
+
 	C(0x43); // reset source
 	C(0x53); // reset dest
 	C(0x5b);  // reset pattern
@@ -139,7 +175,7 @@ void bcm_accel_blit(
 
 	C(0x77);  // do it
 
-	exec_list();
+	if (!accumulateoperations) exec_list();
 }
 
 void bcm_accel_fill(
@@ -147,6 +183,16 @@ void bcm_accel_fill(
 		int x, int y, int width, int height,
 		unsigned long color)
 {
+	if (accumulateoperations)
+	{
+		if (((sizeof(displaylist) / sizeof(displaylist[0]) - ptr) / 2) < 40)
+		{
+			eDebug("bcm_accel_fill: not enough space to accumulate");
+			bcm_accel_sync();
+			bcm_accel_accumulate();
+		}
+	}
+
 	C(0x43); // reset source
 	C(0x53); // reset dest
 	C(0x5b); // reset pattern
@@ -192,6 +238,5 @@ void bcm_accel_fill(
 
 	C(0x77);  // do it
 
-	exec_list();
+	if (!accumulateoperations) exec_list();
 }
-
diff --git a/lib/gdi/fb.cpp b/lib/gdi/fb.cpp
index 2f463d2..d871066 100644
--- a/lib/gdi/fb.cpp
+++ b/lib/gdi/fb.cpp
@@ -97,7 +97,7 @@ fbClass::fbClass(const char *fb)
 		struct ion_handle_data free_data;
 		struct ion_phys_data phys_data;
 		int ret;
-//		unsigned char *lfb;
+		unsigned char *lion;
 
 		eDebug("[fb] Using ION allocator");
 
@@ -137,17 +137,17 @@ fbClass::fbClass(const char *fb)
 			eDebug("[fb] ION_IOC_FREE failed");
 
 		m_accel_fd = share_data.fd;
-		lfb=(unsigned char*)mmap(0, ACCEL_MEM_SIZE, PROT_WRITE|PROT_READ, MAP_SHARED, share_data.fd, 0);
+		lion=(unsigned char*)mmap(0, ACCEL_MEM_SIZE, PROT_WRITE|PROT_READ, MAP_SHARED, share_data.fd, 0);
 
-		if (lfb)
+		if (lion)
 		{
 			eDebug("[fb] %dkB available for acceleration surfaces (via ION).", ACCEL_MEM_SIZE / 1024);
-			gAccel::getInstance()->setAccelMemorySpace(lfb, phys_data.addr, ACCEL_MEM_SIZE);
+			gAccel::getInstance()->setAccelMemorySpace(lion, phys_data.addr, ACCEL_MEM_SIZE);
 		}
 		else
 		{
 			close(m_accel_fd);
-			eDebug("[fb] mmap lfb failed");
+			eDebug("[fb] mmap lion failed");
 err_ioc_free:
 			eFatal("[fb] failed to allocate accel memory via ION!!!");
 			m_accel_fd = -1;
@@ -167,13 +167,13 @@ err_ioc_free:
 	eDebug("[fb] %dk video mem", available/1024);
 	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 0);
 #endif
-//#ifndef CONFIG_ION
+#ifndef CONFIG_ION
 	if (!lfb)
 	{
 		eDebug("[fb] mmap %m");
 		goto nolfb;
 	}
-//#endif
+#endif
 
 #if not defined(__sh__)
 	showConsole(0);
diff --git a/lib/gdi/font.cpp b/lib/gdi/font.cpp
index 95fa12c..edaf88f 100644
--- a/lib/gdi/font.cpp
+++ b/lib/gdi/font.cpp
@@ -288,8 +288,11 @@ int fontRenderClass::getFont(ePtr<Font> &font, const std::string &face, int size
 void addFont(const char *filename, const char *alias, int scale_factor, int is_replacement, int renderflags)
 {
 	fontRenderClass::getInstance()->AddFont(filename, alias, scale_factor, renderflags);
-	if (is_replacement)
+	if (is_replacement == 1)
 		eTextPara::setReplacementFont(alias);
+	else if (is_replacement == -1)
+		eTextPara::setFallbackFont(alias);
+
 }
 
 DEFINE_REF(Font);
@@ -574,23 +577,26 @@ eTextPara::~eTextPara()
 
 void eTextPara::setFont(const gFont *font)
 {
-	ePtr<Font> fnt, replacement;
+	ePtr<Font> fnt, replacement, fallback;
 	fontRenderClass::getInstance()->getFont(fnt, font->family.c_str(), font->pointSize);
 	if (!fnt)
 		eWarning("[eTextPara] FONT '%s' MISSING!", font->family.c_str());
 	fontRenderClass::getInstance()->getFont(replacement, replacement_facename.c_str(), font->pointSize);
-	setFont(fnt, replacement);
+	fontRenderClass::getInstance()->getFont(fallback, fallback_facename.c_str(), font->pointSize);
+	setFont(fnt, replacement, fallback);
 }
 
 std::string eTextPara::replacement_facename;
+std::string eTextPara::fallback_facename;
 std::set<int> eTextPara::forced_replaces;
 
-void eTextPara::setFont(Font *fnt, Font *replacement)
+void eTextPara::setFont(Font *fnt, Font *replacement, Font *fallback)
 {
 	if (!fnt)
 		return;
 	current_font=fnt;
 	replacement_font=replacement;
+	fallback_font=fallback;
 	singleLock s(ftlock);
 
 			// we ask for replacment_font first becauseof the cache
@@ -620,6 +626,19 @@ void eTextPara::setFont(Font *fnt, Font *replacement)
 			return;
 		}
 	}
+	if (fallback_font)
+	{
+		if ((FTC_Manager_LookupFace(fontRenderClass::instance->cacheManager,
+					    fallback_font->scaler.face_id,
+					    &fallback_face) < 0) ||
+		    (FTC_Manager_LookupSize(fontRenderClass::instance->cacheManager,
+					    &fallback_font->scaler,
+					    &fallback_font->size) < 0))
+		{
+			eDebug("[eTextPara] FTC_Manager_Lookup_Size failed!");
+			return;
+		}
+	}
 	previous=0;
 	use_kerning=FT_HAS_KERNING(current_face);
 }
@@ -852,7 +871,14 @@ nprint:				isprintable=0;
 					index=(rflags&RS_DIRECT)? chr : FT_Get_Char_Index(replacement_face, chr);
 
 				if (!index)
-					eDebug("[eTextPara] unicode U+%4lx not present", chr);
+				{
+					if (fallback_face)
+						index=(rflags&RS_DIRECT)? chr : FT_Get_Char_Index(fallback_face, chr);
+					if (!index)
+						eDebug("[eTextPara] unicode U+%4lx not present", chr);
+					else
+						appendGlyph(fallback_font, fallback_face, index, flags, rflags, border, i == uc_visual.end() - 1, activate_newcolor, newcolor);
+				}
 				else
 					appendGlyph(replacement_font, replacement_face, index, flags, rflags, border, i == uc_visual.end() - 1, activate_newcolor, newcolor);
 			} else
diff --git a/lib/gdi/font.h b/lib/gdi/font.h
index d7f428e..608c421 100644
--- a/lib/gdi/font.h
+++ b/lib/gdi/font.h
@@ -123,11 +123,12 @@ class eLCD;
 class eTextPara: public iObject
 {
 	DECLARE_REF(eTextPara);
-	ePtr<Font> current_font, replacement_font;
-	FT_Face current_face, replacement_face;
+	ePtr<Font> current_font, replacement_font, fallback_font;
+	FT_Face current_face, replacement_face, fallback_face;
 	int use_kerning;
 	int previous;
 	static std::string replacement_facename;
+	static std::string fallback_facename;
 	static std::set<int> forced_replaces;
 
 	eRect area;
@@ -147,11 +148,12 @@ class eTextPara: public iObject
 	int appendGlyph(Font *current_font, FT_Face current_face, FT_UInt glyphIndex, int flags, int rflags, int border, bool last,
 			bool activate_newcolor, unsigned long newcolor);
 	void newLine(int flags);
-	void setFont(Font *font, Font *replacement_font);
+	void setFont(Font *font, Font *replacement_font, Font *fallback_font);
 	void calc_bbox();
 public:
 	eTextPara(eRect area, ePoint start=ePoint(-1, -1))
 		: current_font(0), replacement_font(0), current_face(0), replacement_face(0),
+		fallback_font(0), fallback_face(0),
 		area(area), cursor(start), maximum(0, 0), left(start.x()), charCount(0), totalheight(0),
 		bboxValid(0), doTopBottomReordering(false)
 	{
@@ -161,6 +163,8 @@ public:
 	static void setReplacementFont(std::string font) { replacement_facename=font; }
 	static void forceReplacementGlyph(int unicode) { forced_replaces.insert(unicode); }
 
+	static void setFallbackFont(std::string font) { fallback_facename=font; }
+
 	void setFont(const gFont *font);
 	int renderString(const char *string, int flags=0, int border=0);
 
diff --git a/lib/gdi/gfbdc.cpp b/lib/gdi/gfbdc.cpp
index 174011d..7636de4 100644
--- a/lib/gdi/gfbdc.cpp
+++ b/lib/gdi/gfbdc.cpp
@@ -15,7 +15,9 @@
 #include <lib/base/cfile.h>
 #endif
 
-#ifdef CONFIG_ION
+#if defined(CONFIG_ION) || defined(CONFIG_HISILICON_FB)
+#include <lib/gdi/grc.h>
+
 extern void bcm_accel_blit(
 		int src_addr, int src_width, int src_height, int src_stride, int src_format,
 		int dst_addr, int dst_width, int dst_height, int dst_stride,
@@ -24,6 +26,10 @@ extern void bcm_accel_blit(
 		int pal_addr, int flags);
 #endif
 
+#ifdef HAVE_HISILICON_ACCEL
+extern void  dinobot_accel_register(void *p1,void *p2);
+extern void  dinibot_accel_notify(void);
+#endif
 gFBDC::gFBDC()
 {
 	fb=new fbClass;
@@ -193,6 +199,20 @@ void gFBDC::exec(const gOpcode *o)
 				0, 0);
 		}
 #endif
+#if defined(CONFIG_HISILICON_FB)
+		if(islocked()==0)
+		{
+			bcm_accel_blit(
+				surface.data_phys, surface.x, surface.y, surface.stride, 0,
+				surface_back.data_phys, surface_back.x, surface_back.y, surface_back.stride,
+				0, 0, surface.x, surface.y,
+				0, 0, surface.x, surface.y,
+				0, 0);
+		}
+#endif
+#ifdef HAVE_HISILICON_ACCEL
+		dinibot_accel_notify();
+#endif
 		break;
 	case gOpcode::sendShow:
 	{
@@ -266,12 +286,20 @@ void gFBDC::setResolution(int xres, int yres, int bpp)
 		return;
 	}
 #else
-	if (m_pixmap && (surface.x == xres) && (surface.y == yres) && (surface.bpp == bpp))
+	if (m_pixmap && (surface.x == xres) && (surface.y == yres) && (surface.bpp == bpp)
+	#if defined(CONFIG_HISILICON_FB)
+		&& islocked()==0
+	#endif
+		)
 		return;
 #endif
 #ifndef CONFIG_ION
 	if (gAccel::getInstance())
 		gAccel::getInstance()->releaseAccelMemorySpace();
+#else
+	gRC *grc = gRC::getInstance();
+	if (grc)
+		grc->lock();
 #endif
 	fb->SetMode(xres, yres, bpp);
 
@@ -316,6 +344,9 @@ void gFBDC::setResolution(int xres, int yres, int bpp)
 		gAccel::getInstance()->setAccelMemorySpace(fb->lfb + fb_size, surface.data_phys + fb_size, fb->Available() - fb_size);
 #endif
 
+#ifdef HAVE_HISILICON_ACCEL
+	dinobot_accel_register(&surface,&surface_back);
+#endif
 	if (!surface.clut.data)
 	{
 		surface.clut.colors = 256;
@@ -325,7 +356,21 @@ void gFBDC::setResolution(int xres, int yres, int bpp)
 
 	surface_back.clut = surface.clut;
 
+#if defined(CONFIG_HISILICON_FB)
+	if(islocked()==0)
+	{
+		gUnmanagedSurface s(surface);
+		surface = surface_back;
+		surface_back = s;
+	}
+#endif
+
 	m_pixmap = new gPixmap(&surface);
+
+#ifdef CONFIG_ION
+	if (grc)
+		grc->unlock();
+#endif
 }
 
 void gFBDC::saveSettings()
diff --git a/lib/gdi/gpixmap.cpp b/lib/gdi/gpixmap.cpp
index 55d1f63..90199ff 100644
--- a/lib/gdi/gpixmap.cpp
+++ b/lib/gdi/gpixmap.cpp
@@ -9,10 +9,81 @@
 #error "no BYTE_ORDER defined!"
 #endif
 
+/* surface acceleration threshold: do not attempt to accelerate surfaces smaller than the threshold (measured in bytes) */
+#ifndef GFX_SURFACE_ACCELERATION_THRESHOLD
+#define GFX_SURFACE_ACCELERATION_THRESHOLD 48000
+#endif
+
+/* fill acceleration threshold: do not attempt to accelerate fill operations smaller than the threshold (measured in bytes) */
+#ifndef GFX_SURFACE_FILL_ACCELERATION_THRESHOLD
+#define GFX_SURFACE_FILL_ACCELERATION_THRESHOLD 80000
+#endif
+
+/* blit acceleration threshold: do not attempt to accelerate blit operations smaller than the threshold (measured in bytes) */
+#ifndef GFX_SURFACE_BLIT_ACCELERATION_THRESHOLD
+/* by default: accelerate all blit operations on accelerated surfaces */
+#define GFX_SURFACE_BLIT_ACCELERATION_THRESHOLD 0
+#endif
+
 // #define GPIXMAP_DEBUG
 
 #ifdef GPIXMAP_DEBUG
 #	include "../base/benchmark.h"
+
+/* #define GPIXMAP_CHECK_THRESHOLD */
+
+#ifdef GPIXMAP_CHECK_THRESHOLD
+
+static unsigned int acceltime = 0;
+
+static void adjustFillThreshold(unsigned int cputime, int area)
+{
+	static int currentfillthreshold = GFX_SURFACE_FILL_ACCELERATION_THRESHOLD;
+	if (acceltime > cputime)
+	{
+		if (area > currentfillthreshold)
+		{
+			eDebug("[gPixmap] [BLITBENCH] increase fill acceleration threshold from %d to %d", currentfillthreshold, area);
+			currentfillthreshold = area;
+		}
+	}
+	else if (acceltime < cputime)
+	{
+		if (area < currentfillthreshold)
+		{
+			eDebug("[gPixmap] [BLITBENCH] decrease fill acceleration threshold from %d to %d", currentfillthreshold, area);
+			currentfillthreshold = area;
+		}
+	}
+}
+
+static void adjustBlitThreshold(unsigned int cputime, int area)
+{
+	static int currentblitthreshold = GFX_SURFACE_BLIT_ACCELERATION_THRESHOLD;
+	if (acceltime > cputime)
+	{
+		if (area > currentblitthreshold)
+		{
+			eDebug("[gPixmap] [BLITBENCH] increase blit acceleration threshold from %d to %d", currentblitthreshold, area);
+			currentblitthreshold = area;
+		}
+	}
+	else if (acceltime < cputime)
+	{
+		if (area < currentblitthreshold)
+		{
+			eDebug("[gPixmap] [BLITBENCH] decrease blit acceleration threshold from %d to %d", currentblitthreshold, area);
+			currentblitthreshold = area;
+		}
+	}
+}
+
+#undef GFX_SURFACE_FILL_ACCELERATION_THRESHOLD
+#define GFX_SURFACE_FILL_ACCELERATION_THRESHOLD 0
+#undef GFX_SURFACE_BLIT_ACCELERATION_THRESHOLD
+#define GFX_SURFACE_BLIT_ACCELERATION_THRESHOLD 0
+
+#endif
 #endif
 
 gLookup::gLookup()
@@ -123,9 +194,8 @@ static bool is_a_candidate_for_accel(const gUnmanagedSurface* surface)
 	switch (surface->bpp)
 	{
 		case 8:
-			return (surface->y * surface->stride) > 12000;
 		case 32:
-			return (surface->y * surface->stride) > 48000;
+			return (surface->y * surface->stride) >= GFX_SURFACE_ACCELERATION_THRESHOLD;
 		default:
 			return false;
 	}
@@ -210,9 +280,22 @@ void gPixmap::fill(const gRegion &region, const gColor &color)
 
 			col^=0xFF000000;
 
-			if (surface->data_phys)
-				if (!gAccel::getInstance()->fill(surface,  area, col))
+#ifdef GPIXMAP_DEBUG
+			Stopwatch s;
+#endif
+			if (surface->data_phys && ((area.surface() * surface->bypp) > GFX_SURFACE_FILL_ACCELERATION_THRESHOLD))
+				if (!gAccel::getInstance()->fill(surface,  area, col)) {
+#ifdef GPIXMAP_DEBUG
+					s.stop();
+					eDebug("[gPixmap] [BLITBENCH] accel fill %dx%d (%d bytes) took %u us", area.width(), area.height(), area.surface() * surface->bypp, s.elapsed_us());
+#endif
+#ifdef GPIXMAP_CHECK_THRESHOLD
+					acceltime = s.elapsed_us();
+					s.start();
+#else
 					continue;
+#endif
+				}
 
 			for (int y=area.top(); y<area.bottom(); y++)
 			{
@@ -221,6 +304,16 @@ void gPixmap::fill(const gRegion &region, const gColor &color)
 				while (x--)
 					*dst++=col;
 			}
+#ifdef GPIXMAP_DEBUG
+			s.stop();
+			eDebug("[gPixmap] [BLITBENCH] cpu fill %dx%d (%d bytes) took %u us", area.width(), area.height(), area.surface() * surface->bypp, s.elapsed_us());
+#ifdef GPIXMAP_CHECK_THRESHOLD
+			if (surface->data_phys)
+			{
+				adjustFillThreshold(s.elapsed_us(), area.surface() * surface->bypp);
+			}
+#endif
+#endif
 		}	else
 			eWarning("[gPixmap] couldn't fill %d bpp", surface->bpp);
 	}
@@ -245,13 +338,18 @@ void gPixmap::fill(const gRegion &region, const gRGB &color)
 #ifdef GPIXMAP_DEBUG
 			Stopwatch s;
 #endif
-			if (surface->data_phys && (area.surface() > 20000))
+			if (surface->data_phys && ((area.surface() * surface->bypp) > GFX_SURFACE_FILL_ACCELERATION_THRESHOLD))
 				if (!gAccel::getInstance()->fill(surface,  area, col)) {
 #ifdef GPIXMAP_DEBUG
 					s.stop();
-					eDebug("[gPixmap] [BLITBENCH] accel fill %dx%d took %u us", area.width(), area.height(), s.elapsed_us());
+					eDebug("[gPixmap] [BLITBENCH] accel fill %dx%d (%d bytes) took %u us", area.width(), area.height(), area.surface() * surface->bypp, s.elapsed_us());
 #endif
+#ifdef GPIXMAP_CHECK_THRESHOLD
+					acceltime = s.elapsed_us();
+					s.start();
+#else
 					continue;
+#endif
 				}
 
 			for (int y=area.top(); y<area.bottom(); y++)
@@ -263,7 +361,13 @@ void gPixmap::fill(const gRegion &region, const gRGB &color)
 			}
 #ifdef GPIXMAP_DEBUG
 			s.stop();
-			eDebug("[gPixmap] [BLITBENCH] cpu fill %dx%d took %u us", area.width(), area.height(), s.elapsed_us());
+			eDebug("[gPixmap] [BLITBENCH] cpu fill %dx%d (%d bytes) took %u us", area.width(), area.height(), area.surface() * surface->bypp, s.elapsed_us());
+#ifdef GPIXMAP_CHECK_THRESHOLD
+			if (surface->data_phys)
+			{
+				adjustFillThreshold(s.elapsed_us(), area.surface() * surface->bypp);
+			}
+#endif
 #endif
 		} else if (surface->bpp == 16)
 		{
@@ -354,6 +458,8 @@ static void convert_palette(uint32_t* pal, const gPalette& clut)
 void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, int flag)
 {
 	bool accel = (surface->data_phys && src.surface->data_phys);
+	bool accumulate = accel && (gAccel::getInstance()->accumulate() >= 0);
+	int accelerationthreshold = GFX_SURFACE_BLIT_ACCELERATION_THRESHOLD;
 //	eDebug("[gPixmap] blit: -> %d,%d+%d,%d -> %d,%d+%d,%d, flags=0x%x, accel=%d",
 //		_pos.x(), _pos.y(), _pos.width(), _pos.height(),
 //		clip.extends.x(), clip.extends.y(), clip.extends.width(), clip.extends.height(),
@@ -393,6 +499,36 @@ void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, i
 		}
 	}
 
+	if (accumulate)
+	{
+		int totalsurface = 0;
+		for (unsigned int i=0; i<clip.rects.size(); ++i)
+		{
+			eRect area = pos; /* pos is the virtual (pre-clipping) area on the dest, which can be larger/smaller than src if scaling is enabled */
+			area&=clip.rects[i];
+			area&=eRect(ePoint(0, 0), size());
+
+			if (area.empty())
+				continue;
+
+			eRect srcarea = area;
+
+			if (flag & blitScale)
+				srcarea = eRect(srcarea.x() * FIX / scale_x, srcarea.y() * FIX / scale_y, srcarea.width() * FIX / scale_x, srcarea.height() * FIX / scale_y);
+
+			totalsurface += srcarea.surface() * src.surface->bypp;
+		}
+		if (totalsurface < accelerationthreshold)
+		{
+			accel = false;
+		}
+		else
+		{
+			/* total surface is larger than the threshold, no longer apply the threshold on individual clip rects */
+			accelerationthreshold = 0;
+		}
+	}
+
 //	eDebug("[gPixmap] SCALE %x %x", scale_x, scale_y);
 
 	for (unsigned int i=0; i<clip.rects.size(); ++i)
@@ -421,16 +557,24 @@ void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, i
 #else
 		if (accel)
 		{
+			if (srcarea.surface() * src.surface->bypp < accelerationthreshold)
+			{
+				accel = false;
+			}
+		}
+		if (accel)
+		{
 			/* we have hardware acceleration for this blit operation */
 			if (flag & (blitAlphaTest | blitAlphaBlend))
 			{
 				/* alpha blending is requested */
 				if (gAccel::getInstance()->hasAlphaBlendingSupport())
 				{
+#ifdef FORCE_ALPHABLENDING_ACCELERATION
 					/* Hardware alpha blending is broken on the few
 					 * boxes that support it, so only use it
 					 * when scaling */
-#ifdef FORCE_BLENDING_ACCELERATION
+
 					accel = true;
 #else
 					if (flag & blitScale)
@@ -448,7 +592,12 @@ void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, i
 				}
 			}
 		}
+
+#ifdef GPIXMAP_CHECK_THRESHOLD
+		accel = (surface->data_phys && src.surface->data_phys);
+#endif
 #endif
+
 #ifdef GPIXMAP_DEBUG
 		Stopwatch s;
 #endif
@@ -456,9 +605,14 @@ void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, i
 			if (!gAccel::getInstance()->blit(surface, src.surface, area, srcarea, flag)) {
 #ifdef GPIXMAP_DEBUG
 				s.stop();
-				eDebug("[gPixmap] [BLITBENCH] accel blit took %u us", s.elapsed_us());
+				eDebug("[gPixmap] [BLITBENCH] accel blit (%d bytes) took %u us", srcarea.surface() * src.surface->bypp, s.elapsed_us());
 #endif
+#ifdef GPIXMAP_CHECK_THRESHOLD
+				acceltime = s.elapsed_us();
+				s.start();
+#else
 				continue;
+#endif
 			}
 		}
 
@@ -583,7 +737,13 @@ void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, i
 			}
 #ifdef GPIXMAP_DEBUG
 			s.stop();
-			eDebug("[gPixmap] [BLITBENCH] CPU scale blit took %u us", s.elapsed_us());
+			eDebug("[gPixmap] [BLITBENCH] CPU scale blit (%d bytes) took %u us", srcarea.surface() * src.surface->bypp, s.elapsed_us());
+#ifdef GPIXMAP_CHECK_THRESHOLD
+			if (accel)
+			{
+				adjustBlitThreshold(s.elapsed_us(), srcarea.surface() * src.surface->bypp);
+			}
+#endif
 #endif
 			continue;
 		}
@@ -826,9 +986,19 @@ void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, i
 			eWarning("[gPixmap] cannot blit %dbpp from %dbpp", surface->bpp, src.surface->bpp);
 #ifdef GPIXMAP_DEBUG
 		s.stop();
-		eDebug("[gPixmap] [BLITBENCH] cpu blit took %u us", s.elapsed_us());
+		eDebug("[gPixmap] [BLITBENCH] cpu blit (%d bytes) took %u us", srcarea.surface() * src.surface->bypp, s.elapsed_us());
+#ifdef GPIXMAP_CHECK_THRESHOLD
+		if (accel)
+		{
+			adjustBlitThreshold(s.elapsed_us(), srcarea.surface() * src.surface->bypp);
+		}
+#endif
 #endif
 	}
+	if (accumulate)
+	{
+		gAccel::getInstance()->sync();
+	}
 }
 
 #undef FIX
diff --git a/lib/gdi/grc.cpp b/lib/gdi/grc.cpp
index 4e0c0b0..2b3bf97 100644
--- a/lib/gdi/grc.cpp
+++ b/lib/gdi/grc.cpp
@@ -1,4 +1,5 @@
 #include <unistd.h>
+#include <fstream>
 #include <lib/gdi/grc.h>
 #include <lib/gdi/font.h>
 #include <lib/base/init.h>
@@ -43,6 +44,22 @@ gRC::gRC(): rp(0), wp(0)
 #endif
 }
 
+#ifdef CONFIG_ION
+void gRC::lock()
+{
+#ifndef SYNC_PAINT
+	pthread_mutex_lock(&mutex);
+#endif
+}
+
+void gRC::unlock()
+{
+#ifndef SYNC_PAINT
+	pthread_mutex_unlock(&mutex);
+#endif
+}
+#endif
+
 DEFINE_REF(gRC);
 
 gRC::~gRC()
@@ -190,7 +207,11 @@ void *gRC::thread()
 				if (!idle)
 				{
 					if (!m_spinner_enabled)
+					{
 						eDebug("[gRC] main thread is non-idle! display spinner!");
+							std::ofstream dummy("/tmp/doPythonStackTrace");
+							dummy.close();
+					}
 					enableSpinner();
 				} else
 					disableSpinner();
diff --git a/lib/gdi/grc.h b/lib/gdi/grc.h
index 7106a3e..7c72d80 100644
--- a/lib/gdi/grc.h
+++ b/lib/gdi/grc.h
@@ -204,6 +204,11 @@ public:
 
 	void submit(const gOpcode &o);
 
+#ifdef CONFIG_ION
+	void lock();
+	void unlock();
+#endif
+
 	sigc::signal0<void> notify;
 
 	void setSpinnerDC(gDC *dc) { m_spinner_dc = dc; }
diff --git a/lib/network/Makefile.inc b/lib/network/Makefile.inc
index 7851854..05fed51 100644
--- a/lib/network/Makefile.inc
+++ b/lib/network/Makefile.inc
@@ -2,9 +2,11 @@ noinst_LIBRARIES += network/libenigma_network.a
 
 network_libenigma_network_a_SOURCES = \
 	network/serversocket.cpp \
-	network/socket.cpp
+	network/socket.cpp \
+	network/uri.cpp
 
 networkincludedir = $(pkgincludedir)/lib/network
 networkinclude_HEADERS = \
 	network/serversocket.h \
-	network/socket.h
+	network/socket.h \
+	network/uri.h
diff --git a/lib/network/serversocket.cpp b/lib/network/serversocket.cpp
index 0486f93..beef983 100644
--- a/lib/network/serversocket.cpp
+++ b/lib/network/serversocket.cpp
@@ -30,7 +30,7 @@ void eServerSocket::notifier(int)
 	newConnection(clientfd);
 }
 
-eServerSocket::eServerSocket(int port, eMainloop *ml): eSocket(ml, AF_INET6)
+eServerSocket::eServerSocket(int port, eMainloop *ml): m_port(port), eSocket(ml, AF_INET6)
 {
 	struct sockaddr_in6 serv_addr;
 	strRemoteHost = "";
@@ -67,12 +67,14 @@ eServerSocket::eServerSocket(std::string path, eMainloop *ml) : eSocket(ml, AF_L
 {
 	struct sockaddr_un serv_addr;
 	strRemoteHost = "";
+	m_port = 0;
 
 	memset(&serv_addr, 0, sizeof(serv_addr));
 	serv_addr.sun_family = AF_LOCAL;
 	strcpy(serv_addr.sun_path, path.c_str());
 
 	okflag=1;
+	m_port = 0;
 
 	unlink(path.c_str());
 #if HAVE_LINUXSOCKADDR
diff --git a/lib/network/serversocket.h b/lib/network/serversocket.h
index a4df9b5..25b9c63 100644
--- a/lib/network/serversocket.h
+++ b/lib/network/serversocket.h
@@ -8,6 +8,7 @@ class eServerSocket: public eSocket
 	void notifier(int handle);
 	int okflag;
 	std::string strRemoteHost;
+	int m_port;
 protected:
 	virtual void newConnection(int socket)=0;
 	int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen);
@@ -21,6 +22,7 @@ public:
 	virtual ~eServerSocket();
 	bool ok();
 	std::string RemoteHost() { return strRemoteHost;}
+	int Port() { return m_port; }
 };
 
 #endif /* __serversocket_h */
diff --git a/lib/python/Components/AVSwitch.py b/lib/python/Components/AVSwitch.py
index c34b5b3..6a4bd20 100644
--- a/lib/python/Components/AVSwitch.py
+++ b/lib/python/Components/AVSwitch.py
@@ -8,7 +8,27 @@ from SystemInfo import SystemInfo
 import os
 from time import sleep
 
+has_scart = False
+has_scartyuv = False
+has_yuv = False
+has_dvi = False
+has_hdmi = False
+has_rca = False
+has_avjack = False
+
+has_scart = SystemInfo["HAVESCART"]
+has_scartyuv = SystemInfo["HAVESCARTYUV"]
+has_yuv = SystemInfo["HAVEYUV"]
+has_dvi = SystemInfo["HaveDVI"]
+has_hdmi = SystemInfo["HAVEHDMI"]
+has_rca = SystemInfo["HaveRCA"]
+has_avjack = SystemInfo["HaveAVJACK"]
+
 config.av = ConfigSubsection()
+if getBrandOEM() in ('azbox'):
+	config.av.edid_override = ConfigYesNo(default = True)
+else:
+	config.av.edid_override = ConfigYesNo(default = False)
 
 class AVSwitch:
 	hw_type = HardwareInfo().get_device_name()
@@ -19,72 +39,81 @@ class AVSwitch:
 							"60Hz":		{ 60: "pal60" },
 							"multi":	{ 50: "pal", 60: "pal60" } }
 
-	rates["NTSC"] =		{	"60Hz": 	{ 60: "ntsc" } }
+	rates["NTSC"] =		{	"60Hz":		{ 60: "ntsc" } }
 
 	rates["Multi"] =	{	"multi":	{ 50: "pal", 60: "ntsc" } }
 
-	rates["480i"] =		{	"60Hz": 	{ 60: "480i" } }
+	rates["480i"] =		{	"60Hz":		{ 60: "480i" } }
 
-	rates["576i"] =		{	"50Hz": 	{ 50: "576i" } }
+	rates["576i"] =		{	"50Hz":		{ 50: "576i" } }
 
-	rates["480p"] =		{	"60Hz": 	{ 60: "480p" } }
+	rates["480p"] =		{	"60Hz":		{ 60: "480p" } }
 
-	rates["576p"] =		{	"50Hz": 	{ 50: "576p" } }
+	rates["576p"] =		{	"50Hz":		{ 50: "576p" } }
 
-	rates["720p"] =		{	"50Hz": 	{ 50: "720p50" },
-							"60Hz": 	{ 60: "720p" },
-							"multi": 	{ 50: "720p50", 60: "720p" } }
+	rates["720p"] =		{	"50Hz":		{ 50: "720p50" },
+							"60Hz":		{ 60: "720p" },
+							"multi":	{ 50: "720p50", 60: "720p" },
+							"auto":		{ 50: "720p50", 60: "720p", 24: "720p24" } }
 
 	rates["1080i"] =	{	"50Hz":		{ 50: "1080i50" },
 							"60Hz":		{ 60: "1080i" },
-							"multi":	{ 50: "1080i50", 60: "1080i" } }
+							"multi":	{ 50: "1080i50", 60: "1080i" },
+							"auto":		{ 50: "1080i50", 60: "1080i", 24: "1080p24" } }
 
 	rates["1080p"] =	{ 	"50Hz":		{ 50: "1080p50" },
 							"60Hz":		{ 60: "1080p" },
-							"multi":	{ 50: "1080p50", 60: "1080p" } }
+							"multi":	{ 50: "1080p50", 60: "1080p" },
+							"auto":		{ 50: "1080p50", 60: "1080p", 24: "1080p24" } }
+
+	if getBoxType().startswith('dm9'):
+		rates["2160p"] =	{ 	"50Hz":		{ 50: "2160p50" },
+								"60Hz":		{ 60: "2160p60" },
+								"multi":	{ 50: "2160p50", 60: "2160p60" },
+								"auto":		{ 50: "2160p50", 60: "2160p60", 24: "2160p24" } }
+	else:
+		rates["2160p"] =	{ 	"50Hz":		{ 50: "2160p50" },
+								"60Hz":		{ 60: "2160p" },
+								"multi":	{ 50: "2160p50", 60: "2160p" },
+								"auto":		{ 50: "2160p50", 60: "2160p", 24: "2160p24" } }
 
-	rates["2160p"] =	{ 	"50Hz":		{ 50: "2160p50" },
-							"60Hz":		{ 60: "2160p" },
-							"multi":	{ 50: "2160p50", 60: "2160p" } }
-							
 	rates["2160p30"] =	{ 	"25Hz":		{ 50: "2160p25" },
 							"30Hz":		{ 60: "2160p30"} ,
-							"multi":	{ 50: "2160p25", 60: "2160p30" } }
+							"multi":	{ 50: "2160p25", 60: "2160p30" },
+							"auto":		{ 50: "2160p25", 60: "2160p30", 24: "2160p24" } }
 
 	rates["PC"] = {
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+		"1024x768":						{ 60: "1024x768" }, # not possible on DM7025
+		"800x600" :						{ 60: "800x600" },  # also not possible
+		"720x480" :						{ 60: "720x480" },
+		"720x576" :						{ 60: "720x576" },
+		"1280x720":						{ 60: "1280x720" },
+		"1280x720 multi":				{ 50: "1280x720_50", 60: "1280x720" },
+		"1920x1080":					{ 60: "1920x1080"},
+		"1920x1080 multi":				{ 50: "1920x1080", 60: "1920x1080_50" },
+		"1280x1024":					{ 60: "1280x1024"},
+		"1366x768" :					{ 60: "1366x768"},
+		"1366x768 multi":				{ 50: "1366x768", 60: "1366x768_50" },
+		"1280x768":						{ 60: "1280x768" },
+		"640x480" :						{ 60: "640x480" }
 	}
 
 	modes["Scart"] = ["PAL", "NTSC", "Multi"]
 	# modes["DVI-PC"] = ["PC"]
-	
-	if hw_type in ('elite', 'premium', 'premium+', 'ultra', "me", "minime") : config.av.edid_override = True
-	
+
 	if (about.getChipSetString() in ('7366', '7376', '5272s', '7444', '7445', '7445s')):
 		modes["HDMI"] = ["720p", "1080p", "2160p", "1080i", "576p", "576i", "480p", "480i"]
 		widescreen_modes = {"720p", "1080p", "1080i", "2160p"}
-	elif (about.getChipSetString() in ('7252', '7251', '7251S', '7252S', '7251s', '7252s', '72604', '7444s', '3798mv200', '3798cv200')):
+	elif (about.getChipSetString() in ('7252', '7251', '7251S', '7252S', '7251s', '7252s', '72604', '7278', '7444s', '3798mv200', '3798cv200', 'hi3798mv200', 'hi3798cv200')):
 		modes["HDMI"] = ["720p", "1080p", "2160p", "2160p30", "1080i", "576p", "576i", "480p", "480i"]
 		widescreen_modes = {"720p", "1080p", "1080i", "2160p", "2160p30"}
-	elif (about.getChipSetString() in ('7241', '7358', '7362', '73625', '7346', '7356', '73565', '7424', '7425', '7435', '7552', '7581', '7584', '7585', 'pnx8493', '7162', '7111')) or (hw_type in ('elite', 'premium', 'premium+', 'ultra', "me", "minime")):
+	elif (about.getChipSetString() in ('7241', '7358', '7362', '73625', '7346', '7356', '73565', '7424', '7425', '7435', '7552', '7581', '7584', '75845', '7585', 'pnx8493', '7162', '7111')) or (getBrandOEM() in ('azbox')):
 		modes["HDMI"] = ["720p", "1080p", "1080i", "576p", "576i", "480p", "480i"]
 		widescreen_modes = {"720p", "1080p", "1080i"}
 	elif about.getChipSetString() in ('meson-6'):
 		modes["HDMI"] = ["720p", "1080p", "1080i"]
 		widescreen_modes = {"720p", "1080p", "1080i"}
-	elif about.getChipSetString() in ('meson-64'):
+	elif about.getChipSetString() in ('meson-64','S905D'):
 		modes["HDMI"] = ["720p", "1080p", "2160p", "2160p30", "1080i"]
 		widescreen_modes = {"720p", "1080p", "1080i", "2160p", "2160p30"}
 	else:
@@ -92,16 +121,16 @@ class AVSwitch:
 		widescreen_modes = {"720p", "1080i"}
 
 	modes["YPbPr"] = modes["HDMI"]
-	if getBoxType() in ('dm500hd', 'dm800', 'vuuno', 'vusolo', 'vusolo2', 'vuultimo', 'vuduo', 'vuduo2'):
+	if has_scartyuv:
 		modes["Scart-YPbPr"] = modes["HDMI"]
 
 	# if modes.has_key("DVI-PC") and not getModeList("DVI-PC"):
-	# 	print "remove DVI-PC because of not existing modes"
+	# 	print "[AVSwitch] remove DVI-PC because of not existing modes"
 	# 	del modes["DVI-PC"]
-	if modes.has_key("YPbPr") and getBoxType() in ('zgemmah9t','zgemmah9s','vuzero4k','vuuno4kse','anadol4k','mediabox4k','dinobot4kl','dinobot4k','dinobot4kse','lunix','purehdse','lunix34k','sf5008','et13000','zgemmah6','vipert2c','vipercombo','vipercombohdd','e4hdultra','evoslimse','evoslimt2c','beyonwizu4','zgemmah4','osnino','osninoplus','axultra','gbue4k','spycat4kcombo','spycat4k','valalinux','formuler4ip','formuler3ip','tm4ksuper','galaxy4k','zgemmah52splus','zgemmah2splus','zgemmah7','zgemmah32tc','zgemmah52tc','alphatriple','gi11000','spycat4kmini','tmtwin4k','tmnanom3','tiviarmin','vimastec1000','vimastec1500', 'gbquad4k','revo4k','force3uhdplus','force3uhd','force2nano','evoslim','zgemmah5ac', 'zgemmah3ac', 'bre2zet2c', 'dm900', 'dm920', 'wetekplay', 'wetekplay2', 'wetekhub', 'bre2ze4k', 'vuuno4k', 'vuultimo4k', 'sf4008', 'e4hdcombo', 'ultrabox', 'osmega', 'tmnano3t', 'novaip', 'novacombo', 'novatwin', 'dm520', 'dm525', 'megaforce2', 'purehd', 'sf128', 'sf138', 'mutant11', 'xpeedlxpro', 'mbtwinplus', 'mutant51', 'ax51', 'twinboxlcdci5' , 'twinboxlcdci', 'singleboxlcd', 'formuler4', 'formuler4turbo', 'zgemmah5', 'zgemmah52s', 'zgemmai55', 'sf98', 'odinplus', 'zgemmaslc', '9900lx', '9910lx', '9911lx', 'vusolo4k', 'et7x00mini', 'evomini', 'evominiplus', 'zgemmahs', 'zgemmah2s', 'zgemmah2h', 't2cable', 'xpeedlxcs2', 'xpeedlxcc', 'osmini', 'osminiplus', 'gbx1', 'gbx2', 'gbx3', 'gbx3h', 'sf3038', 'spycat', 'bwidowx', 'bwidowx2', 'fegasusx3', 'fegasusx5s', 'fegasusx5t', 'force2', 'force2plus', 'force2plushv', 'optimussos', 'tmnanose', 'tmnanosem2', 'tmnanosem2plus', 'tmnanocombo', 'zgemmash1', 'zgemmash2', 'zgemmas2s', 'zgemmass', 'mago', 'enibox', 'sf108', 'x1plus', 'xcombo', 'mutant1100', 'mutant1200', 'mutant1265', 'mutant1500', 'mutant500c', 'mutant530c', 'et4x00', 'et7500', 'et7000', 'et7100', 'et8500', 'et8500s', 'xp1000mk', 'xp1000max', 'xp1000plus', 'sf8', 'tm2t', 'tmsingle', 'vusolo2', 'tmnano', 'iqonios300hd', 'iqonios300hdv2', 'classm', 'axodin', 'axodinc', 'genius', 'evo', 'galaxym6', 'geniuse3hd', 'evoe3hd', 'axase3', 'axase3c', 'dm500hdv2', 'dm500hd', 'dm800', 'mixosf7', 'mixoslumi', 'mixosf5mini', 'gi9196lite', 'ixusszero', 'optimussos1', 'enfinity', 'marvel1', 'bre2ze', 'sezam1000hd', 'mbmini', 'atemio5x00', 'xpeedlx1', 'xpeedlx2', 'vusolose', 'gbipbox', 'formuler3', 'optimussos3plus', 'force1plus', 'vuzero', 'vizyonvita') or (about.getModelString() == 'ini-3000'):
+	if modes.has_key("YPbPr") and not has_yuv:
 		del modes["YPbPr"]
-	if modes.has_key("Scart") and getBoxType() in ('zgemmah9t','zgemmah9s','vuzero4k','vuuno4kse','lunix','purehdse','sf5008','et13000','e4hdultra','beyonwizu4','osnino','osninoplus','axultra','gbue4k','gi11000','spycat4kmini','tmtwin4k','tmnanom3','gbquad4k','revo4k','force3uhd','force2nano','dm900', 'dm920', 'wetekplay', 'wetekplay2', 'wetekhub', 'bre2ze4k', 'vuuno4k', 'vuultimo4k', 'sf4008', 'novaip', 'dm520', 'dm525', 'purehd', 'vusolo4k', 'fusionhdse', 'fusionhd', 'force2', 'force2plus', 'force2plushv', 'optimussos', 'tmnanose', 'tmnanosecombo', 'gbx1', 'gbx2', 'gbx3', 'gbx3h', 'gbultraue', 'gbultraueh', 'zgemmai55', 'mutant1500'):
-		del modes["Scart"]
+	if modes.has_key("Scart") and not has_scart and not has_rca and not has_avjack:
+			del modes["Scart"]
 		
 	if getBoxType() in ('mutant2400'):
 		f = open("/proc/stb/info/board_revision", "r").read()
@@ -115,9 +144,11 @@ class AVSwitch:
 		self.current_port = None
 
 		self.readAvailableModes()
+		self.is24hzAvailable()
 
-		self.createConfig()
 		self.readPreferredModes()
+		self.createConfig()
+
 
 	def readAvailableModes(self):
 		try:
@@ -125,35 +156,63 @@ class AVSwitch:
 			modes = f.read()[:-1]
 			f.close()
 		except IOError:
-			print "couldn't read available videomodes."
+			print "[AVSwitch] couldn't read available videomodes."
 			self.modes_available = [ ]
 			return
 		self.modes_available = modes.split(' ')
 
 	def readPreferredModes(self):
-		try:
-			f = open("/proc/stb/video/videomode_preferred")
-			modes = f.read()[:-1]
-			f.close()
-			self.modes_preferred = modes.split(' ')
-		except IOError:
-			print "reading preferred modes failed, using all modes"
+		if config.av.edid_override.value == False:
+			try:
+				f = open("/proc/stb/video/videomode_edid")
+				modes = f.read()[:-1]
+				f.close()
+				self.modes_preferred = modes.split(' ')
+				print "[AVSwitch] reading edid modes: ", self.modes_preferred
+			except IOError:
+				print "[AVSwitch] reading edid modes failed, using all modes"
+				try:
+					f = open("/proc/stb/video/videomode_preferred")
+					modes = f.read()[:-1]
+					f.close()
+					self.modes_preferred = modes.split(' ')
+					print "[AVSwitch] reading _preferred modes: ", self.modes_preferred
+				except IOError:
+					print "[AVSwitch] reading preferred modes failed, using all modes"
+					self.modes_preferred = self.modes_available
+		else:
+			self.modes_preferred = self.modes_available
+			print "[AVSwitch] used default modes: ", self.modes_preferred
+			
+		if len(self.modes_preferred) <= 2:
+			print "[AVSwitch] preferend modes not ok, possible driver failer, len=", len(self.modes_preferred)
 			self.modes_preferred = self.modes_available
 
 		if self.modes_preferred != self.last_modes_preferred:
 			self.last_modes_preferred = self.modes_preferred
 			self.on_hotplug("HDMI") # must be HDMI
 
+	def is24hzAvailable(self):
+		try:
+			self.has24pAvailable = os.access("/proc/stb/video/videomode_24hz", os.W_OK) and True or False
+		except IOError:
+			print "[AVSwitch] failed to read video choices 24hz ."
+			self.has24pAvailable = False
+		SystemInfo["have24hz"] = self.has24pAvailable
+
 	# check if a high-level mode with a given rate is available.
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
 			if port == "DVI":
-				if hw_type in ('elite', 'premium', 'premium+', 'ultra', "me", "minime"):
+				if getBrandOEM() in ('azbox'):
 					if mode not in self.modes_preferred and not config.av.edid_override.value:
-						print "no, not preferred"
+						print "[AVSwitch] no, not preferred"
 						return False
-			if mode not in self.modes_available:
+			if port != "HDMI":
+				if mode not in self.modes_available:
+					return False
+			elif mode not in self.modes_preferred:
 				return False
 		return True
 
@@ -161,7 +220,7 @@ class AVSwitch:
 		return mode in self.widescreen_modes
 
 	def setMode(self, port, mode, rate, force = None):
-		print "[VideoMode] setMode - port: %s, mode: %s, rate: %s" % (port, mode, rate)
+		print "[AVSwitch] setMode - port: %s, mode: %s, rate: %s" % (port, mode, rate)
 
 		# config.av.videoport.setValue(port)
 		# we can ignore "port"
@@ -172,10 +231,16 @@ class AVSwitch:
 
 		mode_50 = modes.get(50)
 		mode_60 = modes.get(60)
+		mode_24 = modes.get(24)
+
 		if mode_50 is None or force == 60:
 			mode_50 = mode_60
 		if mode_60 is None or force == 50:
 			mode_60 = mode_50
+		if mode_24 is None or force:
+			mode_24 = mode_60
+			if force == 50:
+				mode_24 = mode_50
 
 		try:
 			f = open("/proc/stb/video/videomode_50hz", "w")
@@ -193,13 +258,20 @@ class AVSwitch:
 			except IOError:
 				print "[AVSwitch] setting videomode failed."
 
-#		try:
-#			# use 50Hz mode (if available) for booting
-#			f = open("/etc/videomode", "w")
-#			f.write(mode_50)
-#			f.close()
-#		except IOError:
-#			print "[AVSwitch] writing initial videomode to /etc/videomode failed."
+		if SystemInfo["have24hz"]:
+			try:
+				open("/proc/stb/video/videomode_24hz", "w").write(mode_24)
+			except IOError:
+				print "[VideoHardware] cannot open /proc/stb/video/videomode_24hz"
+
+		if getBrandOEM() in ('gigablue'):
+			try:
+				# use 50Hz mode (if available) for booting
+				f = open("/etc/videomode", "w")
+				f.write(mode_50)
+				f.close()
+			except IOError:
+				print "[AVSwitch] writing initial videomode to /etc/videomode failed."
 
 		map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
 		self.setColorFormat(map[config.av.colorformat.value])
@@ -278,11 +350,16 @@ class AVSwitch:
 				config.av.autores_mode_fhd[port] = ConfigSelection(choices = [mode for (mode, rates) in modes])
 				config.av.autores_mode_uhd[port] = ConfigSelection(choices = [mode for (mode, rates) in modes])
 			for (mode, rates) in modes:
-				config.av.videorate[mode] = ConfigSelection(choices = rates)
-				config.av.autores_rate_sd[mode] = ConfigSelection(choices = rates)
-				config.av.autores_rate_hd[mode] = ConfigSelection(choices = rates)
-				config.av.autores_rate_fhd[mode] = ConfigSelection(choices = rates)
-				config.av.autores_rate_uhd[mode] = ConfigSelection(choices = rates)
+				ratelist = []
+				for rate in rates:
+					if rate in ("auto") and not SystemInfo["have24hz"]:
+						continue
+					ratelist.append((rate, rate))
+				config.av.videorate[mode] = ConfigSelection(choices = ratelist)
+				config.av.autores_rate_sd[mode] = ConfigSelection(choices = ratelist)
+				config.av.autores_rate_hd[mode] = ConfigSelection(choices = ratelist)
+				config.av.autores_rate_fhd[mode] = ConfigSelection(choices = ratelist)
+				config.av.autores_rate_uhd[mode] = ConfigSelection(choices = ratelist)
 		config.av.videoport = ConfigSelection(choices = lst)
 
 	def setInput(self, input):
@@ -302,26 +379,26 @@ class AVSwitch:
 	def setConfiguredMode(self):
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
-			print "current port not available, not setting videomode"
+			print "[AVSwitch] current port not available, not setting videomode"
 			return
 
 		mode = config.av.videomode[port].value
 
 		if mode not in config.av.videorate:
-			print "current mode not available, not setting videomode"
+			print "[AVSwitch] current mode not available, not setting videomode"
 			return
 
 		rate = config.av.videorate[mode].value
 		self.setMode(port, mode, rate)
 
 	def setAspect(self, cfgelement):
-		print "[VideoMode] setting aspect: %s" % cfgelement.value
+		print "[AVSwitch] setting aspect: %s" % cfgelement.value
 		try:
 			f = open("/proc/stb/video/aspect", "w")
 			f.write(cfgelement.value)
 			f.close()
 		except IOError:
-			print "setting aspect failed."
+			print "[AVSwitch] setting aspect failed."
 
 	def setWss(self, cfgelement):
 		if not cfgelement.value:
@@ -329,13 +406,13 @@ class AVSwitch:
 		else:
 			wss = "auto"
 		if os.path.exists("/proc/stb/denc/0/wss"):
-			print "[VideoMode] setting wss: %s" % wss
+			print "[AVSwitch] setting wss: %s" % wss
 			f = open("/proc/stb/denc/0/wss", "w")
 			f.write(wss)
 			f.close()
 
 	def setPolicy43(self, cfgelement):
-		print "[VideoMode] setting policy: %s" % cfgelement.value
+		print "[AVSwitch] setting policy: %s" % cfgelement.value
 		arw = "0"
 		try:
 			if about.getChipSetString() in ('meson-6', 'meson-64'):
@@ -348,11 +425,11 @@ class AVSwitch:
 				f.write(cfgelement.value)
 				f.close()
 		except IOError:
-			print "setting policy43 failed."
+			print "[AVSwitch] setting policy43 failed."
 
 	def setPolicy169(self, cfgelement):
 		if os.path.exists("/proc/stb/video/policy2"):
-			print "[VideoMode] setting policy2: %s" % cfgelement.value
+			print "[AVSwitch] setting policy2: %s" % cfgelement.value
 			f = open("/proc/stb/video/policy2", "w")
 			f.write(cfgelement.value)
 			f.close()
@@ -414,11 +491,11 @@ class AVSwitch:
 iAVSwitch = AVSwitch()
 
 def InitAVSwitch():
-	if getBoxType() == 'vuduo' or getBoxType().startswith('ixuss'):	
+	if getBoxType() == 'vuduo' or getBoxType().startswith('ixuss'):
 		config.av.yuvenabled = ConfigBoolean(default=False)
 	else:
 		config.av.yuvenabled = ConfigBoolean(default=True)
-	config.av.osd_alpha = ConfigSlider(default=255, increment = 5, limits=(20,255)) # Make OpenPlus compatible with some plugins who still use config.av.osd_alpha
+	config.av.osd_alpha = ConfigSlider(default=255, increment = 5, limits=(20,255)) # Make openATV compatible with some plugins who still use config.av.osd_alpha
 	colorformat_choices = {"cvbs": _("CVBS"), "rgb": _("RGB"), "svideo": _("S-Video")}
 	# when YUV is not enabled, don't let the user select it
 	if config.av.yuvenabled.value:
@@ -519,6 +596,9 @@ def InitAVSwitch():
 	if "scale" in policy2_choices_raw and not "auto" in policy2_choices_raw and not "bestfit" in policy2_choices_raw:
 		# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching all parts of the picture with the same factor (All parts lose aspect))
 		policy2_choices.update({"scale": _("Stretch linear")})
+	if "full" in policy2_choices_raw:
+		# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching all parts of the picture with the same factor (force aspect))
+		policy2_choices.update({"full": _("Stretch full")})
 	if "auto" in policy2_choices_raw and not "bestfit" in policy2_choices_raw:
 		# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching all parts of the picture with the same factor (All parts lose aspect))
 		policy2_choices.update({"auto": _("Stretch linear")})
@@ -569,6 +649,9 @@ def InitAVSwitch():
 	if "scale" in policy_choices_raw and not "auto" in policy_choices_raw and not "bestfit" in policy_choices_raw:
 		# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching all parts of the picture with the same factor (All parts lose aspect))
 		policy_choices.update({"scale": _("Stretch linear")})
+	if "full" in policy_choices_raw:
+		# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching all parts of the picture with the same factor (force aspect))
+		policy_choices.update({"full": _("Stretch full")})
 	if "auto" in policy_choices_raw and not "bestfit" in policy_choices_raw:
 		# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching all parts of the picture with the same factor (All parts lose aspect))
 		policy_choices.update({"auto": _("Stretch linear")})
@@ -640,6 +723,13 @@ def InitAVSwitch():
 		config.av.bypass_edid_checking.addNotifier(setEDIDBypass)
 	else:
 		config.av.bypass_edid_checking = ConfigNothing()
+		
+		
+	def setUnsupportModes(configElement):
+		iAVSwitch.readPreferredModes()
+		iAVSwitch.createConfig()
+
+	config.av.edid_override.addNotifier(setUnsupportModes)
 
 	if os.path.exists("/proc/stb/video/hdmi_colorspace"):
 		f = open("/proc/stb/video/hdmi_colorspace", "r")
@@ -658,7 +748,7 @@ def InitAVSwitch():
 				f.close()
 			except:
 				pass
-		if getBoxType() in ('vusolo4k','vuuno4k','vuuno4kse','vuultimo4k'):
+		if getBoxType() in ('vusolo4k','vuuno4k','vuuno4kse','vuultimo4k','vuduo4k'):
 			config.av.hdmicolorspace = ConfigSelection(choices={
 					"Edid(Auto)": _("Auto"),
 					"Hdmi_Rgb": _("RGB"),
@@ -772,6 +862,68 @@ def InitAVSwitch():
 		config.av.hdmicolordepth.addNotifier(setHdmiColordepth)
 	else:
 		config.av.hdmicolordepth = ConfigNothing()
+		
+		
+	if os.path.exists("/proc/stb/video/hdmi_hdrtype"):
+		f = open("/proc/stb/video/hdmi_hdrtype", "r")
+		have_HdmiHdrType = f.read().strip().split(" ")
+		f.close()
+	else:
+		have_HdmiHdrType = False
+
+	SystemInfo["havehdmihdrtype"] = have_HdmiHdrType
+
+	if have_HdmiHdrType:
+		def setHdmiHdrType(configElement):
+			try:
+				f = open("/proc/stb/video/hdmi_hdrtype", "w")
+				f.write(configElement.value)
+				f.close()
+			except:
+				pass
+		config.av.hdmihdrtype = ConfigSelection(choices={
+				"auto": _("Auto"),
+				"dolby": _("dolby"),
+				"none": _("sdr"),
+				"hdr10": _("hdr10"),
+				"hlg": _("hlg")},
+				default = "auto")
+		config.av.hdmihdrtype.addNotifier(setHdmiHdrType)
+	else:
+		config.av.hdmihdrtype = ConfigNothing()
+
+	if os.path.exists("/proc/stb/hdmi/hlg_support_choices"):
+		f = open("/proc/stb/hdmi/hlg_support_choices", "r")
+		have_HDRSupport = f.read().strip().split(" ")
+		f.close()
+	else:
+		have_HDRSupport = False
+
+	SystemInfo["HDRSupport"] = have_HDRSupport
+
+	if have_HDRSupport:
+		def setHlgSupport(configElement):
+			open("/proc/stb/hdmi/hlg_support", "w").write(configElement.value)
+		config.av.hlg_support = ConfigSelection(default = "auto(EDID)", 
+			choices = [ ("auto(EDID)", _("controlled by HDMI")), ("yes", _("force enabled")), ("no", _("force disabled")) ])
+		config.av.hlg_support.addNotifier(setHlgSupport)
+
+		def setHdr10Support(configElement):
+			open("/proc/stb/hdmi/hdr10_support", "w").write(configElement.value)
+		config.av.hdr10_support = ConfigSelection(default = "auto(EDID)", 
+			choices = [ ("auto(EDID)", _("controlled by HDMI")), ("yes", _("force enabled")), ("no", _("force disabled")) ])
+		config.av.hdr10_support.addNotifier(setHdr10Support)
+
+		def setDisable12Bit(configElement):
+			open("/proc/stb/video/disable_12bit", "w").write(configElement.value)
+		config.av.allow_12bit = ConfigSelection(default = "0", choices = [ ("0", _("yes")), ("1", _("no")) ]);
+		config.av.allow_12bit.addNotifier(setDisable12Bit)
+
+		def setDisable10Bit(configElement):
+			open("/proc/stb/video/disable_10bit", "w").write(configElement.value)
+		config.av.allow_10bit = ConfigSelection(default = "0", choices = [ ("0", _("yes")), ("1", _("no")) ]);
+		config.av.allow_10bit.addNotifier(setDisable10Bit)
+
 
 	if os.path.exists("/proc/stb/hdmi/audio_source"):
 		f = open("/proc/stb/hdmi/audio_source", "r")
@@ -829,9 +981,12 @@ def InitAVSwitch():
 
 	if can_3dsurround_speaker:
 		def set3DSurroundSpeaker(configElement):
-			f = open("/proc/stb/audio/3d_surround_speaker_position", "w")
-			f.write(configElement.value)
-			f.close()
+			try:
+				f = open("/proc/stb/audio/3d_surround_speaker_position", "w")
+				f.write(configElement.value)
+				f.close()
+			except:
+				pass
 		choice_list = [("center", _("center")), ("wide", _("wide")), ("extrawide", _("extra wide"))]
 		config.av.surround_3d_speaker = ConfigSelection(choices = choice_list, default = "center")
 		config.av.surround_3d_speaker.addNotifier(set3DSurroundSpeaker)
@@ -874,6 +1029,7 @@ def InitAVSwitch():
 		eDVBVolumecontrol.getInstance().setVolumeSteps(int(configElement.value))
 	config.av.volume_stepsize = ConfigSelectionNumber(1, 10, 1, default = 5)
 	config.av.volume_stepsize_fastmode = ConfigSelectionNumber(1, 10, 1, default = 5)
+	config.av.volume_hide_mute = ConfigYesNo(default = True)
 	config.av.volume_stepsize.addNotifier(setVolumeStepsize)
 
 	try:
@@ -901,7 +1057,8 @@ def InitAVSwitch():
 				if can_pcm_multichannel:
 					config.av.pcm_multichannel.setValue(False)
 		if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
-			config.av.downmix_ac3 = ConfigSelection(choices = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI"))], default = "downmix")
+			choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI"))]
+			config.av.downmix_ac3 = ConfigSelection(choices = choice_list, default = "downmix")
 		else:
 			config.av.downmix_ac3 = ConfigYesNo(default = True)
 		config.av.downmix_ac3.addNotifier(setAC3Downmix)
@@ -923,6 +1080,9 @@ def InitAVSwitch():
 		if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
 			choice_list = [("use_hdmi_caps", _("controlled by HDMI")), ("force_ac3", _("convert to AC3")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI")), ("force_ddp",  _("force AC3plus"))]
 			config.av.transcodeac3plus = ConfigSelection(choices = choice_list, default = "force_ac3")
+		elif getBoxType() in ('gbquad4k', 'gbue4k'):
+			choice_list = [("downmix", _("Downmix")), ("passthrough", _("Passthrough")), ("force_ac3", _("convert to AC3")), ("multichannel",  _("convert to multi-channel PCM")), ("force_dts",  _("convert to DTS"))]
+			config.av.transcodeac3plus = ConfigSelection(choices = choice_list, default = "force_ac3")
 		else:
 			choice_list = [("use_hdmi_caps", _("controlled by HDMI")), ("force_ac3", _("convert to AC3"))]
 			config.av.transcodeac3plus = ConfigSelection(choices = choice_list, default = "force_ac3")
@@ -997,7 +1157,7 @@ def InitAVSwitch():
 	if can_downmix_aac:
 		def setAACDownmix(configElement):
 			f = open("/proc/stb/audio/aac", "w")
-			if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
+			if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800', 'gbquad4k', 'gbue4k'):
 				f.write(configElement.value)
 			else:
 				f.write(configElement.value and "downmix" or "passthrough")
@@ -1005,10 +1165,32 @@ def InitAVSwitch():
 		if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
 			choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI"))]
 			config.av.downmix_aac = ConfigSelection(choices = choice_list, default = "downmix")
+		elif getBoxType() in ('gbquad4k', 'gbue4k'):
+			choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("force_ac3", _("convert to AC3")), ("force_dts",  _("convert to DTS")), ("use_hdmi_cacenter",  _("use_hdmi_cacenter")), ("wide",  _("wide")), ("extrawide",  _("extrawide"))]
+			config.av.downmix_aac = ConfigSelection(choices = choice_list, default = "downmix")
 		else:
 			config.av.downmix_aac = ConfigYesNo(default = True)
 		config.av.downmix_aac.addNotifier(setAACDownmix)
 
+	try:
+		f = open("/proc/stb/audio/aacplus_choices", "r")
+		file = f.read()[:-1]
+		f.close()
+		can_downmix_aacplus = "downmix" in file
+	except:
+		can_downmix_aacplus = False
+
+	SystemInfo["CanDownmixAACPlus"] = can_downmix_aacplus
+	if can_downmix_aacplus:
+		def setAACDownmixPlus(configElement):
+			f = open("/proc/stb/audio/aacplus", "w")
+			f.write(configElement.value)
+			f.close()
+
+		choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("force_ac3", _("convert to AC3")), ("force_dts",  _("convert to DTS")), ("use_hdmi_cacenter",  _("use_hdmi_cacenter")), ("wide",  _("wide")), ("extrawide",  _("extrawide"))]
+		config.av.downmix_aacplus = ConfigSelection(choices = choice_list, default = "downmix")
+		config.av.downmix_aacplus.addNotifier(setAACDownmixPlus)
+
 	if os.path.exists("/proc/stb/audio/aac_transcode_choices"):
 		f = open("/proc/stb/audio/aac_transcode_choices", "r")
 		can_aactranscode = f.read().strip().split(" ")
@@ -1033,7 +1215,7 @@ def InitAVSwitch():
 		def setScaler_sharpness(config):
 			myval = int(config.value)
 			try:
-				print "[VideoMode] setting scaler_sharpness to: %0.8X" % myval
+				print "[AVSwitch] setting scaler_sharpness to: %0.8X" % myval
 				f = open("/proc/stb/vmpeg/0/pep_scaler_sharpness", "w")
 				f.write("%0.8X\n" % myval)
 				f.close()
@@ -1041,7 +1223,7 @@ def InitAVSwitch():
 				f.write("1")
 				f.close()
 			except IOError:
-				print "couldn't write pep_scaler_sharpness"
+				print "[AVSwitch] couldn't write pep_scaler_sharpness"
 
 		if getBoxType() in ('gbquad', 'gbquadplus'):
 			config.av.scaler_sharpness = ConfigSlider(default=5, limits=(0,26))
@@ -1051,8 +1233,6 @@ def InitAVSwitch():
 	else:
 		config.av.scaler_sharpness = NoSave(ConfigNothing())
 
-	config.av.edid_override = ConfigYesNo(default = False)
-
 	iAVSwitch.setConfiguredMode()
 
 class VideomodeHotplug:
@@ -1066,20 +1246,20 @@ class VideomodeHotplug:
 		iAVSwitch.on_hotplug.remove(self.hotplug)
 
 	def hotplug(self, what):
-		print "hotplug detected on port '%s'" % what
+		print "[AVSwitch] hotplug detected on port '%s'" % what
 		port = config.av.videoport.value
 		mode = config.av.videomode[port].value
 		rate = config.av.videorate[mode].value
 
 		if not iAVSwitch.isModeAvailable(port, mode, rate):
-			print "mode %s/%s/%s went away!" % (port, mode, rate)
+			print "[AVSwitch] mode %s/%s/%s went away!" % (port, mode, rate)
 			modelist = iAVSwitch.getModeList(port)
 			if not len(modelist):
-				print "sorry, no other mode is available (unplug?). Doing nothing."
+				print "[AVSwitch] sorry, no other mode is available (unplug?). Doing nothing."
 				return
 			mode = modelist[0][0]
 			rate = modelist[0][1]
-			print "setting %s/%s/%s" % (port, mode, rate)
+			print "[AVSwitch] setting %s/%s/%s" % (port, mode, rate)
 			iAVSwitch.setMode(port, mode, rate)
 
 hotplug = None
diff --git a/lib/python/Components/About.py b/lib/python/Components/About.py
index a2036b3..bdf9c88 100644
--- a/lib/python/Components/About.py
+++ b/lib/python/Components/About.py
@@ -31,13 +31,8 @@ def getKernelVersionString():
 		return _("unknown")
 	
 def getModelString():
-	try:
-		file = open("/proc/stb/info/boxtype", "r")
-		model = file.readline().strip()
-		file.close()
+		model = getBoxType()
 		return model
-	except IOError:
-		return "unknown"
 
 def getChipSetString():
 	if getMachineBuild() in ('dm7080','dm820'):
@@ -48,6 +43,8 @@ def getChipSetString():
 		return "7252S"
 	elif getMachineBuild() in ('hd51','vs1500','h7'):
 		return "7251S"
+	elif getMachineBuild() in ('alien5'):
+		return "S905D"
 	else:
 		try:
 			f = open('/proc/stb/info/chipset', 'r')
@@ -58,15 +55,19 @@ def getChipSetString():
 			return "unavailable"
 
 def getCPUSpeedString():
-	if getMachineBuild() in ('vusolo4k','vuultimo4k', 'vuzero4k'):
+	if getMachineBuild() in ('dags72604','vusolo4k','vuultimo4k', 'vuzero4k'):
 		return "1,5 GHz"
 	elif getMachineBuild() in ('formuler1tc','formuler1', 'triplex', 'tiviaraplus'):
 		return "1,3 GHz"
-	elif getMachineBuild() in ('u5','u5pvr','h9'):
+	elif getMachineBuild() in ('u51','u52','u53','u54','u5','u5pvr','h9','h9combo','cc1','sf8008','sf8008s','hd60','i55plus','ustym4kpro','v8plus'):
 		return "1,6 GHz"
 	elif getMachineBuild() in ('vuuno4kse','vuuno4k','dm900','dm920', 'gb7252', 'dags7252','xc7439','8100s'):
 		return "1,7 GHz"
-	elif getMachineBuild() in ('hd51','hd52','sf4008','vs1500','et1x000','h7','et13000','sf5008'):
+	elif getMachineBuild() in ('alien5'):
+		return "2,0 GHz"
+	elif getMachineBuild() in ('vuduo4k'):
+		return "2,1 GHz"
+	elif getMachineBuild() in ('hd51','hd52','sf4008','vs1500','et1x000','h7','et13000','sf5008','osmio4k'):
 		try:
 			import binascii
 			f = open('/sys/firmware/devicetree/base/cpus/cpu@0/clock-frequency', 'rb')
@@ -95,10 +96,12 @@ def getCPUSpeedString():
 			return "unavailable"
 
 def getCPUString():
-	if getMachineBuild() in ('vuuno4kse','vuuno4k', 'vuultimo4k','vusolo4k', 'vuzero4k', 'hd51', 'hd52', 'sf4008', 'dm900','dm920', 'gb7252', 'dags7252', 'vs1500', 'et1x000', 'xc7439','h7','8100s','et13000','sf5008'):
+	if getMachineBuild() in ('vuduo4k','osmio4k','dags72604','vuuno4kse','vuuno4k', 'vuultimo4k','vusolo4k', 'vuzero4k', 'hd51', 'hd52', 'sf4008', 'dm900','dm920', 'gb7252', 'dags7252', 'vs1500', 'et1x000', 'xc7439','h7','8100s','et13000','sf5008'):
 		return "Broadcom"
-	elif getMachineBuild() in ('u5','u5pvr','h9'):
+	elif getMachineBuild() in ('u51','u52','u53','u54','u5','u5pvr','h9','h9combo','cc1','sf8008','sf8008s','hd60','i55plus','ustym4kpro','v8plus'):
 		return "Hisilicon"
+	elif getMachineBuild() in ('alien5'):
+		return "AMlogic"
 	else:
 		try:
 			system="unknown"
@@ -126,7 +129,7 @@ def getCpuCoresString():
 			if len(splitted) > 1:
 				splitted[1] = splitted[1].replace('\n','')
 				if splitted[0].startswith("processor"):
-					if getMachineBuild() in ('vuultimo4k','u5','u5pvr','h9'):
+					if getMachineBuild() in ('u51','u52','u53','u54','vuultimo4k','u5','u5pvr','h9','h9combo','alien5','cc1','sf8008','sf8008s','hd60','i55plus','ustym4kpro','v8plus','vuduo4k'):
 						cores = 4
 					elif int(splitted[1]) > 0:
 						cores = 2
diff --git a/lib/python/Components/Converter/PliExtraInfo.py b/lib/python/Components/Converter/PliExtraInfo.py
index 8235326..8a87efc 100644
--- a/lib/python/Components/Converter/PliExtraInfo.py
+++ b/lib/python/Components/Converter/PliExtraInfo.py
@@ -300,7 +300,8 @@ class PliExtraInfo(Poll, Converter, object):
 		fps  = str((info.getInfo(iServiceInformation.sFrameRate) + 500) / 1000)
 		if int(fps) <= 0:
 			fps = ""
-		return str(xres) + "x" + str(yres) + mode + fps
+		gamma = ("SDR", "HDR", "HDR10", "HLG", "")[info.getInfo(iServiceInformation.sGamma)]
+		return str(xres) + "x" + str(yres) + mode + fps + addspace(gamma)
 
 	def createVideoCodec(self, info):
 		return ("MPEG2", "MPEG4", "MPEG1", "MPEG4-II", "VC1", "VC1-SM", "")[info.getInfo(iServiceInformation.sVideoType)]
diff --git a/lib/python/Components/Converter/RemainingToText.py b/lib/python/Components/Converter/RemainingToText.py
index 76284c7..cda4aa4 100644
--- a/lib/python/Components/Converter/RemainingToText.py
+++ b/lib/python/Components/Converter/RemainingToText.py
@@ -210,7 +210,12 @@ class RemainingToText(Poll, Converter, object):
 					if remaining is None:	
 						return strftime(d, t)
 					if remaining is not None:
-						myRestMinuten = ngettext(_("%+6d"), _("%+6d"), (r/60)) % (r/60)
+						if config.usage.elapsed_time_positive_vfd.value:
+							myRestMinuten = "%+6d" % (r/60)
+						else:
+							myRestMinuten = "%+6d" % (r/60*-1)
+						if (r/60) == 0:
+							myRestMinuten = " "
 						return strftime(d, t) + myRestMinuten
 				elif self.type == self.WITH_SECONDS:
 					if remaining is not None:
diff --git a/lib/python/Components/Converter/ServiceInfo.py b/lib/python/Components/Converter/ServiceInfo.py
index 7a19474..874a741 100644
--- a/lib/python/Components/Converter/ServiceInfo.py
+++ b/lib/python/Components/Converter/ServiceInfo.py
@@ -39,6 +39,11 @@ class ServiceInfo(Converter, object):
 	IS_480 = 30
 	IS_4K = 31
 	IS_IPSTREAM = 32
+	IS_SDR = 33
+	IS_HDR = 34
+	IS_HDR10 = 35
+	IS_HLG = 36
+	IS_HDHDR = 37
 
 	def __init__(self, type):
 		Converter.__init__(self, type)
@@ -68,13 +73,18 @@ class ServiceInfo(Converter, object):
 				"Editmode": (self.EDITMODE, (iPlayableService.evUpdatedInfo,)),
 				"IsStream": (self.IS_STREAM, (iPlayableService.evUpdatedInfo,)),
 				"IsSD": (self.IS_SD, (iPlayableService.evVideoSizeChanged,)),
-				"IsHD": (self.IS_HD, (iPlayableService.evVideoSizeChanged,)),
+				"IsHD": (self.IS_HD, (iPlayableService.evVideoSizeChanged,iPlayableService.evVideoGammaChanged,)),
 				"Is1080": (self.IS_1080, (iPlayableService.evVideoSizeChanged,)),
 				"Is720": (self.IS_720, (iPlayableService.evVideoSizeChanged,)),
 				"Is576": (self.IS_576, (iPlayableService.evVideoSizeChanged,)),
 				"Is480": (self.IS_480, (iPlayableService.evVideoSizeChanged,)),
-				"Is4K": (self.IS_4K, (iPlayableService.evVideoSizeChanged,)),
+				"Is4K": (self.IS_4K, (iPlayableService.evVideoSizeChanged,iPlayableService.evVideoGammaChanged,)),
 				"IsIPStream": (self.IS_IPSTREAM, (iPlayableService.evUpdatedInfo,)),
+				"IsSDR": (self.IS_SDR, (iPlayableService.evVideoSizeChanged,iPlayableService.evVideoGammaChanged,)),
+				"IsHDR": (self.IS_HDR, (iPlayableService.evVideoSizeChanged,iPlayableService.evVideoGammaChanged,)),
+				"IsHDR10": (self.IS_HDR10, (iPlayableService.evVideoSizeChanged,iPlayableService.evVideoGammaChanged,)),
+				"IsHLG": (self.IS_HLG, (iPlayableService.evVideoSizeChanged,iPlayableService.evVideoGammaChanged,)),
+				"IsHDHDR": (self.IS_HDHDR, (iPlayableService.evVideoSizeChanged,iPlayableService.evVideoGammaChanged,)),
 			}[type]
 
 	def getServiceInfoString(self, info, what, convert = lambda x: "%d" % x):
@@ -101,6 +111,7 @@ class ServiceInfo(Converter, object):
 			return False
 
 		video_height = None
+		video_width = None
 		video_aspect = None
 		if path.exists("/proc/stb/vmpeg/0/yres"):
 			f = open("/proc/stb/vmpeg/0/yres", "r")
@@ -110,6 +121,14 @@ class ServiceInfo(Converter, object):
 				pass
 			f.close()
 
+		if path.exists("/proc/stb/vmpeg/0/xres"):
+			f = open("/proc/stb/vmpeg/0/xres", "r")
+			try:
+				video_width = int(f.read(),16)
+			except:
+				pass
+			f.close()
+
 		if path.exists("/proc/stb/vmpeg/0/aspect"):
 			f = open("/proc/stb/vmpeg/0/aspect", "r")
 			try:
@@ -117,6 +136,7 @@ class ServiceInfo(Converter, object):
 			except:
 				pass
 			f.close()
+
 		if not video_height:
 			video_height = int(info.getInfo(iServiceInformation.sVideoHeight))
 		if not video_aspect:
@@ -134,7 +154,8 @@ class ServiceInfo(Converter, object):
 				while idx < n:
 					i = audio.getTrackInfo(idx)
 					description = i.getDescription()
-					if description in ("AC3", "AC-3", "AC3+", "DTS"):
+					#if description in ("AC3", "AC-3", "AC3+", "DTS"):
+					if description and description.split()[0] in ("AC3", "AC-3", "AC3+", "DTS"): # some audio description has 'audio' as additional value (e.g. 'AC-3 audio')
 						if self.type == self.IS_MULTICHANNEL:
 							return True
 						elif self.type == self.AUDIO_STEREO:
@@ -172,7 +193,10 @@ class ServiceInfo(Converter, object):
 		elif self.type == self.IS_SD:
 			return video_height < 720
 		elif self.type == self.IS_HD:
-			return video_height >= 720 and video_height < 2151
+			if info.getInfo(iServiceInformation.sGamma) > 0:
+				return False
+			else:
+				return video_width >= 721 and video_width < 1980
 		elif self.type == self.IS_1080:
 			return video_height > 1000 and video_height <= 1080
 		elif self.type == self.IS_720:
@@ -181,10 +205,23 @@ class ServiceInfo(Converter, object):
 			return video_height > 500 and video_height <= 576
 		elif self.type == self.IS_480:
 			return video_height > 0 and video_height <= 480
-		elif self.type == self.IS_4K:
-			return video_height > 2152 and video_height <= 2160
+		elif self.type == self.IS_4K: 
+			if info.getInfo(iServiceInformation.sGamma) > 0:
+				return False
+			else:
+				return video_width > 2160 and video_width <= 3840
 		elif self.type == self.IS_IPSTREAM:
 			return service.streamed() is not None
+		elif self.type == self.IS_SDR:
+			return video_width > 2160 and video_width <= 3840 and info.getInfo(iServiceInformation.sGamma) == 0
+		elif self.type == self.IS_HDR:
+			return video_width > 2160 and video_width <= 3840 and info.getInfo(iServiceInformation.sGamma) == 1
+		elif self.type == self.IS_HDR10:
+			return video_width > 2160 and video_width <= 3840 and info.getInfo(iServiceInformation.sGamma) == 2
+		elif self.type == self.IS_HLG:
+			return video_width > 2160 and video_width <= 3840 and info.getInfo(iServiceInformation.sGamma) == 3
+		elif self.type == self.IS_HDHDR:
+			return video_width >= 721 and video_width < 1980 and info.getInfo(iServiceInformation.sGamma) > 0
 		return False
 
 	boolean = property(getBoolean)
diff --git a/lib/python/Components/Converter/ServiceName2.py b/lib/python/Components/Converter/ServiceName2.py
index a2708b2..b91d6c6 100644
--- a/lib/python/Components/Converter/ServiceName2.py
+++ b/lib/python/Components/Converter/ServiceName2.py
@@ -241,9 +241,9 @@ class ServiceName2(Converter, object):
 				else:
 					result += type
 			elif f == 'F':	# %F - frequency (dvb-s/s2/c/t) in KHz
-				if type in ('DVB-S') and self.tpdata.get('frequency', 0) >0 :
-					result += '%d MHz'%(self.tpdata.get('frequency', 0) / 1000) 
-				if type in ('DVB-C','DVB-T'):
+				if type in ('DVB-S','DVB-C') and self.tpdata.get('frequency', 0) >0 :
+					result += '%d MHz'%(self.tpdata.get('frequency', 0) / 1000)
+				if type in ('DVB-T'):
 					result += '%.3f MHz'%(((self.tpdata.get('frequency', 0) +500) / 1000) / 1000.0)
 #					result += '%.3f'%(((self.tpdata.get('frequency', 0) / 1000) +1) / 1000.0) + " MHz " 
 			elif f == 'f':	# %f - fec_inner (dvb-s/s2/c/t)
diff --git a/lib/python/Components/Converter/ServicePosition.py b/lib/python/Components/Converter/ServicePosition.py
index 7b4dec7..867ca7e 100644
--- a/lib/python/Components/Converter/ServicePosition.py
+++ b/lib/python/Components/Converter/ServicePosition.py
@@ -301,7 +301,12 @@ class ServicePosition(Poll, Converter, object):
 							elif self.type == self.TYPE_POSITION:
 								return sign_p + ngettext("%d Min", "%d Mins", (p/60)) % (p/60)
 							elif self.type == self.TYPE_REMAINING and self.OnlyMinute:
-								myRestMinuten = ngettext("%+6d", "%+6d", (r/60)) % (r/60)
+								if config.usage.elapsed_time_positive_vfd.value:
+									myRestMinuten = "%+6d" % (r/60)
+								else:
+									myRestMinuten = "%+6d" % (r/60*-1)
+								if (r/60) == 0:
+									myRestMinuten = " "
 								time = getTime()
 								t = localtime(time)
 								d = _("%-H:%M")
diff --git a/lib/python/Components/Converter/VfdDisplay.py b/lib/python/Components/Converter/VfdDisplay.py
index ab35602..6f88514 100644
--- a/lib/python/Components/Converter/VfdDisplay.py
+++ b/lib/python/Components/Converter/VfdDisplay.py
@@ -30,14 +30,14 @@ class VfdDisplay(Poll, Converter, object):
 						break
 				if 'loop' in self.type and self.delay:
 					self.loop = self.delay
-			if 'nozero' in self.type:
-				self.hour = '%'
+			if '12h' in self.type and 'nozero' in self.type:
+				self.hour = '%l'
+			elif '12h' in self.type:
+				self.hour = '%I'
+			elif 'nozero' in self.type:
+				self.hour = '%k'
 			else:
-				self.hour = '%02'
-			if '12h' in self.type:
-				self.hour = self.hour + 'I'
-			else:
-				self.hour = self.hour + 'H'
+				self.hour = '%H'
 
 	@cached
 	def getText(self):
diff --git a/lib/python/Components/EpgList.py b/lib/python/Components/EpgList.py
index db8f533..d507d82 100644
--- a/lib/python/Components/EpgList.py
+++ b/lib/python/Components/EpgList.py
@@ -1,4 +1,4 @@
-from time import localtime, time, strftime
+from time import localtime, time, strftime, mktime
 
 from enigma import eEPGCache, eListbox, eListboxPythonMultiContent, loadPNG, gFont, getDesktop, eRect, eSize, RT_HALIGN_LEFT, RT_HALIGN_RIGHT, RT_HALIGN_CENTER, RT_VALIGN_CENTER, RT_VALIGN_TOP, RT_WRAP, BT_SCALE, BT_KEEP_ASPECT_RATIO
 
@@ -6,13 +6,13 @@ from HTMLComponent import HTMLComponent
 from GUIComponent import GUIComponent
 from Components.MultiContent import MultiContentEntryText, MultiContentEntryPixmapAlphaBlend, MultiContentEntryPixmapAlphaTest
 from Components.Renderer.Picon import getPiconName
-from skin import parseColor, parseFont
+from skin import parseColor, parseFont, parameters as skinparameter
 from Tools.Alternatives import CompareWithAlternatives
 from Tools.LoadPixmap import LoadPixmap
 from Components.config import config
 from ServiceReference import ServiceReference
 from Tools.Directories import resolveFilename, SCOPE_ACTIVE_SKIN
-
+from Tools.TextBoundary import getTextBoundarySize
 
 EPG_TYPE_SINGLE = 0
 EPG_TYPE_MULTI = 1
@@ -21,9 +21,12 @@ EPG_TYPE_ENHANCED = 3
 EPG_TYPE_INFOBAR = 4
 EPG_TYPE_GRAPH = 5
 EPG_TYPE_INFOBARGRAPH = 7
+EPG_TYPE_VERTICAL = 8
 
 MAX_TIMELINES = 6
 
+sf = 1
+
 class Rect:
 	def __init__(self, x, y, width, height):
 		self.x = x
@@ -46,6 +49,18 @@ class Rect:
 
 class EPGList(HTMLComponent, GUIComponent):
 	def __init__(self, type = EPG_TYPE_SINGLE, selChangedCB = None, timer = None, time_epoch = 120, overjump_empty = False, graphic=False):
+		global sf
+		self.screenwidth = getDesktop(0).size().width()
+		if self.screenwidth and self.screenwidth == 1920:
+			sf = 1.5
+			self.posx, self.posy , self.picx, self.picy, self.gap = skinparameter.get("EpgListIcon", (2,13,25,25,2))
+			self.column_service, self.column_time , self.column_remaining, self.column_gap = skinparameter.get("EpgListMulti", (240,180,120,30))
+			self.progress_width, self.progress_height , self.progress_borderwidth = skinparameter.get("EpgListMultiProgressBar", (120,15,1))
+		else:
+			self.posx, self.posy , self.picx, self.picy, self.gap = skinparameter.get("EpgListIcon", (1,11,23,23,1))
+			self.column_service, self.column_time , self.column_remaining, self.column_gap = skinparameter.get("EpgListMulti", (160,120,80,20))
+			self.progress_width, self.progress_height , self.progress_borderwidth = skinparameter.get("EpgListMultiProgressBar", (80,10,1))
+
 		self.cur_event = None
 		self.cur_service = None
 		self.offs = 0
@@ -58,9 +73,12 @@ class EPGList(HTMLComponent, GUIComponent):
 		self.currentlyPlaying = None
 		self.showPicon = False
 		self.showServiceTitle = True
-		self.screenwidth = getDesktop(0).size().width()
+		self.showServiceNumber = False
 		self.skinUsingForeColorByTime = False
 		self.skinUsingBackColorByTime = False
+		#//vertical
+		self.days = (_("Mon"), _("Tue"), _("Wed"), _("Thu"), _("Fri"), _("Sat"), _("Sun"))
+		#//
 
 		self.overjump_empty = overjump_empty
 		self.timer = timer
@@ -78,6 +96,8 @@ class EPGList(HTMLComponent, GUIComponent):
 			self.l.setBuildFunc(self.buildMultiEntry)
 		elif type == EPG_TYPE_GRAPH or type == EPG_TYPE_INFOBARGRAPH:
 			self.l.setBuildFunc(self.buildGraphEntry)
+		elif type == EPG_TYPE_VERTICAL:
+			self.l.setBuildFunc(self.buildVerticalEntry)
 		else:
 			assert(type == EPG_TYPE_SIMILAR)
 			self.l.setBuildFunc(self.buildSimilarEntry)
@@ -116,6 +136,7 @@ class EPGList(HTMLComponent, GUIComponent):
 				LoadPixmap(cached=True, path=resolveFilename(SCOPE_ACTIVE_SKIN, 'icons/epgclock_selpost.png'))]
 
 		self.autotimericon = LoadPixmap(cached=True, path=resolveFilename(SCOPE_ACTIVE_SKIN, 'icons/epgclock_autotimer.png'))
+		self.primetimeicon = LoadPixmap(cached=True, path=resolveFilename(SCOPE_ACTIVE_SKIN, 'icons/epgclock_primetime.png'))
 
 		self.nowEvPix = None
 		self.nowSelEvPix = None
@@ -160,6 +181,10 @@ class EPGList(HTMLComponent, GUIComponent):
 		self.backColorPastSelected = 0xd69600
 		self.foreColorServiceNow = 0xffffff
 		self.backColorServiceNow = 0x00825F
+		self.foreColorTime = 0xF0A30A
+		self.backColorTime = 0x2D455E
+		self.foreColorPrimeTime = 0xffffff
+		self.backColorPrimeTime = 0x704A05
 
 		self.foreColorRecord = 0xffffff
 		self.backColorRecord = 0xd13333
@@ -176,26 +201,23 @@ class EPGList(HTMLComponent, GUIComponent):
 		self.eventFontNameMulti = "Regular"
 		self.serviceFontNameInfobar = "Regular"
 		self.eventFontNameInfobar = "Regular"
-
-		if self.screenwidth and self.screenwidth == 1920:
-			self.serviceFontSizeGraph = 30
-			self.eventFontSizeGraph = 27
-			self.eventFontSizeSingle = 33
-			self.eventFontSizeMulti = 33
-			self.serviceFontSizeInfobar = 30
-			self.eventFontSizeInfobar = 33
-		else:
-			self.serviceFontSizeGraph = 20
-			self.eventFontSizeGraph = 18
-			self.eventFontSizeSingle = 22
-			self.eventFontSizeMulti = 22
-			self.serviceFontSizeInfobar = 20
-			self.eventFontSizeInfobar = 22
+		self.eventFontNameVertical = "Regular"
+		self.timeFontNameVertical = "Regular"
+
+		self.serviceFontSizeGraph = int(20 * sf)
+		self.eventFontSizeGraph = int(18 * sf)
+		self.eventFontSizeSingle = int(22 * sf)
+		self.eventFontSizeMulti = int(22 * sf)
+		self.serviceFontSizeInfobar = int(20 * sf)
+		self.eventFontSizeInfobar = int(22 * sf)
+		self.eventFontSizeVertical = int(18 * sf)
+		self.timeFontSizeVertical = int(20 * sf)
 
 		self.listHeight = None
 		self.listWidth = None
 		self.serviceBorderWidth = 1
 		self.serviceNamePadding = 3
+		self.serviceNumberPadding = 9
 		self.eventBorderWidth = 1
 		self.eventNamePadding = 3
 		self.eventNameAlign = 'left'
@@ -232,6 +254,14 @@ class EPGList(HTMLComponent, GUIComponent):
 					font = parseFont(value, ((1,1),(1,1)) )
 					self.eventFontNameMulti = font.family
 					self.eventFontSizeMulti = font.pointSize
+				elif attrib == "EventFontVertical":
+					font = parseFont(value, ((1,1),(1,1)) )
+					self.eventFontNameVertical = font.family
+					self.eventFontSizeVertical = font.pointSize
+				elif attrib == "TimeFontVertical":
+					font = parseFont(value, ((1,1),(1,1)) )
+					self.timeFontNameVertical = font.family
+					self.timeFontSizeVertical = font.pointSize
 				elif attrib == "EntryFontAlignment":
 					self.eventNameAlign = value
 				elif attrib == "EntryFontWrap":
@@ -278,6 +308,14 @@ class EPGList(HTMLComponent, GUIComponent):
 				elif attrib == "EntryForegroundColorPastSelected":
 					self.foreColorPastSelected = parseColor(value).argb()
 					self.skinUsingForeColorByTime = True
+				elif attrib == "TimeForegroundColor":
+					self.foreColorTime = parseColor(value).argb()
+				elif attrib == "TimeBackgroundColor":
+					self.backColorTime = parseColor(value).argb()
+				elif attrib == "PrimeTimeForegroundColor":
+					self.foreColorPrimeTime = parseColor(value).argb()
+				elif attrib == "PrimeTimeBackgroundColor":
+					self.backColorPrimeTime = parseColor(value).argb()
 
 				elif attrib == "ServiceBorderColor":
 					self.borderColorService = parseColor(value).argb()
@@ -285,6 +323,8 @@ class EPGList(HTMLComponent, GUIComponent):
 					self.serviceBorderWidth = int(value)
 				elif attrib == "ServiceNamePadding":
 					self.serviceNamePadding = int(value)
+				elif attrib == "ServiceNumberPadding":
+					self.serviceNumberPadding = int(value)
 				elif attrib == "EntryBorderColor":
 					self.borderColor = parseColor(value).argb()
 				elif attrib == "EventBorderWidth":
@@ -325,10 +365,11 @@ class EPGList(HTMLComponent, GUIComponent):
 			return self.l.getCurrentSelection()[0]
 		return 0
 
-	def isSelectable(self, service, service_name, events, picon):
+	def isSelectable(self, service, service_name, events, picon, channel):
 		return (events and len(events) and True) or False
 
 	def setShowServiceMode(self, value):
+		self.showServiceNumber = "servicenumber" in value
 		self.showServiceTitle = "servicename" in value
 		self.showPicon = "picon" in value
 		self.recalcEntrySize()
@@ -357,14 +398,10 @@ class EPGList(HTMLComponent, GUIComponent):
 	def getIndexFromService(self, serviceref):
 		if serviceref is not None:
 			for x in range(len(self.list)):
-				if str(self.list[x][0]).startswith('1:'): # check for Graphical EPG
-					if CompareWithAlternatives(self.list[x][0], serviceref.toString()):
-						return x
-				elif str(self.list[x][1]).startswith('1:'): # check for Multi EPG
-					if CompareWithAlternatives(self.list[x][1], serviceref.toString()):
-						return x
-				else:
-					return 0
+				if CompareWithAlternatives(self.list[x][0], serviceref.toString()):
+					return x
+				if CompareWithAlternatives(self.list[x][1], serviceref.toString()):
+					return x
 		return 0
 
 	def getCurrentIndex(self):
@@ -425,11 +462,11 @@ class EPGList(HTMLComponent, GUIComponent):
 		if cur_sel:
 			self.findBestEvent()
 
-	def findBestEvent(self):
+	def findBestEvent(self, getnow = False):
 		old_service = self.cur_service  #(service, service_name, events, picon)
 		cur_service = self.cur_service = self.l.getCurrentSelection()
 		time_base = self.getTimeBase()
-		last_time = time()
+		now = last_time = time()
 		if old_service and self.cur_event is not None:
 			try:
 				events = old_service[2]
@@ -453,9 +490,9 @@ class EPGList(HTMLComponent, GUIComponent):
 					if best is None or (diff < best_diff):
 						best = idx
 						best_diff = diff
-					if ev_end_time < time():
+					if ev_end_time < now:
 						best = idx+1
-					if best is not None and ev_time > last_time and ev_end_time > time():
+					if best is not None and ev_end_time > now and (ev_time > last_time or (getnow and ev_time < now)):
 						break
 					idx += 1
 			self.cur_event = best
@@ -474,14 +511,14 @@ class EPGList(HTMLComponent, GUIComponent):
 				if self.listHeight > 0:
 					itemHeight = self.listHeight / config.epgselection.graph_itemsperpage.value
 				else:
-					itemHeight = 54 # some default (270/5)
+					itemHeight = 54*sf # some default (270/5)
 				if config.epgselection.graph_heightswitch.value:
 					if ((self.listHeight / config.epgselection.graph_itemsperpage.value) / 3) >= 27:
 						tmp_itemHeight = ((self.listHeight / config.epgselection.graph_itemsperpage.value) / 3)
 					elif ((self.listHeight / config.epgselection.graph_itemsperpage.value) / 2) >= 27:
 						tmp_itemHeight = ((self.listHeight / config.epgselection.graph_itemsperpage.value) / 2)
 					else:
-						tmp_itemHeight = 27
+						tmp_itemHeight = 27*sf
 					if tmp_itemHeight < itemHeight:
 						itemHeight = tmp_itemHeight
 					else:
@@ -490,16 +527,17 @@ class EPGList(HTMLComponent, GUIComponent):
 						elif ((self.listHeight / config.epgselection.graph_itemsperpage.value) * 2) <= 45:
 							itemHeight = ((self.listHeight / config.epgselection.graph_itemsperpage.value) * 2)
 						else:
-							itemHeight = 45
+							itemHeight = 45*sf
 			elif self.type == EPG_TYPE_INFOBARGRAPH:
 				if self.listHeight > 0:
 					itemHeight = self.listHeight / config.epgselection.infobar_itemsperpage.value
 				else:
-					itemHeight = 54 # some default (270/5)
+					itemHeight = 54*sf # some default (270/5)
 			if self.NumberOfRows:
 				itemHeight = self.listHeight / self.NumberOfRows
+			itemHeight = int(itemHeight)
 			self.l.setItemHeight(itemHeight)
-			self.instance.resize(eSize(self.listWidth, self.listHeight / itemHeight * itemHeight))
+			self.instance.resize(eSize(self.listWidth, int(self.listHeight / itemHeight * itemHeight)))
 			self.listHeight = self.instance.size().height()
 			self.listWidth = self.instance.size().width()
 			self.itemHeight = itemHeight
@@ -508,11 +546,12 @@ class EPGList(HTMLComponent, GUIComponent):
 			if self.listHeight > 0:
 				itemHeight = self.listHeight / config.epgselection.enhanced_itemsperpage.value
 			else:
-				itemHeight = 32
+				itemHeight = 32*sf
 			if itemHeight < 15:
-				itemHeight = 15
+				itemHeight = 15*sf
+			itemHeight = int(itemHeight)
 			self.l.setItemHeight(itemHeight)
-			self.instance.resize(eSize(self.listWidth, self.listHeight / itemHeight * itemHeight))
+			self.instance.resize(eSize(self.listWidth, int(self.listHeight / itemHeight * itemHeight)))
 			self.listHeight = self.instance.size().height()
 			self.listWidth = self.instance.size().width()
 			self.itemHeight = itemHeight
@@ -520,11 +559,12 @@ class EPGList(HTMLComponent, GUIComponent):
 			if self.listHeight > 0:
 				itemHeight = self.listHeight / config.epgselection.multi_itemsperpage.value
 			else:
-				itemHeight = 32
+				itemHeight = 32*sf
 			if itemHeight < 25:
-				itemHeight = 25
+				itemHeight = 25*sf
+			itemHeight = int(itemHeight)
 			self.l.setItemHeight(itemHeight)
-			self.instance.resize(eSize(self.listWidth, self.listHeight / itemHeight * itemHeight))
+			self.instance.resize(eSize(self.listWidth, int(self.listHeight / itemHeight * itemHeight)))
 			self.listHeight = self.instance.size().height()
 			self.listWidth = self.instance.size().width()
 			self.itemHeight = itemHeight
@@ -532,11 +572,23 @@ class EPGList(HTMLComponent, GUIComponent):
 			if self.listHeight > 0:
 				itemHeight = self.listHeight / config.epgselection.infobar_itemsperpage.value
 			else:
-				itemHeight = 32
+				itemHeight = 32*sf
 			if itemHeight < 25:
-				itemHeight = 20
-			self.l.setItemHeight(int(itemHeight))
-			self.instance.resize(eSize(self.listWidth, self.listHeight / itemHeight * itemHeight))
+				itemHeight = 20*sf
+			itemHeight = int(itemHeight)
+			self.l.setItemHeight(itemHeight)
+			self.instance.resize(eSize(self.listWidth, int(self.listHeight / itemHeight * itemHeight)))
+			self.listHeight = self.instance.size().height()
+			self.listWidth = self.instance.size().width()
+			self.itemHeight = itemHeight
+		elif self.type == EPG_TYPE_VERTICAL:
+			if self.listHeight > 0:
+				itemHeight = self.listHeight / config.epgselection.vertical_itemsperpage.value
+			else:
+				itemHeight = 90*sf
+			itemHeight = int(itemHeight)
+			self.l.setItemHeight(itemHeight)
+			self.instance.resize(eSize(self.listWidth, int(self.listHeight / itemHeight * itemHeight)))
 			self.listHeight = self.instance.size().height()
 			self.listWidth = self.instance.size().width()
 			self.itemHeight = itemHeight
@@ -555,6 +607,10 @@ class EPGList(HTMLComponent, GUIComponent):
 		elif self.type == EPG_TYPE_INFOBARGRAPH:
 			self.l.setFont(0, gFont(self.serviceFontNameInfobar, self.serviceFontSizeInfobar + config.epgselection.infobar_servfs.value))
 			self.l.setFont(1, gFont(self.eventFontNameInfobar, self.eventFontSizeInfobar + config.epgselection.infobar_eventfs.value))
+		elif self.type == EPG_TYPE_VERTICAL:
+			self.l.setFont(0, gFont(self.timeFontNameVertical, self.timeFontSizeVertical + config.epgselection.vertical_eventfs.value))
+			self.l.setFont(1, gFont(self.eventFontNameVertical, self.eventFontSizeVertical + config.epgselection.vertical_eventfs.value))
+
 
 	def postWidgetCreate(self, instance):
 		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
@@ -587,28 +643,39 @@ class EPGList(HTMLComponent, GUIComponent):
 		self.listSizeWidth = width
 		if self.type == EPG_TYPE_MULTI:
 			xpos = 0
-			w = width / 10 * 3
-			self.service_rect = Rect(xpos, 0, w-10, height)
-			xpos += w
-			w = width / 10 * 2
-			self.start_end_rect = Rect(xpos, 0, w-10, height)
-			self.progress_rect = Rect(xpos, int(height/4), w-10, int(height/2))
-			xpos += w
-			w = width / 10 * 5
-			self.descr_rect = Rect(xpos, 0, w+5, height)
+			w = self.column_service
+			self.service_rect = Rect(xpos, 0, w, height)
+			xpos += w + self.column_gap
+			w = self.column_time
+			self.start_end_rect = Rect(xpos, 0, w, height)
+			p =  w-self.progress_width
+			self.progress_rect = Rect(xpos + int(p/2), int((height-self.progress_height)/2), w-p, self.progress_height)
+			xpos += w + int(self.column_gap/2)
+			w = self.column_remaining
+			self.remaining_rect = Rect(xpos, 0, w, height)
+			xpos += w + self.column_gap
+			w = width - xpos
+			self.descr_rect = Rect(xpos, 0, w, height)
 		elif self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
 			servicew = 0
 			piconw = 0
+			channelw = 0
 			if self.type == EPG_TYPE_GRAPH:
 				if self.showServiceTitle:
 					servicew = config.epgselection.graph_servicewidth.value
 				if self.showPicon:
 					piconw = config.epgselection.graph_piconwidth.value
+				if self.showServiceNumber:
+					font = gFont(self.serviceFontNameGraph, self.serviceFontSizeGraph + config.epgselection.graph_servfs.value)
+					channelw = getTextBoundarySize(self.instance, font, self.instance.size(), "0000" ).width()
 			elif self.type == EPG_TYPE_INFOBARGRAPH:
 				if self.showServiceTitle:
 					servicew = config.epgselection.infobar_servicewidth.value
 				if self.showPicon:
 					piconw = config.epgselection.infobar_piconwidth.value
+				if self.showServiceNumber:
+					font = gFont(self.serviceFontNameGraph, self.serviceFontSizeGraph + config.epgselection.infobar_servfs.value)
+					channelw = getTextBoundarySize(self.instance, font, self.instance.size(), "0000" ).width()
 			w = (piconw + servicew)
 			self.service_rect = Rect(0, 0, w, height)
 			self.event_rect = Rect(w, 0, width - w, height)
@@ -617,6 +684,14 @@ class EPGList(HTMLComponent, GUIComponent):
 			if piconWidth > w - 2 * self.serviceBorderWidth:
 				piconWidth = w - 2 * self.serviceBorderWidth
 			self.picon_size = eSize(piconWidth, piconHeight)
+		elif self.type == EPG_TYPE_VERTICAL:
+			if self.picy > self.timeFontSizeVertical:
+				dh = self.picy
+			else:
+				dh = self.timeFontSizeVertical
+			self.line_rect = Rect(0, 0, width, int(config.epgselection.vertical_showlines.value))
+			self.datetime_rect = Rect(0, 0, width, dh)
+			self.descr_rect = Rect(0, dh, width, height-dh)
 		else:
 			self.weekday_rect = Rect(0, 0, float(width * 10) / 100, height)
 			self.datetime_rect = Rect(self.weekday_rect.width(), 0, float(width * 24) / 100, height)
@@ -687,29 +762,16 @@ class EPGList(HTMLComponent, GUIComponent):
 		]
 		if clock_types:
 			if self.wasEntryAutoTimer and clock_types in (2,7,12):
-				if self.screenwidth and self.screenwidth == 1920:
-					res.extend((
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-25, (r3.h/2-13), 25, 25, self.clocks[clock_types]),
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-50, (r3.h/2-13), 25, 25, self.autotimericon),
-						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-50, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName, foreColor, foreColorSel, backColor, backColorSel)
-						))
-				else:
-					res.extend((
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-21, (r3.h/2-11), 21, 21, self.clocks[clock_types]),
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-42, (r3.h/2-11), 21, 21, self.autotimericon),
-						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-42, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName, foreColor, foreColorSel, backColor, backColorSel)
-						))
+				res.extend((
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-self.picx - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.clocks[clock_types]),
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-self.picx*2 - self.gap - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.autotimericon),
+					(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-self.picx*2 - (self.gap*2) - self.posx, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName, foreColor, foreColorSel, backColor, backColorSel)
+					))
 			else:
-				if self.screenwidth and self.screenwidth == 1920:
-					res.extend((
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-25, (r3.h/2-13), 25, 25, self.clocks[clock_types]),
-						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-25, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName, foreColor, foreColorSel, backColor, backColorSel)
-						))
-				else:
-					res.extend((
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-21, (r3.h/2-11), 21, 21, self.clocks[clock_types]),
-						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-21, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName, foreColor, foreColorSel, backColor, backColorSel)
-						))
+				res.extend((
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-self.picx - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.clocks[clock_types]),
+					(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-self.picx - self.posx, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName, foreColor, foreColorSel, backColor, backColorSel)
+					))
 		else:
 			res.append((eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName, foreColor, foreColorSel, backColor, backColorSel))
 		return res
@@ -729,29 +791,16 @@ class EPGList(HTMLComponent, GUIComponent):
 		]
 		if clock_types:
 			if self.wasEntryAutoTimer and clock_types in (2,7,12):
-				if self.screenwidth and self.screenwidth == 1920:
-					res.extend((
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-25, (r3.h/2-13), 25, 25, self.clocks[clock_types]),
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-50, (r3.h/2-13), 25, 25, self.autotimericon),
-						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-50, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, service_name)
-					))
-				else:
-					res.extend((
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-21, (r3.h/2-11), 21, 21, self.clocks[clock_types]),
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-42, (r3.h/2-11), 21, 21, self.autotimericon),
-						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-42, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, service_name)
-					))
+				res.extend((
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-self.picx - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.clocks[clock_types]),
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-self.picx*2 - self.gap - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.autotimericon),
+					(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-self.picx*2 - (self.gap*2) - self.posx, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, service_name)
+				))
 			else:
-				if self.screenwidth and self.screenwidth == 1920:
-					res.extend((
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-25, (r3.h/2-13), 25, 25, self.clocks[clock_types]),
-						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-25, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, service_name)
-					))
-				else:
-					res.extend((
-						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-21, (r3.h/2-11), 21, 21, self.clocks[clock_types]),
-						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-21, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, service_name)
-					))
+				res.extend((
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r3.x+r3.w-self.picx - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.clocks[clock_types]),
+					(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-self.picx - (self.gap*2) - self.posx, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, service_name)
+				))
 		else:
 			res.append((eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w, r3.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, service_name))
 		return res
@@ -763,16 +812,8 @@ class EPGList(HTMLComponent, GUIComponent):
 		r2 = self.progress_rect
 		r3 = self.descr_rect
 		r4 = self.start_end_rect
-		if self.screenwidth and self.screenwidth == 1920:
-			fact1 = 120
-			fact2 = 135
-			fact3 = 30
-			borderw = 1
-		else:
-			fact1 = 80
-			fact2 = 90
-			fact3 = 20
-			borderw = 1
+		r5 = self.remaining_rect
+		borderw = self.progress_borderwidth
 		res = [None, (eListboxPythonMultiContent.TYPE_TEXT, r1.x, r1.y, r1.w, r1.h, 0, RT_HALIGN_LEFT | RT_VALIGN_CENTER, service_name)] # no private data needed
 		if beginTime is not None:
 			clock_types = self.getPixmapForEntry(service, eventId, beginTime, duration)
@@ -781,7 +822,7 @@ class EPGList(HTMLComponent, GUIComponent):
 				end = localtime(beginTime+duration)
 				res.extend((
 					(eListboxPythonMultiContent.TYPE_TEXT, r4.x, r4.y, r4.w, r4.h, 1, RT_HALIGN_CENTER|RT_VALIGN_CENTER, _("%02d:%02d - %02d:%02d")%(begin[3],begin[4],end[3],end[4])),
-					(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, fact1, r3.h, 1, RT_HALIGN_RIGHT|RT_VALIGN_CENTER, _("%d min") % (duration / 60))
+					(eListboxPythonMultiContent.TYPE_TEXT, r5.x, r5.y, r5.w, r5.h, 1, RT_HALIGN_RIGHT|RT_VALIGN_CENTER, _("%d min") % (duration / 60))
 				))
 			else:
 				percent = (nowTime - beginTime) * 100 / duration
@@ -790,40 +831,27 @@ class EPGList(HTMLComponent, GUIComponent):
 				if remaining <= 0:
 					prefix = ""
 				res.extend((
-					(eListboxPythonMultiContent.TYPE_PROGRESS, r2.x+fact3, r2.y, r2.w-fact3*2, r2.h, percent, borderw),
-					(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, fact1, r3.h, 1, RT_HALIGN_RIGHT|RT_VALIGN_CENTER, _("%s%d min") % (prefix, remaining))
+					(eListboxPythonMultiContent.TYPE_PROGRESS, r2.x, r2.y + borderw, r2.w, r2.h, percent, borderw),
+					(eListboxPythonMultiContent.TYPE_TEXT, r5.x, r5.y, r5.w, r5.h, 1, RT_HALIGN_RIGHT|RT_VALIGN_CENTER, _("%s%d min") % (prefix, remaining))
 				))
 			if clock_types:
 				pos = r3.x+r3.w
 				if self.wasEntryAutoTimer and clock_types in (2,7,12):
-					if self.screenwidth and self.screenwidth == 1920:
-						res.extend((
-							(eListboxPythonMultiContent.TYPE_TEXT, r3.x + 135, r3.y, r3.w-185, r3.h, 1, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName),
-							(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-25, (r3.h/2-13), 25, 25, self.clocks[clock_types]),
-							(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-50, (r3.h/2-13), 25, 25, self.autotimericon)
-						))
-					else:
-						res.extend((
-							(eListboxPythonMultiContent.TYPE_TEXT, r3.x + 90, r3.y, r3.w-132, r3.h, 1, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName),
-							(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-21, (r3.h/2-11), 21, 21, self.clocks[clock_types]),
-							(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-42, (r3.h/2-11), 21, 21, self.autotimericon)
-						))
+					res.extend((
+						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-self.picx*2 - (self.gap*2) - self.posx, r3.h, 1, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName),
+						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-self.picx - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.clocks[clock_types]),
+						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-self.picx*2 - self.gap - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.autotimericon)
+					))
 				else:
-					if self.screenwidth and self.screenwidth == 1920:
-						res.extend((
-							(eListboxPythonMultiContent.TYPE_TEXT, r3.x + 135, r3.y, r3.w-160, r3.h, 1, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName),
-							(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-25, (r3.h/2-13), 25, 25, self.clocks[clock_types])
-						))
-					else:
-						res.extend((
-							(eListboxPythonMultiContent.TYPE_TEXT, r3.x + 90, r3.y, r3.w-111, r3.h, 1, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName),
-							(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-21, (r3.h/2-11), 21, 21, self.clocks[clock_types])
-						))
+					res.extend((
+						(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w-self.picx - (self.gap*2) - self.posx, r3.h, 1, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName),
+						(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, pos-self.picx - self.posx, (r3.h/2-self.posy), self.picx, self.picy, self.clocks[clock_types])
+					))
 			else:
-				res.append((eListboxPythonMultiContent.TYPE_TEXT, r3.x + fact2, r3.y, r3.w-fact2, r3.h, 1, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName))
+				res.append((eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w, r3.h, 1, RT_HALIGN_LEFT|RT_VALIGN_CENTER, EventName))
 		return res
 
-	def buildGraphEntry(self, service, service_name, events, picon):
+	def buildGraphEntry(self, service, service_name, events, picon, channel):
 		if self.listSizeWidth != self.l.getItemSize().width(): #recalc size if scrollbar is shown
 			self.recalcEntrySize()
 		r1 = self.service_rect
@@ -871,7 +899,7 @@ class EPGList(HTMLComponent, GUIComponent):
 			if picon is None: # go find picon and cache its location
 				picon = getPiconName(service)
 				curIdx = self.l.getCurrentSelectionIndex()
-				self.list[curIdx] = (service, service_name, events, picon)
+				self.list[curIdx] = (service, service_name, events, picon, channel)
 			piconWidth = self.picon_size.width()
 			piconHeight = self.picon_size.height()
 			if picon != "":
@@ -887,22 +915,39 @@ class EPGList(HTMLComponent, GUIComponent):
 				namefont = 0
 				namefontflag = int(config.epgselection.graph_servicename_alignment.value)
 				namewidth = piconWidth
-				piconWidth = 0
 			else:
 				piconWidth = 0
 		else:
-			piconWidth = 10
+			piconWidth = 0
+			
+		channelWidth = 0
+		if self.showServiceNumber:
+			if not isinstance(channel, int):
+				channel = self.getChannelNumber(channel)
+			
+			if channel:
+				namefont = 0
+				namefontflag = RT_HALIGN_CENTER | RT_VALIGN_CENTER
+				font = gFont(self.serviceFontNameGraph, self.serviceFontSizeGraph + config.epgselection.graph_servfs.value)
+				channelWidth = getTextBoundarySize(self.instance, font, self.instance.size(), (channel < 10000)  and "0000" or str(channel) ).width()
+				res.append(MultiContentEntryText(
+					pos = (r1.x + self.serviceNamePadding + piconWidth + self.serviceNamePadding, r1.y + self.serviceBorderWidth),
+					size = (channelWidth, r1.h - 2 * self.serviceBorderWidth),
+					font = namefont, flags = namefontflag,
+					text = str(channel),
+					color = serviceForeColor, color_sel = serviceForeColor,
+					backcolor = serviceBackColor, backcolor_sel = serviceBackColor))
 
 		if self.showServiceTitle: # we have more space so reset parms
 			namefont = 0
 			namefontflag = int(config.epgselection.graph_servicename_alignment.value)
-			namewidth = r1.w - piconWidth
+			namewidth = r1.w - channelWidth - piconWidth
 
 		if self.showServiceTitle or displayPicon is None:
 			res.append(MultiContentEntryText(
-				pos = (r1.x + piconWidth + self.serviceBorderWidth + self.serviceNamePadding,
+				pos = (r1.x + self.serviceNamePadding + piconWidth + self.serviceNamePadding + channelWidth + self.serviceNumberPadding,
 					r1.y + self.serviceBorderWidth),
-				size = (namewidth - 2 * (self.serviceBorderWidth + self.serviceNamePadding),
+				size = (namewidth - 3 * (self.serviceBorderWidth + self.serviceNamePadding),
 					r1.h - 2 * self.serviceBorderWidth),
 				font = namefont, flags = namefontflag,
 				text = service_name,
@@ -1127,49 +1172,109 @@ class EPGList(HTMLComponent, GUIComponent):
 				if clock_types is not None and ewidth > 23:
 					if config.epgselection.graph_rec_icon_height.value != "hide":
 						if config.epgselection.graph_rec_icon_height.value == "middle":
-							RecIconHDheight = top+(height/2)-11
-							RecIconFHDheight = top+(height/2)-13
+							RecIconHeight = top+(height/2)-self.posy
 						elif config.epgselection.graph_rec_icon_height.value == "top":
-							RecIconHDheight = top+3
-							RecIconFHDheight = top+3
+							RecIconHeight = top + self.gap
 						else:
-							RecIconHDheight = top+height-22
-							RecIconFHDheight = top+height-26
+							RecIconHeight = top+height-self.picy - self.gap
 						if clock_types in (1,6,11):
-							if self.screenwidth and self.screenwidth == 1920:
-								pos = (left+xpos+ewidth-15, RecIconFHDheight)
-							else:
-								pos = (left+xpos+ewidth-13, RecIconHDheight)
+							pos = (left+xpos+ewidth-self.picx, RecIconHeight)
 						elif clock_types in (5,10,15):
-							if self.screenwidth and self.screenwidth == 1920:
-								pos = (left+xpos-26, RecIconFHDheight)
-							else:
-								pos = (left+xpos-22, RecIconHDheight)
-						else:
-							if self.screenwidth and self.screenwidth == 1920:
-								pos = (left+xpos+ewidth-26, RecIconFHDheight)
-							else:
-								pos = (left+xpos+ewidth-22, RecIconHDheight)
-						if self.screenwidth and self.screenwidth == 1920:
-							res.append(MultiContentEntryPixmapAlphaBlend(
-								pos = pos, size = (25, 25),
-								png = clocks))
+							pos = (left+xpos-self.picx - self.posx, RecIconHeight)
 						else:
-							res.append(MultiContentEntryPixmapAlphaBlend(
-								pos = pos, size = (21, 21),
-								png = clocks))
+							pos = (left+xpos+ewidth-self.picx - self.posx, RecIconHeight)
+						res.append(MultiContentEntryPixmapAlphaBlend(
+							pos = pos, size = (self.picx, self.picy),
+							png = clocks))
 						if self.wasEntryAutoTimer and clock_types in (2,7,12):
-							if self.screenwidth and self.screenwidth == 1920:
-								res.append(MultiContentEntryPixmapAlphaBlend(
-									pos = (pos[0]-25,pos[1]), size = (25, 25),
-									png = self.autotimericon))
-							else:
-								res.append(MultiContentEntryPixmapAlphaBlend(
-									pos = (pos[0]-21,pos[1]), size = (21, 21),
-									png = self.autotimericon))
+							res.append(MultiContentEntryPixmapAlphaBlend(
+								pos = (pos[0]-self.picx - self.gap,pos[1]), size = (self.picx, self.picy),
+								png = self.autotimericon))
+		return res
+
+	def buildVerticalEntry(self, service, eventId, beginTime, duration, EventName):
+		if self.listSizeWidth != self.l.getItemSize().width(): #recalc size if scrollbar is shown
+			self.recalcEntrySize()
+
+		if (beginTime is not None) and (beginTime+duration < time()):
+			foreColor = self.foreColorPast
+			backColor = self.backColorPast
+			foreColorSel = self.foreColorPastSelected
+			backColorSel = self.backColorPastSelected
+		elif (beginTime is not None) and (beginTime < time()):
+			foreColor = self.foreColorNow
+			backColor = self.backColorNow
+			foreColorSel = self.foreColorNowSelected
+			backColorSel = self.backColorNowSelected
+		else:
+			foreColor = self.foreColor
+			backColor = self.backColor
+			foreColorSel = self.foreColorSelected
+			backColorSel = self.backColorSelected
+
+		#don't apply new defaults to old skins:
+		if not self.skinUsingForeColorByTime:
+			foreColor = None
+			foreColorSel = None
+		if not self.skinUsingBackColorByTime:
+			backColor = None
+			backColorSel = None
+
+		foreColorTime = self.foreColorTime
+		foreColorPrimeTime = self.foreColorPrimeTime
+		backColorTime = self.backColorTime
+		backColorPrimeTime = self.backColorPrimeTime
+		borderColor = self.borderColor
+
+		r1=self.line_rect
+		r2=self.datetime_rect
+		r3=self.descr_rect
+
+		clock_types = self.getPixmapForEntry(service, eventId, beginTime, duration)
+
+		if beginTime is None:
+			beginTime = time()
+			duration = beginTime + 3600
+		elif duration is None:
+			duration = beginTime + 3600
+
+		t = localtime(beginTime)
+		primetime = mktime((t[0],t[1],t[2],config.epgselection.vertical_primetimehour.value,config.epgselection.vertical_primetimemins.value,0,t[6],t[7],t[8]))
+		pt = (primetime >= beginTime and primetime < beginTime+duration)
+		if pt:
+			foreColor = foreColorPrimeTime
+			backColor = backColorPrimeTime
+		res = [
+			None,
+			(eListboxPythonMultiContent.TYPE_TEXT, r3.x, r3.y, r3.w, r3.h, 0, RT_HALIGN_LEFT, ' ', foreColor, foreColorSel, backColor, backColorSel),			#//background event
+			(eListboxPythonMultiContent.TYPE_TEXT, r2.x, r2.y, r2.w, r2.h, 0, RT_HALIGN_LEFT, ' ', foreColorTime, foreColorSel, backColorTime, backColorSel),	#//background time
+			]
+		if pt:
+			res.extend((
+				(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r2.x+self.posx, r2.h/2-self.posy, self.picx, self.picy, self.primetimeicon),
+				(eListboxPythonMultiContent.TYPE_TEXT, r2.x+self.posx*3+self.picx, r2.y, r2.w-(self.posx*3+self.picx), r2.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, ("%02d.%02d"%(t[2],t[1]) + " " + self.days[t[6]]) + " " + ("%02d:%02d"%(t[3],t[4])), foreColorTime, foreColorSel, backColorTime, backColorSel),
+			))
+		else:
+			res.extend((
+				(eListboxPythonMultiContent.TYPE_TEXT, r2.x+self.posx, r2.y, r2.w-self.posx, r2.h, 0, RT_HALIGN_LEFT|RT_VALIGN_CENTER, ("%02d.%02d"%(t[2],t[1]) + " " + self.days[t[6]]) + " " + ("%02d:%02d"%(t[3],t[4])), foreColorTime, foreColorSel, backColorTime, backColorSel),
+			))
+		if clock_types:
+			if self.wasEntryAutoTimer and clock_types in (2,7,12):
+				res.extend((
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r2.w-self.picx*2-self.posx*2, r2.h/2-self.posy, self.picx, self.picy, self.autotimericon),
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r2.w-self.picx-self.posx, r2.h/2-self.posy, self.picx, self.picy, self.clocks[clock_types]),
+				))
+			else:
+				res.extend((
+					(eListboxPythonMultiContent.TYPE_PIXMAP_ALPHABLEND, r2.w-self.picx-self.posx, r2.h/2-self.posy, self.picx, self.picy, self.clocks[clock_types]),
+				))
+		res.extend((
+				(eListboxPythonMultiContent.TYPE_TEXT, r1.x, r1.y, r1.w, r1.h, 0, RT_HALIGN_LEFT, ' ', foreColor, foreColorSel, borderColor, borderColor),		#//parting line
+				(eListboxPythonMultiContent.TYPE_TEXT, r3.x+self.posx, r3.y, r3.w-self.posx, r3.h, 1, RT_HALIGN_LEFT|RT_WRAP, EventName, foreColor, foreColorSel, backColor, backColorSel)
+				))
 		return res
 
-	def getSelectionPosition(self,serviceref):
+	def getSelectionPosition(self,serviceref, activeList = 1):
 		if self.type == EPG_TYPE_GRAPH:
 			indx = int(self.getIndexFromService(serviceref))
 			selx = self.select_rect.x+self.select_rect.w
@@ -1195,6 +1300,11 @@ class EPGList(HTMLComponent, GUIComponent):
 			selx = self.listWidth
 			while indx+1 > config.epgselection.infobar_itemsperpage.value:
 				indx = indx - config.epgselection.infobar_itemsperpage.value
+		elif self.type == EPG_TYPE_VERTICAL:
+			indx = int(self.l.getCurrentSelectionIndex())
+			selx = self.listWidth * activeList
+			while indx+1 > config.epgselection.vertical_itemsperpage.value:
+				indx = indx - config.epgselection.vertical_itemsperpage.value
 		pos = self.instance.position().y()
 		sely = int(pos)+(int(self.itemHeight)*int(indx))
 		temp = int(self.instance.position().y())+int(self.listHeight)
@@ -1238,22 +1348,31 @@ class EPGList(HTMLComponent, GUIComponent):
 					self.offs -= 1
 					self.fillGraphEPG(None) # refill
 					return True
+				elif self.time_base > time():
+					self.time_base -= self.time_epoch * 60
+					self.fillGraphEPG(None) # refill
+					return True
 			elif dir == +24:
 				self.time_base += 86400
 				self.fillGraphEPG(None, self.time_base) # refill
 				return True
 			elif dir == -24:
 				now = time() - int(config.epg.histminutes.value) * 60
+				roundto = None
 				if self.type == EPG_TYPE_GRAPH:
-					if (self.time_base - 86400) >= now - now % (int(config.epgselection.graph_roundto.value) * 60):
-						self.time_base -= 86400
-						self.fillGraphEPG(None, self.time_base) # refill
-						return True
+					roundto = config.epgselection.graph_roundto
 				elif self.type == EPG_TYPE_INFOBARGRAPH:
-					if (self.time_base - 86400) >= now - now % (int(config.epgselection.infobar_roundto.value) * 60):
+					roundto = config.epgselection.infobar_roundto
+				if roundto is not None:
+					if (self.time_base - 86400) > now - now % (int(roundto.value) * 60):
 						self.time_base -= 86400
-						self.fillGraphEPG(None, self.time_base) # refill
-						return True
+						getnow = False
+					else:
+						self.offs = 0
+						self.time_base = now - now % (int(roundto.value) * 60)
+						getnow = True
+					self.fillGraphEPG(None, self.time_base, getnow) # refill
+					return True
 
 		if cur_service and valid_event and (self.cur_event+1 <= len(entries)):
 			entry = entries[self.cur_event] #(event_id, event_title, begin_time, duration)
@@ -1286,9 +1405,12 @@ class EPGList(HTMLComponent, GUIComponent):
 		self.l.setList(self.list)
 		self.selectionChanged()
 
-	def fillSingleEPG(self, service):
-		t = time()
-		epg_time = t - config.epg.histminutes.value*60
+	def fillSingleEPG(self, service, stime = None):
+		if stime is not None:
+			t = epg_time = int(stime)
+		else:
+			t = time()
+			epg_time = t - config.epg.histminutes.value*60
 		test = [ 'RIBDT', (service.ref.toString(), 0, epg_time, -1) ]
 		self.list = self.queryEPG(test)
 		self.l.setList(self.list)
@@ -1299,6 +1421,8 @@ class EPGList(HTMLComponent, GUIComponent):
 				if t < x[2]+x[3]:
 					break
 			self.instance.moveSelectionTo(idx-1)
+		else:
+			self.instance.moveSelectionTo(0)
 		self.selectionChanged()
 
 	def fillMultiEPG(self, services, stime=None):
@@ -1322,7 +1446,7 @@ class EPGList(HTMLComponent, GUIComponent):
 		self.l.setList(self.list)
 		self.selectionChanged()
 
-	def fillGraphEPG(self, services, stime = None):
+	def fillGraphEPG(self, services, stime = None, getnow = False):
 		if (self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH) and not self.graphicsloaded:
 			if self.graphic:
 				self.nowEvPix = loadPNG(resolveFilename(SCOPE_ACTIVE_SKIN, 'epg/CurrentEvent.png'))
@@ -1355,15 +1479,21 @@ class EPGList(HTMLComponent, GUIComponent):
 			self.time_base = int(stime)
 		if services is None:
 			time_base = self.time_base + self.offs * self.time_epoch * 60
+			#// set new time base without offset
+			self.time_base = time_base
+			self.offs = 0
+			#//
 			test = [ (service[0], 0, time_base, self.time_epoch) for service in self.list ]
 			serviceList = self.list
 			piconIdx = 3
+			channelIdx = 4
 		else:
 			self.cur_event = None
 			self.cur_service = None
 			test = [ (service.ref.toString(), 0, self.time_base, self.time_epoch) for service in services ]
 			serviceList = services
 			piconIdx = 0
+			channelIdx = None
 
 		test.insert(0, 'XRnITBD') #return record, service ref, service name, event id, event title, begin time, duration
 		epg_data = self.queryEPG(test)
@@ -1377,7 +1507,8 @@ class EPGList(HTMLComponent, GUIComponent):
 			if service != x[0]:
 				if tmp_list is not None:
 					picon = None if piconIdx == 0 else serviceList[serviceIdx][piconIdx]
-					self.list.append((service, sname, tmp_list[0][0] is not None and tmp_list or None, picon))
+					channel = serviceList[serviceIdx] if (channelIdx == None) else serviceList[serviceIdx][channelIdx]
+					self.list.append((service, sname, tmp_list[0][0] is not None and tmp_list or None, picon, channel))
 					serviceIdx += 1
 				service = x[0]
 				sname = x[1]
@@ -1385,11 +1516,12 @@ class EPGList(HTMLComponent, GUIComponent):
 			tmp_list.append((x[2], x[3], x[4], x[5])) #(event_id, event_title, begin_time, duration)
 		if tmp_list and len(tmp_list):
 			picon = None if piconIdx == 0 else serviceList[serviceIdx][piconIdx]
-			self.list.append((service, sname, tmp_list[0][0] is not None and tmp_list or None, picon))
+			channel = serviceList[serviceIdx] if (channelIdx == None) else serviceList[serviceIdx][channelIdx]
+			self.list.append((service, sname, tmp_list[0][0] is not None and tmp_list or None, picon, channel))
 			serviceIdx += 1
 
 		self.l.setList(self.list)
-		self.findBestEvent()
+		self.findBestEvent(getnow)
 
 	def sortSingleEPG(self, type):
 		list = self.list
@@ -1403,6 +1535,14 @@ class EPGList(HTMLComponent, GUIComponent):
 			self.l.invalidate()
 			self.moveToEventId(event_id)
 
+	def getChannelNumber(self,service):
+		if hasattr(service, "ref") and service.ref and '0:0:0:0:0:0:0:0:0' not in service.ref.toString():
+			numservice = service.ref
+			num = numservice and numservice.getChannelNum() or None
+			if num is not None:
+				return num
+		return None
+
 	def getEventRect(self):
 		rc = self.event_rect
 		if rc:
@@ -1456,11 +1596,7 @@ class TimelineText(HTMLComponent, GUIComponent):
 		self.time_base = 0
 		self.time_epoch = 0
 		self.timelineFontName = "Regular"
-		self.screenwidth = getDesktop(0).size().width()
-		if self.screenwidth and self.screenwidth == 1920:
-			self.timelineFontSize = 30
-		else:
-			self.timelineFontSize = 20
+		self.timelineFontSize = int(20 * sf)
 		self.timelineAlign = 'left'
 		self.datefmt = ""
 
@@ -1517,9 +1653,9 @@ class TimelineText(HTMLComponent, GUIComponent):
 		time_base = l.getTimeBase()
 
 		if self.timelineAlign.lower() == 'right':
-			alignnment = RT_HALIGN_RIGHT | RT_VALIGN_TOP
+			alignnment = RT_HALIGN_RIGHT | RT_VALIGN_CENTER
 		else:
-			alignnment = RT_HALIGN_LEFT | RT_VALIGN_TOP
+			alignnment = RT_HALIGN_LEFT | RT_VALIGN_CENTER
 
 		if event_rect is None or time_epoch is None or time_base is None:
 			return
@@ -1613,7 +1749,7 @@ class TimelineText(HTMLComponent, GUIComponent):
 				res.append(MultiContentEntryText(
 					pos = (service_rect.width() + xpos, 0),
 					size = (incWidth, self.listHeight),
-					font = 0, flags = RT_HALIGN_LEFT | RT_VALIGN_TOP,
+					font = 0, flags = RT_HALIGN_LEFT | RT_VALIGN_CENTER,
 					text = timetext,
 					color = foreColor,
 					backcolor = backColor))
@@ -1661,11 +1797,7 @@ class EPGBouquetList(HTMLComponent, GUIComponent):
 		self.graphicsloaded = False
 
 		self.bouquetFontName = "Regular"
-		self.screenwidth = getDesktop(0).size().width()
-		if self.screenwidth and self.screenwidth == 1920:
-			self.bouquetFontSize = 30
-		else:
-			self.bouquetFontSize = 20
+		self.bouquetFontSize = int(20 * sf)
 
 		self.itemHeight = 31
 		self.listHeight = None
diff --git a/lib/python/Components/GUIComponent.py b/lib/python/Components/GUIComponent.py
index b3ac3d4..92fe2ca 100644
--- a/lib/python/Components/GUIComponent.py
+++ b/lib/python/Components/GUIComponent.py
@@ -1,6 +1,7 @@
 import skin
 
 from enigma import ePoint, eSize
+from Components.config import config
 
 class GUIComponent(object):
 	""" GUI component """
@@ -36,6 +37,14 @@ class GUIComponent(object):
 		if self.skinAttributes is None:
 			return False
 
+		#//workaround for values from attributes the not be set
+		#
+		#The order of some attributes is crucial if they are applied. Also, an attribute may be responsible that another does not take effect and occurs at different skins.
+		#It was noticed at 'scrollbarSliderBorderWidth' and 'scrollbarSliderForegroundColor'.
+		#
+		if config.skin.primary_skin.value.split('/')[0] not in ('DMConcinnity-HD'):
+			self.skinAttributes.sort()
+		#//
 		skin.applyAllAttributes(self.instance, desktop, self.skinAttributes, parent.scale)
 		return True
 
diff --git a/lib/python/Components/Harddisk.py b/lib/python/Components/Harddisk.py
index d1d17b5..0e197c8 100644
--- a/lib/python/Components/Harddisk.py
+++ b/lib/python/Components/Harddisk.py
@@ -756,12 +756,10 @@ class HarddiskManager:
 		error = False
 		removable = False
 		BLACKLIST=[]
-		if getMachineBuild() in ('vuzero4k','et1x000','vuuno4k','vuuno4kse','vuultimo4k','vusolo4k','hd51','hd52','sf4008','dm900','dm7080','dm820', 'gb7252', 'dags7252', 'vs1500','h7','8100s','et13000','sf5008'):
+		if getMachineBuild() in ('h9combo','v8plus','hd60','vuduo4k','ustym4kpro','dags72604','u51','u52','u53','u54','u5','u5pvr','cc1','sf8008','sf8008s','vuzero4k','et1x000','vuuno4k','vuuno4kse','vuultimo4k','vusolo4k','hd51','hd52','sf4008','dm900','dm7080','dm820', 'gb7252', 'dags7252', 'vs1500','h7','8100s','et13000','sf5008'):
 			BLACKLIST=["mmcblk0"]
-		elif getMachineBuild() in ('xc7439'):
+		elif getMachineBuild() in ('xc7439','osmio4k'):
 			BLACKLIST=["mmcblk1"]
-		elif getMachineBuild() in ('u5','u5pvr'):
-			BLACKLIST=["mmcblk0", "mmcblk1"]
 
 		blacklisted = False
 		if blockdev[:7] in BLACKLIST:
diff --git a/lib/python/Components/HdmiCec.py b/lib/python/Components/HdmiCec.py
index 462afec..7165a6d 100644
--- a/lib/python/Components/HdmiCec.py
+++ b/lib/python/Components/HdmiCec.py
@@ -3,26 +3,31 @@ import os
 from fcntl import ioctl
 from sys import maxint
 from enigma import eTimer, eHdmiCEC, eActionMap
-from config import config, ConfigSelection, ConfigYesNo, ConfigSubsection, ConfigText, NoSave, ConfigInteger
+from config import config, ConfigSelection, ConfigYesNo, ConfigSubsection, ConfigText
 from Components.Console import Console
-from Tools.StbHardware import getFPWasTimerWakeup
 from Tools.Directories import fileExists
-
+from time import time
+import Screens.Standby
 
 config.hdmicec = ConfigSubsection()
-config.hdmicec.enabled = ConfigYesNo(default = False)
+config.hdmicec.enabled = ConfigYesNo(default = False) # query from this value in hdmi_cec.cpp
 config.hdmicec.control_tv_standby = ConfigYesNo(default = True)
-config.hdmicec.control_tv_standby_skipnow = ConfigYesNo(default = False)
-config.hdmicec.TVoffCounter = NoSave(ConfigInteger(default = 0))
 config.hdmicec.control_tv_wakeup = ConfigYesNo(default = True)
 config.hdmicec.report_active_source = ConfigYesNo(default = True)
-config.hdmicec.report_active_menu = ConfigYesNo(default = True)
-config.hdmicec.handle_tv_standby = ConfigYesNo(default = True)
-config.hdmicec.handle_tv_wakeup = ConfigYesNo(default = True)
-config.hdmicec.tv_wakeup_detection = ConfigSelection(
+config.hdmicec.report_active_menu = ConfigYesNo(default = True) # query from this value in hdmi_cec.cpp
+choicelist = [
+	("disabled", _("Disabled")),
+	("standby", _("Standby")),
+	("deepstandby", _("Deep standby")),
+	]
+config.hdmicec.handle_tv_standby = ConfigSelection(default = "standby", choices = choicelist)
+config.hdmicec.handle_tv_input = ConfigSelection(default = "disabled", choices = choicelist)
+config.hdmicec.handle_tv_wakeup = ConfigSelection(
 	choices = {
+	"disabled": _("Disabled"),
 	"wakeup": _("Wakeup"),
 	"tvreportphysicaladdress": _("TV physical address report"),
+	"routingrequest": _("Routing request"),
 	"sourcerequest": _("Source request"),
 	"streamrequest": _("Stream request"),
 	"osdnamerequest": _("OSD name request"),
@@ -34,11 +39,36 @@ config.hdmicec.volume_forwarding = ConfigYesNo(default = False)
 config.hdmicec.control_receiver_wakeup = ConfigYesNo(default = False)
 config.hdmicec.control_receiver_standby = ConfigYesNo(default = False)
 config.hdmicec.handle_deepstandby_events = ConfigYesNo(default = False)
-config.hdmicec.preemphasis = ConfigYesNo(default = False)	
+config.hdmicec.preemphasis = ConfigYesNo(default = False)
 choicelist = []
-for i in (10, 50, 100, 150, 250, 500, 750, 1000, 1500, 2000):
+for i in (10, 50, 100, 150, 250, 500, 750, 1000, 1500, 2000, 3000):
 	choicelist.append(("%d" % i, "%d ms" % i))
 config.hdmicec.minimum_send_interval = ConfigSelection(default = "0", choices = [("0", _("Disabled"))] + choicelist)
+choicelist = []
+for i in range(1,4):
+	choicelist.append(("%d" % i, _("%d times") % i))
+config.hdmicec.messages_repeat = ConfigSelection(default = "0", choices = [("0", _("Disabled"))] + choicelist)
+config.hdmicec.messages_repeat_standby = ConfigYesNo(default = False)
+choicelist = []
+for i in (10, 50, 100, 150, 250, 500, 750, 1000):
+	choicelist.append(("%d" % i, "%d ms" % i))
+config.hdmicec.messages_repeat_slowdown = ConfigSelection(default = "250", choices = [("0", _("None"))] + choicelist)
+choicelist = []
+for i in (10,30,60,120,300,600,900,1800,3600):
+	if i/60<1:
+		choicelist.append(("%d" % i, _("%d sec") % i))
+	else:
+		choicelist.append(("%d" % i, _("%d min") % (i/60)))
+config.hdmicec.handle_tv_delaytime = ConfigSelection(default = "0", choices = [("0", _("None"))] + choicelist)
+config.hdmicec.deepstandby_waitfortimesync = ConfigYesNo(default = True)
+config.hdmicec.tv_wakeup_zaptimer = ConfigYesNo(default = True)
+config.hdmicec.tv_wakeup_zapandrecordtimer = ConfigYesNo(default = True)
+config.hdmicec.tv_wakeup_wakeuppowertimer = ConfigYesNo(default = True)
+config.hdmicec.tv_standby_notinputactive = ConfigYesNo(default = True)
+config.hdmicec.check_tv_state = ConfigYesNo(default = False)
+config.hdmicec.workaround_activesource = ConfigYesNo(default = False)
+
+#nice cec info site: http://www.cec-o-matic.com/
 
 class HdmiCec:
 	instance = None
@@ -51,24 +81,42 @@ class HdmiCec:
 			self.wait = eTimer()
 			self.wait.timeout.get().append(self.sendCmd)
 			self.queue = []
+			self.messages = []
+
+			self.handleTimer = eTimer()
+			self.stateTimer = eTimer()
+			self.stateTimer.callback.append(self.stateTimeout)
+			self.repeatTimer = eTimer()
+			self.repeatTimer.callback.append(self.repeatMessages)
+			self.repeatCounter = 0
+			self.messageCounter = 0
+			self.what = ''
+			self.tv_lastrequest = ''
+			self.tv_powerstate = 'unknown'
+			self.tv_skip_messages = False
+			self.activesource = False
+			self.firstrun = True
+
+			self.sethdmipreemphasis()
+			self.checkifPowerupWithoutWakingTv() # initially write 'False' to file, see below
 
 			eHdmiCEC.getInstance().messageReceived.get().append(self.messageReceived)
 			config.misc.standbyCounter.addNotifier(self.onEnterStandby, initial_call = False)
-			config.hdmicec.TVoffCounter.addNotifier(self.TVoff, initial_call = False)
 			config.misc.DeepStandby.addNotifier(self.onEnterDeepStandby, initial_call = False)
 			self.setFixedPhysicalAddress(config.hdmicec.fixed_physical_address.value)
 
 			self.volumeForwardingEnabled = False
 			self.volumeForwardingDestination = 0
 			eActionMap.getInstance().bindAction('', -maxint - 1, self.keyEvent)
-			config.hdmicec.volume_forwarding.addNotifier(self.configVolumeForwarding)
+			config.hdmicec.volume_forwarding.addNotifier(self.configVolumeForwarding, initial_call = False)
 			config.hdmicec.enabled.addNotifier(self.configVolumeForwarding)
-			if config.hdmicec.handle_deepstandby_events.value:
-				if not getFPWasTimerWakeup():
-					self.wakeupMessages()
-			dummy = self.checkifPowerupWithoutWakingTv() # initially write 'False' to file, see below
-#			if fileExists("/proc/stb/hdmi/preemphasis"):		
-#				self.sethdmipreemphasis()
+
+			config.hdmicec.report_active_menu.addNotifier(self.configReportActiveMenu, initial_call = False)
+			config.hdmicec.check_tv_state.addNotifier(self.configTVstate, initial_call = False)
+			config.hdmicec.tv_standby_notinputactive.addNotifier(self.configTVstate, initial_call = False)
+			config.hdmicec.control_tv_standby.addNotifier(self.configTVstate, initial_call = False)
+
+			self.checkTVstate('firstrun')
 
 	def getPhysicalAddress(self):
 		physicaladdress = eHdmiCEC.getInstance().getPhysicalAddress()
@@ -82,6 +130,133 @@ class HdmiCec:
 		hexstring = address[0] + address[2] + address[4] + address[6]
 		eHdmiCEC.getInstance().setFixedPhysicalAddress(int(float.fromhex(hexstring)))
 
+	def messageReceived(self, message):
+		if config.hdmicec.enabled.value:
+			checkstate = self.stateTimer.isActive()
+			data = 16 * '\x00'
+			cmd = message.getCommand()
+			length = message.getData(data, len(data))
+			address = message.getAddress()
+			#print '[HdmiCec] messageReceived from address: %s (0x%02x)' %(address, address)
+
+			#// workaround for wrong address vom driver (e.g. hd51, message comes from tv -> address is only sometimes 0, dm920, same tv -> address is always 0)
+			if cmd != 0x8f or address == 0:
+				self.messageCounter = 0
+			elif cmd == 0x8f:
+				self.messageCounter += 1
+				if self.messageCounter > 3:
+					self.messageCounter = 0
+					address = 0
+			#//
+
+			if cmd == 0x00: # feature abort
+				if data[0] == '\x44':
+					print 'eHdmiCec: volume forwarding not supported by device %02x'%(address)
+					self.volumeForwardingEnabled = False
+			elif cmd == 0x46: # request name
+				self.sendMessage(address, 'osdname')
+			elif cmd in (0x7e, 0x72): # system audio mode status
+				if data[0] == '\x01':
+					self.volumeForwardingDestination = 5 # on: send volume keys to receiver
+				else:
+					self.volumeForwardingDestination = 0 # off: send volume keys to tv
+				if config.hdmicec.volume_forwarding.value:
+					print 'eHdmiCec: volume forwarding to device %02x enabled'% self.volumeForwardingDestination
+					self.volumeForwardingEnabled = True
+			elif cmd == 0x8f: # request power status
+				if Screens.Standby.inStandby:
+					self.sendMessage(address, 'powerinactive')
+				else:
+					self.sendMessage(address, 'poweractive')
+			elif cmd == 0x83: # request address
+				self.sendMessage(address, 'reportaddress')
+			elif cmd == 0x85: # request active source
+				if not Screens.Standby.inStandby and config.hdmicec.report_active_source.value:
+					self.sendMessage(address, 'sourceactive')
+			elif cmd == 0x8c: # request vendor id
+				self.sendMessage(address, 'vendorid')
+			elif cmd == 0x8d: # menu request
+				requesttype = ord(data[0])
+				if requesttype == 2: # query
+					if Screens.Standby.inStandby:
+						self.sendMessage(address, 'menuinactive')
+					else:
+						self.sendMessage(address, 'menuactive')
+			elif cmd == 0x90: # report power state
+				if data[0] == '\x00':
+					self.tv_powerstate = "on"
+				elif data[0] == '\x01':
+					self.tv_powerstate = "standby"
+				elif data[0] == '\x02':
+					self.tv_powerstate = "get_on"
+				elif data[0] == '\x03':
+					self.tv_powerstate = "get_standby"
+				if checkstate and not self.firstrun:
+					self.checkTVstate('powerstate')
+				elif self.firstrun and not config.hdmicec.handle_deepstandby_events.value:
+					self.firstrun = False
+				else:
+					self.checkTVstate()
+			elif cmd == 0x36: # handle standby request from the tv
+				if config.hdmicec.handle_tv_standby.value != 'disabled':
+					self.handleTVRequest('tvstandby')
+				self.checkTVstate('tvstandby')
+			elif cmd == 0x80: # routing changed
+				oldaddress = ord(data[0]) * 256 + ord(data[1])
+				newaddress = ord(data[2]) * 256 + ord(data[3])
+				ouraddress = eHdmiCEC.getInstance().getPhysicalAddress()
+				active = (newaddress == ouraddress)
+				hexstring = '%04x' % oldaddress
+				oldaddress = hexstring[0] + '.' + hexstring[1] + '.' + hexstring[2] + '.' + hexstring[3]
+				hexstring = '%04x' % newaddress
+				newaddress = hexstring[0] + '.' + hexstring[1] + '.' + hexstring[2] + '.' + hexstring[3]
+				print "[HdmiCec] routing has changed... from '%s' to '%s' (to our address: %s)" %(oldaddress, newaddress, active)
+			elif cmd in (0x86, 0x82): # set streaming path, active source changed
+				newaddress = ord(data[0]) * 256 + ord(data[1])
+				ouraddress = eHdmiCEC.getInstance().getPhysicalAddress()
+				active = (newaddress == ouraddress)
+				if checkstate or self.activesource != active:
+					if checkstate:
+						txt = 'our receiver is active source'
+					else:
+						txt = 'active source'
+						if cmd == 0x86: txt = 'streaming path'
+						txt += ' has changed... to our address'
+					print '[HdmiCec] %s: %s' %(txt, active)
+				self.activesource = active
+				if not checkstate:
+					if cmd == 0x86 and not Screens.Standby.inStandby and self.activesource:
+						self.sendMessage(address, 'sourceactive')
+						if config.hdmicec.report_active_menu.value:
+							self.sendMessage(0, 'menuactive')
+					if config.hdmicec.handle_tv_input.value != 'disabled':
+						self.handleTVRequest('activesource')
+					self.checkTVstate('changesource')
+				else:
+					self.checkTVstate('activesource')
+
+			# handle wakeup requests from the tv
+			if cmd == 0x44 and data[0] in ('\x40', '\x6D'): # handle wakeup from tv hdmi-cec menu (e.g. panasonic tv apps, viera link)
+				self.wakeup()
+			elif not checkstate and config.hdmicec.handle_tv_wakeup.value != 'disabled':
+				if cmd == 0x04 and config.hdmicec.handle_tv_wakeup.value == "wakeup":
+					self.wakeup()
+				elif cmd == 0x80 and config.hdmicec.handle_tv_wakeup.value == "routingrequest":
+					if active:
+						self.wakeup()
+				elif cmd == 0x84 and config.hdmicec.handle_tv_wakeup.value == "tvreportphysicaladdress":
+					if (ord(data[0]) * 256 + ord(data[1])) == 0 and ord(data[2]) == 0:
+						self.wakeup()
+				elif cmd == 0x85 and config.hdmicec.handle_tv_wakeup.value == "sourcerequest":
+					self.wakeup()
+				elif cmd == 0x86 and config.hdmicec.handle_tv_wakeup.value == "streamrequest":
+					if active:
+						self.wakeup()
+				elif cmd == 0x46 and config.hdmicec.handle_tv_wakeup.value == "osdnamerequest":
+					self.wakeup()
+				elif cmd != 0x36 and config.hdmicec.handle_tv_wakeup.value == "activity":
+					self.wakeup()
+
 	def sendMessage(self, address, message):
 		if config.hdmicec.enabled.value:
 			cmd = 0
@@ -89,10 +264,15 @@ class HdmiCec:
 			if message == "wakeup":
 				cmd = 0x04
 			elif message == "sourceactive":
-				address = 0x0f # use broadcast for active source command
+				address = 0x0f # use broadcast address
 				cmd = 0x82
 				physicaladdress = eHdmiCEC.getInstance().getPhysicalAddress()
 				data = str(struct.pack('BB', int(physicaladdress/256), int(physicaladdress%256)))
+			elif message == "routinginfo":
+				address = 0x0f # use broadcast address
+				cmd = 0x81
+				physicaladdress = eHdmiCEC.getInstance().getPhysicalAddress()
+				data = str(struct.pack('BB', int(physicaladdress/256), int(physicaladdress%256)))
 			elif message == "standby":
 				cmd = 0x36
 			elif message == "sourceinactive":
@@ -107,12 +287,16 @@ class HdmiCec:
 				data = str(struct.pack('B', 0x01))
 			elif message == "givesystemaudiostatus":
 				cmd = 0x7d
-				address = 0x05
 			elif message == "setsystemaudiomode":
 				cmd = 0x70
-				address = 0x05
 				physicaladdress = eHdmiCEC.getInstance().getPhysicalAddress()
 				data = str(struct.pack('BB', int(physicaladdress/256), int(physicaladdress%256)))
+			elif message == "activatesystemaudiomode":
+				cmd = 0x72
+				data = str(struct.pack('B', 0x01))
+			elif message == "deactivatesystemaudiomode":
+				cmd = 0x72
+				data = str(struct.pack('B', 0x00))
 			elif message == "osdname":
 				cmd = 0x47
 				data = os.uname()[1]
@@ -138,11 +322,14 @@ class HdmiCec:
 			elif message == "keypoweroff":
 				cmd = 0x44
 				data = str(struct.pack('B', 0x6c))
+			elif message == "powerstate":
+				cmd = 0x8f
 			if cmd:
-				if config.hdmicec.minimum_send_interval.value != "0" and message != "standby": # Use no interval time when message is standby. usefull for Panasonic TV
+				sendSlower = self.sendSlower()
+				if int(config.hdmicec.minimum_send_interval.value) + sendSlower != 0 and (message != "standby" or (config.hdmicec.workaround_activesource.value and self.what == 'on')): # Use no interval time when message is standby. usefull for Panasonic TV
 					self.queue.append((address, cmd, data))
 					if not self.wait.isActive():
-						self.wait.start(int(config.hdmicec.minimum_send_interval.value), True)
+						self.wait.start(int(config.hdmicec.minimum_send_interval.value) + sendSlower, True)
 				else:
 					eHdmiCEC.getInstance().sendMessage(address, cmd, data, len(data))
 
@@ -150,204 +337,329 @@ class HdmiCec:
 		if len(self.queue):
 			(address, cmd, data) = self.queue.pop(0)
 			eHdmiCEC.getInstance().sendMessage(address, cmd, data, len(data))
-			self.wait.start(int(config.hdmicec.minimum_send_interval.value), True)
+			self.wait.start(int(config.hdmicec.minimum_send_interval.value) + self.sendSlower(), True)
 
-	def sendMessages(self, address, messages):
-		for message in messages:
+	def sendMessages(self, messages):
+		self.firstrun = False
+		self.queue = []
+		self.sendMessagesIsActive(True)
+		sendCnt = 0
+		for send in messages:
+			address = send[0]
+			message = send[1]
+			if self.what == 'on' and ((self.repeatCounter > 0 or self.activesource) and (message == 'standby' or (message == 'wakeup' and not config.hdmicec.control_tv_wakeup.value))): # skip active source workaround messages
+				continue
 			self.sendMessage(address, message)
+			sendCnt += 1
+		if sendCnt:
+			self.repeatTimer.start((int(config.hdmicec.minimum_send_interval.value)+self.sendSlower())*len(messages)+1000, True)
+
+	def repeatMessages(self):
+		if len(self.queue):
+			self.repeatTimer.start(1000, True)
+		elif self.firstrun:
+			if self.stateTimer.isActive():
+				self.repeatTimer.start(1000, True)
+			else:
+				self.sendMessages(self.messages)
+		elif self.repeatCounter < int(config.hdmicec.messages_repeat.value) and (self.what == 'on' or (config.hdmicec.messages_repeat_standby.value and self.what == 'standby')):
+			self.repeatCounter += 1
+			self.sendMessages(self.messages)
+		else:
+			self.repeatCounter = 0
+			self.checkTVstate(self.what)
+
+	def sendSlower(self):
+		return int(config.hdmicec.messages_repeat_slowdown.value) * self.repeatCounter
 
 	def wakeupMessages(self):
-		if self.checkifPowerupWithoutWakingTv() == 'True':
+		self.handleTimerStop()
+		if self.tv_skip_messages:
+			self.tv_skip_messages = False
+			print "[HdmiCec] Skip turning on TV"
+		elif self.checkifPowerupWithoutWakingTv() == 'True':
 			print "[HdmiCec] Skip waking TV, found 'True' in '/tmp/powerup_without_waking_tv.txt' (usually written by openWebif)"
 		else:
 			if config.hdmicec.enabled.value:
-				messages = []
+				self.messages = []
+				self.what = 'on'
+				self.repeatCounter = 0
+				if config.hdmicec.workaround_activesource.value and config.hdmicec.report_active_source.value and not self.activesource and not 'standby' in self.tv_powerstate:
+					#// some tv devices switched not to correct hdmi port if a another hdmi port active - the workaround switch the tv off and on
+					self.messages.append((0, "standby"))
+					if not config.hdmicec.control_tv_wakeup.value:
+						self.messages.append((0, "wakeup"))
+					#//
 				if config.hdmicec.control_tv_wakeup.value:
-					messages.append("wakeup")
+					self.messages.append((0, "wakeup"))
 				if config.hdmicec.report_active_source.value:
-					messages.append("sourceactive")
+					self.messages.append((0, "sourceactive"))
 				if config.hdmicec.report_active_menu.value:
-					messages.append("menuactive")
-				if messages:
-					self.sendMessages(0, messages)
+					if not config.hdmicec.report_active_source.value and self.activesource:
+						self.messages.append((0, "sourceactive"))
+					self.messages.append((0, "menuactive"))
 
 				if config.hdmicec.control_receiver_wakeup.value:
-					self.sendMessage(5, "keypoweron")
-					self.sendMessage(5, "setsystemaudiomode")
+					self.messages.append((5, "keypoweron"))
+					self.messages.append((5, "setsystemaudiomode"))
+
+				if self.firstrun: # wait for tv state and another messages on first start
+					self.repeatTimer.start(1000, True)
+				else:
+					self.sendMessages(self.messages)
+
 			if os.path.exists("/usr/script/TvOn.sh"):
 				Console().ePopen("/usr/script/TvOn.sh &")
 
 	def standbyMessages(self):
-		if config.hdmicec.control_tv_standby_skipnow.value:
-			print "[HdmiCec] Skip turning off TV (action standby_skipTVshutdown)"
-		else:
+		self.handleTimerStop()
+		if self.tv_skip_messages:
+			self.tv_skip_messages = False
+			print "[HdmiCec] Skip turning off TV"
+		elif config.hdmicec.control_tv_standby.value and not config.hdmicec.tv_standby_notinputactive.value and not self.sendMessagesIsActive() and not self.activesource and 'on' in self.tv_powerstate:
+			print "[HdmiCec] Skip turning off TV - config: tv has another input active"
+		else: 
 			if config.hdmicec.enabled.value:
-				messages = []
+				self.messages = []
+				self.what = 'standby'
+				self.repeatCounter = 0
 				if config.hdmicec.control_tv_standby.value:
-					messages.append("standby")
+					self.messages.append((0, "standby"))
 				else:
 					if config.hdmicec.report_active_source.value:
-						messages.append("sourceinactive")
+						self.messages.append((0, "sourceinactive"))
 					if config.hdmicec.report_active_menu.value:
-						messages.append("menuinactive")
-				if messages:
-					self.sendMessages(0, messages)
+						self.messages.append((0, "menuinactive"))
 
 				if config.hdmicec.control_receiver_standby.value:
-					self.sendMessage(5, "keypoweroff")
-					self.sendMessage(5, "standby")
+					self.messages.append((5, "keypoweroff"))
+					self.messages.append((5, "standby"))
+
+				self.sendMessages(self.messages)
+
 			if os.path.exists("/usr/script/TvOff.sh"):
 				Console().ePopen("/usr/script/TvOff.sh &")
 
-	def onLeaveStandby(self):
-		self.wakeupMessages()
+	def sendMessagesIsActive(self, stopMessages = False):
+		if stopMessages:
+			active = False
+			if self.wait.isActive():
+				self.wait.stop()
+				active = True
+			if self.repeatTimer.isActive():
+				self.repeatTimer.stop()
+				active = True
+			if self.stateTimer.isActive():
+				self.stateTimer.stop()
+				active = True
+			return active
+		else:
+			return self.repeatTimer.isActive() or self.stateTimer.isActive()
 
-	def TVoff(self, configElement):
-		self.standbyMessages()
+	def stateTimeout(self):
+		print '[HdmiCec] timeout for check TV state!'
+		if 'on' in self.tv_powerstate:
+			self.checkTVstate('activesource')
+		elif self.tv_powerstate == 'unknown': # no response from tv - another input active ? -> check if powered on
+			self.checkTVstate('getpowerstate')
+		elif self.firstrun and not config.hdmicec.handle_deepstandby_events.value:
+			self.firstrun = False
 
-	def onEnterStandby(self, configElement):
-		from Screens.Standby import inStandby
-		inStandby.onClose.append(self.onLeaveStandby)
-		self.standbyMessages()
+	def checkTVstate(self, state = ''):
+		if self.stateTimer.isActive():
+			self.stateTimer.stop()
 
-	def onEnterDeepStandby(self, configElement):
-		if config.hdmicec.handle_deepstandby_events.value:
-			self.standbyMessages()
+		timeout = 3000
+		need_routinginfo = config.hdmicec.control_tv_standby.value and not config.hdmicec.tv_standby_notinputactive.value
+		if 'source' in state:
+			self.tv_powerstate = 'on'
+			if state == 'activesource' and self.what == 'on' and config.hdmicec.report_active_source.value and not self.activesource and not self.firstrun: # last try for switch to correct input
+				self.sendMessage(0, 'sourceactive')
+				if need_routinginfo or config.hdmicec.check_tv_state.value:
+					self.sendMessage(0, 'routinginfo')
+			if self.firstrun and not config.hdmicec.handle_deepstandby_events.value:
+				self.firstrun = False
+		elif state == 'tvstandby':
+			self.activesource = False
+			self.tv_powerstate = 'standby'
+		elif state == 'firstrun' and ((not config.hdmicec.handle_deepstandby_events.value and (need_routinginfo or config.hdmicec.report_active_menu.value)) or config.hdmicec.check_tv_state.value or config.hdmicec.workaround_activesource.value):
+			self.stateTimer.start(timeout,True)
+			self.sendMessage(0, 'routinginfo')
+		elif state == 'firstrun' and not config.hdmicec.handle_deepstandby_events.value:
+			self.firstrun = False
+		elif config.hdmicec.check_tv_state.value or 'powerstate' in state:
+			if state == 'getpowerstate' or state in ('on', 'standby'):
+				self.activesource = False
+				if state in ('on', 'standby'):
+					self.tv_powerstate = 'unknown'
+				else:
+					self.tv_powerstate = 'getpowerstate'
+				self.stateTimer.start(timeout,True)
+				self.sendMessage(0, 'powerstate')
+			elif state == 'powerstate' and 'on' in self.tv_powerstate:
+				self.stateTimer.start(timeout,True)
+				self.sendMessage(0, 'routinginfo')
+		else:
+			if state == 'on' and need_routinginfo:
+				self.activesource = False
+				self.tv_powerstate = 'unknown'
+				self.stateTimer.start(timeout,True)
+				self.sendMessage(0, 'routinginfo')
+			elif state == 'standby' and config.hdmicec.control_tv_standby.value:
+				self.activesource = False
+				self.tv_powerstate = 'standby'
 
-	def standby(self):
-		from Screens.Standby import Standby, inStandby
-		if not inStandby:
-			from Tools import Notifications
-			Notifications.AddNotification(Standby)
+	def handleTimerStop(self, reset = False):
+		if reset:
+			self.tv_skip_messages = False
+		if self.handleTimer.isActive():
+			self.handleTimer.stop()
+			if len(self.handleTimer.callback):
+				target = 'standby'
+				if 'deep' in str(self.handleTimer.callback[0]):
+					target = 'deep ' + target
+				print '[HdmiCec] stopping Timer to %s' %target
 
-	def wakeup(self):
-		from Screens.Standby import Standby, inStandby
-		if inStandby:
-			inStandby.Power()
+	def handleTVRequest(self, request):
+		if (request == 'activesource' and self.activesource) or (self.tv_lastrequest == 'tvstandby' and request == 'activesource' and self.handleTimer.isActive()):
+			self.handleTimerStop(True)
+		elif ((request == self.tv_lastrequest or self.tv_lastrequest == 'tvstandby') and self.handleTimer.isActive()) or (request == 'activesource' and not self.activesource and self.sendMessagesIsActive()):
+			return
+		else:
+			self.handleTimerStop(True)
+			self.tv_lastrequest = request
 
-	def messageReceived(self, message):
-		if config.hdmicec.enabled.value:
-			from Screens.Standby import inStandby
-			cmd = message.getCommand()
-			data = 16 * '\x00'
-			length = message.getData(data, len(data))
-			if cmd == 0x00: # feature abort
-				if data[0] == '\x44':
-					print 'eHdmiCec: volume forwarding not supported by device %02x'%(message.getAddress())
-					self.volumeForwardingEnabled = False
-			elif cmd == 0x46: # request name
-				self.sendMessage(message.getAddress(), 'osdname')
-			elif cmd == 0x7e or cmd == 0x72: # system audio mode status
-				if data[0] == '\x01':
-					self.volumeForwardingDestination = 5 # on: send volume keys to receiver
+			standby = deepstandby = False
+			if config.hdmicec.handle_tv_standby.value != 'disabled' and request == 'tvstandby':
+				self.tv_skip_messages = False
+				if config.hdmicec.handle_tv_standby.value == 'standby':
+					standby = True
+				elif config.hdmicec.handle_tv_standby.value == 'deepstandby':
+					deepstandby = True
+			elif config.hdmicec.handle_tv_input.value != 'disabled' and request == 'activesource':
+				self.tv_skip_messages = True
+				if config.hdmicec.handle_tv_input.value == 'standby':
+					standby = True
+				elif config.hdmicec.handle_tv_input.value == 'deepstandby':
+					deepstandby = True
+
+			if standby and Screens.Standby.inStandby:
+				self.tv_skip_messages = False
+				return
+			elif standby or deepstandby:
+				while len(self.handleTimer.callback):
+					self.handleTimer.callback.pop()
+
+			if standby:
+				if int(config.hdmicec.handle_tv_delaytime.value):
+					self.handleTimer.callback.append(self.standby)
+					self.handleTimer.startLongTimer(int(config.hdmicec.handle_tv_delaytime.value))
+					print '[HdmiCec] starting Timer to standby in %s s' %config.hdmicec.handle_tv_delaytime.value
 				else:
-					self.volumeForwardingDestination = 0 # off: send volume keys to tv
-				if config.hdmicec.volume_forwarding.value:
-					print 'eHdmiCec: volume forwarding to device %02x enabled'% self.volumeForwardingDestination
-					self.volumeForwardingEnabled = True
-			elif cmd == 0x8f: # request power status
-				if inStandby:
-					self.sendMessage(message.getAddress(), 'powerinactive')
+					self.standby()
+			elif deepstandby:
+				if int(config.hdmicec.handle_tv_delaytime.value):
+					self.handleTimer.callback.append(self.deepstandby)
+					self.handleTimer.startLongTimer(int(config.hdmicec.handle_tv_delaytime.value))
+					print '[HdmiCec] starting Timer to deep standby in %s s' %config.hdmicec.handle_tv_delaytime.value
 				else:
-					self.sendMessage(message.getAddress(), 'poweractive')
-			elif cmd == 0x83: # request address
-				self.sendMessage(message.getAddress(), 'reportaddress')
-			elif cmd == 0x86: # request streaming path
-				physicaladdress = ord(data[0]) * 256 + ord(data[1])
-				ouraddress = eHdmiCEC.getInstance().getPhysicalAddress()
-				if physicaladdress == ouraddress:
-					if not inStandby:
-						if config.hdmicec.report_active_source.value:
-							self.sendMessage(message.getAddress(), 'sourceactive')
-			elif cmd == 0x85: # request active source
-				if not inStandby:
-					if config.hdmicec.report_active_source.value:
-						self.sendMessage(message.getAddress(), 'sourceactive')
-			elif cmd == 0x8c: # request vendor id
-				self.sendMessage(message.getAddress(), 'vendorid')
-			elif cmd == 0x8d: # menu request
-				requesttype = ord(data[0])
-				if requesttype == 2: # query
-					if inStandby:
-						self.sendMessage(message.getAddress(), 'menuinactive')
-					else:
-						self.sendMessage(message.getAddress(), 'menuactive')
+					self.deepstandby()
 
-			# handle standby request from the tv
-			if cmd == 0x36 and config.hdmicec.handle_tv_standby.value:
-				self.standby()
+	def deepstandby(self):
+		import NavigationInstance
+		now = time()
+		recording = NavigationInstance.instance.getRecordingsCheckBeforeActivateDeepStandby()
+		rectimer = abs(NavigationInstance.instance.RecordTimer.getNextRecordingTime() - now) <= 900 or NavigationInstance.instance.RecordTimer.getStillRecording() or abs(NavigationInstance.instance.RecordTimer.getNextZapTime() - now) <= 900
+		pwrtimer = abs(NavigationInstance.instance.PowerTimer.getNextPowerManagerTime() - now) <= 900 or NavigationInstance.instance.PowerTimer.isProcessing(exceptTimer = 0) or not NavigationInstance.instance.PowerTimer.isAutoDeepstandbyEnabled()
+		if recording or rectimer or pwrtimer:
+			print '[HdmiCec] go not into deepstandby... recording=%s, rectimer=%s, pwrtimer=%s' %(recording, rectimer, pwrtimer)
+			self.standby()
+		else:
+			from Screens.InfoBar import InfoBar
+			if InfoBar and InfoBar.instance:
+				print '[HdmiCec] go into deepstandby...'
+				InfoBar.instance.openInfoBarSession(Screens.Standby.TryQuitMainloop, 1)
 
-			# handle wakeup requests from the tv
-			if config.hdmicec.handle_tv_wakeup.value:
-				if cmd == 0x04 and config.hdmicec.tv_wakeup_detection.value == "wakeup":
-					self.wakeup()
-				elif cmd == 0x84 and config.hdmicec.tv_wakeup_detection.value == "tvreportphysicaladdress":
-					if (ord(data[0]) * 256 + ord(data[1])) == 0 and ord(data[2]) == 0:
-						self.wakeup()
-				elif cmd == 0x85 and config.hdmicec.tv_wakeup_detection.value == "sourcerequest":
-					self.wakeup()
-				elif cmd == 0x86 and config.hdmicec.tv_wakeup_detection.value == "streamrequest":
-					physicaladdress = ord(data[0]) * 256 + ord(data[1])
-					ouraddress = eHdmiCEC.getInstance().getPhysicalAddress()
-					if physicaladdress == ouraddress:
-						self.wakeup()
-				elif cmd == 0x46 and config.hdmicec.tv_wakeup_detection.value == "osdnamerequest":
-					self.wakeup()
-				elif cmd != 0x36 and config.hdmicec.tv_wakeup_detection.value == "activity":
-					self.wakeup()
+	def standby(self):
+		if not Screens.Standby.inStandby:
+			import NavigationInstance
+			NavigationInstance.instance.skipWakeup = True
+			from Screens.InfoBar import InfoBar
+			if InfoBar and InfoBar.instance:
+				print '[HdmiCec] go into standby...'
+				InfoBar.instance.openInfoBarSession(Screens.Standby.Standby)
+
+	def wakeup(self):
+		self.handleTimerStop(True)
+		if Screens.Standby.inStandby:
+			print '[HdmiCec] wake up...'
+			Screens.Standby.inStandby.Power()
+
+	def onLeaveStandby(self):
+		self.wakeupMessages()
+
+	def onEnterStandby(self, configElement):
+		Screens.Standby.inStandby.onClose.append(self.onLeaveStandby)
+		self.standbyMessages()
+
+	def onEnterDeepStandby(self, configElement):
+		if config.hdmicec.handle_deepstandby_events.value:
+			self.standbyMessages()
 
 	def configVolumeForwarding(self, configElement):
 		if config.hdmicec.enabled.value and config.hdmicec.volume_forwarding.value:
 			self.volumeForwardingEnabled = True
-			self.sendMessage(0x05, 'givesystemaudiostatus')
+			self.sendMessage(5, 'givesystemaudiostatus')
 		else:
 			self.volumeForwardingEnabled = False
 
+	def configReportActiveMenu(self, configElement):
+		if config.hdmicec.report_active_menu.value:
+			self.sendMessage(0, 'sourceactive')
+			self.sendMessage(0, 'menuactive')
+		else:
+			self.sendMessage(0, 'menuinactive')
+
+	def configTVstate(self, configElement):
+		if not self.sendMessagesIsActive() and (config.hdmicec.check_tv_state.value or (config.hdmicec.control_tv_standby.value and not config.hdmicec.tv_standby_notinputactive.value)):
+			self.sendMessage(0, 'powerstate')
+			self.sendMessage(0, 'routinginfo')
+
 	def keyEvent(self, keyCode, keyEvent):
 		if not self.volumeForwardingEnabled: return
 		cmd = 0
 		data = ''
-		if keyEvent == 0:
-			if keyCode == 115:
-				cmd = 0x44
-				data = str(struct.pack('B', 0x41))
-			if keyCode == 114:
-				cmd = 0x44
-				data = str(struct.pack('B', 0x42))
-			if keyCode == 113:
-				cmd = 0x44
-				data = str(struct.pack('B', 0x43))
-		if keyEvent == 2:
+		if keyEvent in (0, 2):
 			if keyCode == 115:
 				cmd = 0x44
 				data = str(struct.pack('B', 0x41))
-			if keyCode == 114:
+			elif keyCode == 114:
 				cmd = 0x44
 				data = str(struct.pack('B', 0x42))
-			if keyCode == 113:
+			elif keyCode == 113:
 				cmd = 0x44
 				data = str(struct.pack('B', 0x43))
-		if keyEvent == 1:
-			if keyCode == 115 or keyCode == 114 or keyCode == 113:
-				cmd = 0x45
+		elif keyEvent == 1 and keyCode in (113, 114, 115):
+			cmd = 0x45
 		if cmd:
 			eHdmiCEC.getInstance().sendMessage(self.volumeForwardingDestination, cmd, data, len(data))
 			return 1
 		else:
 			return 0
-			
+
 	def sethdmipreemphasis(self):
-		try:
-			if config.hdmicec.preemphasis.value == True:
-				file = open("/proc/stb/hdmi/preemphasis", "w")
-				file.write('on')
-				file.close()
-			else:
-				file = open("/proc/stb/hdmi/preemphasis", "w")
-				file.write('off')
-				file.close()
-		except:
-			return
+		if fileExists("/proc/stb/hdmi/preemphasis"):
+			try:
+				if config.hdmicec.preemphasis.value == True:
+					file = open("/proc/stb/hdmi/preemphasis", "w")
+					file.write('on')
+					file.close()
+				else:
+					file = open("/proc/stb/hdmi/preemphasis", "w")
+					file.write('off')
+					file.close()
+			except:
+				return
 
 	def checkifPowerupWithoutWakingTv(self):
 		try:
diff --git a/lib/python/Components/InputDevice.py b/lib/python/Components/InputDevice.py
index 923fe1b..56b0642 100644
--- a/lib/python/Components/InputDevice.py
+++ b/lib/python/Components/InputDevice.py
@@ -7,8 +7,6 @@ from config import config, ConfigSubsection, ConfigInteger, ConfigYesNo, ConfigT
 from Tools.Directories import pathExists
 import platform
 
-boxtype = getBoxType()
-
 # include/uapi/asm-generic/ioctl.h
 IOC_NRBITS = 8L
 IOC_TYPEBITS = 8L
@@ -51,7 +49,7 @@ class inputDevices:
 
 			if self.name:
 				self.Devices[evdev] = {'name': self.name, 'type': self.getInputDeviceType(self.name),'enabled': False, 'configuredName': None }
-				if boxtype.startswith('et'):
+				if getBoxType().startswith('et'):
 					self.setDefaults(evdev) # load default remote control "delay" and "repeat" values for ETxxxx ("QuickFix Scrollspeed Menues" proposed by Xtrend Support)
 
 
@@ -107,8 +105,8 @@ class inputDevices:
 	def setDefaults(self, device):
 		print "[iInputDevices] setDefaults for device %s" % device
 		self.setDeviceAttribute(device, 'configuredName', None)
-		event_repeat = struct.pack('iihhi', 0, 0, 0x14, 0x01, 100)
-		event_delay = struct.pack('iihhi', 0, 0, 0x14, 0x00, 700)
+		event_repeat = struct.pack('LLHHi', 0, 0, 0x14, 0x01, 100)
+		event_delay = struct.pack('LLHHi', 0, 0, 0x14, 0x00, 700)
 		fd = os_open("/dev/input/" + device, O_RDWR)
 		os_write(fd, event_repeat)
 		os_write(fd, event_delay)
@@ -117,7 +115,7 @@ class inputDevices:
 	def setRepeat(self, device, value): #REP_PERIOD
 		if self.getDeviceAttribute(device, 'enabled'):
 			print "[iInputDevices] setRepeat for device %s to %d ms" % (device,value)
-			event = struct.pack('iihhi', 0, 0, 0x14, 0x01, int(value))
+			event = struct.pack('LLHHi', 0, 0, 0x14, 0x01, int(value))
 			fd = os_open("/dev/input/" + device, O_RDWR)
 			os_write(fd, event)
 			os_close(fd)
@@ -125,7 +123,7 @@ class inputDevices:
 	def setDelay(self, device, value): #REP_DELAY
 		if self.getDeviceAttribute(device, 'enabled'):
 			print "[iInputDevices] setDelay for device %s to %d ms" % (device,value)
-			event = struct.pack('iihhi', 0, 0, 0x14, 0x00, int(value))
+			event = struct.pack('LLHHi', 0, 0, 0x14, 0x00, int(value))
 			fd = os_open("/dev/input/" + device, O_RDWR)
 			os_write(fd, event)
 			os_close(fd)
@@ -179,6 +177,7 @@ class InitInputDevices:
 	def setupConfigEntries(self,device):
 		cmd = "config.inputDevices." + device + " = ConfigSubsection()"
 		exec cmd
+		boxtype=getBoxType()
 		if boxtype == 'dm800' or boxtype == 'azboxhd':
 			cmd = "config.inputDevices." + device + ".enabled = ConfigYesNo(default = True)"
 		else:
@@ -216,13 +215,9 @@ config.plugins.remotecontroltype.rctype = ConfigInteger(default = 0)
 
 class RcTypeControl():
 	def __init__(self):
-		if pathExists('/proc/stb/ir/rc/type') and pathExists('/proc/stb/info/boxtype') and getBrandOEM() not in ('gigablue', 'odin', 'ini', 'entwopia', 'tripledot'):
+		if pathExists('/proc/stb/ir/rc/type') and getBrandOEM() not in ('gigablue', 'odin', 'ini', 'entwopia', 'tripledot'):
 			self.isSupported = True
 
-			fd = open('/proc/stb/info/boxtype', 'r')
-			self.boxType = fd.read()
-			fd.close()
-
 			if config.plugins.remotecontroltype.rctype.value != 0:
 				self.writeRcType(config.plugins.remotecontroltype.rctype.value)
 		else:
@@ -231,9 +226,6 @@ class RcTypeControl():
 	def multipleRcSupported(self):
 		return self.isSupported
 
-	def getBoxType(self):
-		return self.boxType
-
 	def writeRcType(self, rctype):
 		fd = open('/proc/stb/ir/rc/type', 'w')
 		fd.write('%d' % rctype)
diff --git a/lib/python/Components/Ipkg.py b/lib/python/Components/Ipkg.py
index 81f6b48..0111af6 100644
--- a/lib/python/Components/Ipkg.py
+++ b/lib/python/Components/Ipkg.py
@@ -181,7 +181,7 @@ class IpkgComponent:
 			elif item[0].find('-bootlogo') > -1 and not config.plugins.softwaremanager.overwriteBootlogoFiles.value:
 				self.excludeList.append(item)
 				return
-			elif item[0].find('openplus-spinner') > -1 and not config.plugins.softwaremanager.overwriteSpinnerFiles.value:
+			elif item[0].find('openatv-spinner') > -1 and not config.plugins.softwaremanager.overwriteSpinnerFiles.value:
 				self.excludeList.append(item)
 				return
 			else:
diff --git a/lib/python/Components/Language.py b/lib/python/Components/Language.py
index cd5bbc5..96048cc 100644
--- a/lib/python/Components/Language.py
+++ b/lib/python/Components/Language.py
@@ -34,7 +34,7 @@ class Language:
 		self.addLanguage("Catal", "ca", "AD", "ISO-8859-15")
 		self.addLanguage("esky", "cs", "CZ", "ISO-8859-15")
 		self.addLanguage("SChinese", "zh", "CN", "UTF-8")
-		self.addLanguage("TChinese", "hk", "HK", "UTF-8")
+		self.addLanguage("TChinese", "zh", "HK", "UTF-8")
 		self.addLanguage("Dansk", "da", "DK", "ISO-8859-15")
 		self.addLanguage("", "el", "GR", "ISO-8859-7")
 		self.addLanguage("English (UK)", "en", "GB", "ISO-8859-15")
@@ -47,6 +47,7 @@ class Language:
 		self.addLanguage("Hebrew", "he", "IL", "ISO-8859-15")
 		self.addLanguage("Hrvatski", "hr", "HR", "ISO-8859-15")
 		self.addLanguage("Magyar", "hu", "HU", "ISO-8859-15")
+		self.addLanguage("Indonesian", "id", "ID", "ISO-8859-15")
 		self.addLanguage("slenska", "is", "IS", "ISO-8859-15")
 		self.addLanguage("Italiano", "it", "IT", "ISO-8859-15")
 		self.addLanguage("Kurdish", "ku", "KU", "ISO-8859-15")
@@ -70,14 +71,9 @@ class Language:
 
 	def addLanguage(self, name, lang, country, encoding):
 		try:
-			if lang in self.ll:
-				if country == "GB" or country == "BR":
-					if (lang + "_" + country) in self.ll:
-						self.lang[str(lang + "_" + country)] = ((name, lang, country, encoding))
-						self.langlist.append(str(lang + "_" + country))
-				else:
-					self.lang[str(lang + "_" + country)] = ((name, lang, country, encoding))
-					self.langlist.append(str(lang + "_" + country))
+			if lang in self.ll or (lang + "_" + country) in self.ll:
+				self.lang[str(lang + "_" + country)] = ((name, lang, country, encoding))
+				self.langlist.append(str(lang + "_" + country))
 
 		except:
 			print "Language " + str(name) + " not found"
diff --git a/lib/python/Components/Lcd.py b/lib/python/Components/Lcd.py
index 9d96152..c4034ac 100644
--- a/lib/python/Components/Lcd.py
+++ b/lib/python/Components/Lcd.py
@@ -1,4 +1,4 @@
-from boxbranding import getBoxType
+from boxbranding import getBoxType, getDisplayType
 from sys import maxint
 
 from twisted.internet import threads
@@ -300,7 +300,7 @@ def standbyCounterChanged(configElement):
 	config.lcd.ledbrightnessdeepstandby.apply()
 
 def InitLcd():
-	if getBoxType() in ('lunix','purehdse','vipert2c','evoslimse','evoslimt2c','valalinux','tmtwin4k','tmnanom3','mbmicrov2','revo4k','force3uhd','force2nano','evoslim','wetekplay', 'wetekplay2', 'wetekhub', 'ultrabox', 'novaip', 'dm520', 'dm525', 'purehd', 'mutant11', 'xpeedlxpro', 'zgemmai55', 'sf98', 'et7x00mini', 'xpeedlxcs2', 'xpeedlxcc', 'e4hd', 'e4hdhybrid', 'mbmicro', 'beyonwizt2', 'amikomini', 'dynaspark', 'amiko8900', 'sognorevolution', 'arguspingulux', 'arguspinguluxmini', 'arguspinguluxplus', 'sparkreloaded', 'sabsolo', 'sparklx', 'gis8120', 'gb800se', 'gb800solo', 'gb800seplus', 'gbultrase', 'gbipbox', 'tmsingle', 'tmnano2super', 'iqonios300hd', 'iqonios300hdv2', 'optimussos1plus', 'optimussos1', 'vusolo', 'et4x00', 'et5x00', 'et6x00', 'et7000', 'et7100', 'mixosf7', 'mixoslumi', 'gbx1', 'gbx2', 'gbx3', 'gbx3h'):
+	if getBoxType() in ('force4','alien5','viperslim','lunix','lunix4k','purehdse','vipert2c','evoslimse','evoslimt2c','valalinux','tmtwin4k','tmnanom3','mbmicrov2','revo4k','force3uhd','force2nano','evoslim','wetekplay', 'wetekplay2', 'wetekhub', 'ultrabox', 'novaip', 'dm520', 'dm525', 'purehd', 'mutant11', 'xpeedlxpro', 'zgemmai55', 'sf98', 'et7x00mini', 'xpeedlxcs2', 'xpeedlxcc', 'e4hd', 'e4hdhybrid', 'mbmicro', 'beyonwizt2', 'amikomini', 'dynaspark', 'amiko8900', 'sognorevolution', 'arguspingulux', 'arguspinguluxmini', 'arguspinguluxplus', 'sparkreloaded', 'sabsolo', 'sparklx', 'gis8120', 'gb800se', 'gb800solo', 'gb800seplus', 'gbultrase', 'gbipbox', 'tmsingle', 'tmnano2super', 'iqonios300hd', 'iqonios300hdv2', 'optimussos1plus', 'optimussos1', 'vusolo', 'et4x00', 'et5x00', 'et6x00', 'et7000', 'et7100', 'mixosf7', 'mixoslumi', 'gbx1', 'gbx2', 'gbx3', 'gbx3h'):
 		detected = False
 	else:
 		detected = eDBoxLCD.getInstance().detected()
@@ -309,7 +309,7 @@ def InitLcd():
 
 	if fileExists("/proc/stb/lcd/mode"):
 		f = open("/proc/stb/lcd/mode", "r")
-		can_lcdmodechecking = f.read().strip().split(" ")
+		can_lcdmodechecking = f.read()
 		f.close()
 	else:
 		can_lcdmodechecking = False
@@ -337,46 +337,26 @@ def InitLcd():
 			def setLCDModePiP(configElement):
 				pass
 			def setLCDScreenshot(configElement):
- 				ilcd.setScreenShot(configElement.value);
-
-			if getBoxType() in ('gbquad4k', 'gbue4k'):
-				config.lcd.modepip = ConfigSelection(choices={
-						"0": _("off"),
-						"4": _("PIP"),
-						"6": _("PIP with OSD")},
-						default = "0")
-			else:
-				config.lcd.modepip = ConfigSelection(choices={
-						"0": _("off"),
-						"5": _("PIP"),
-						"7": _("PIP with OSD")},
-						default = "0")
-			if config.misc.boxtype.value in ( 'gbquad', 'gbquadplus', 'gbquad4k', 'gbue4k'):
+				ilcd.setScreenShot(configElement.value)
+
+			config.lcd.modepip = ConfigSelection(choices={
+					"0": _("off"),
+					"5": _("PIP"),
+					"7": _("PIP with OSD")},
+					default = "0")
+			if config.misc.boxtype.value in ( 'gbquad', 'gbquadplus'):
 				config.lcd.modepip.addNotifier(setLCDModePiP)
 			else:
 				config.lcd.modepip = ConfigNothing()
-				
 			config.lcd.screenshot = ConfigYesNo(default=False)
- 			config.lcd.screenshot.addNotifier(setLCDScreenshot)	
-
-			if getBoxType() in ('gbquad4k', 'gbue4k'):
-				#  (0:normal, 1:video0, 2:fb, 3:vide0+fb, 4:video1, 5:vide0+video1, 6:video1+fb, 7:video0+video1+fb)
-				config.lcd.modeminitv = ConfigSelection(default = "0", choices=[
-						("0", _("normal")),
-						("1", _("MiniTV") + _(" - video0")),
-						("3", _("MiniTV with OSD") + _(" - video0")),
-						("2", _("OSD")),
-						("4", _("MiniTV") + _(" - video1")),
-						("6", _("MiniTV with OSD") + _(" - video1")),
-						("5", _("MiniTV") + _(" - video0+video1")),
-						("7", _("MiniTV with OSD") + _(" - video0+video1"))]) 
-			else:
-				config.lcd.modeminitv = ConfigSelection(choices={
-						"0": _("normal"),
-						"1": _("MiniTV"),
-						"2": _("OSD"),
-						"3": _("MiniTV with OSD")},
-						default = "0")
+			config.lcd.screenshot.addNotifier(setLCDScreenshot)
+
+			config.lcd.modeminitv = ConfigSelection(choices={
+					"0": _("normal"),
+					"1": _("MiniTV"),
+					"2": _("OSD"),
+					"3": _("MiniTV with OSD")},
+					default = "0")
 			config.lcd.fpsminitv = ConfigSlider(default=30, limits=(0, 30))
 			config.lcd.modeminitv.addNotifier(setLCDModeMinitTV)
 			config.lcd.fpsminitv.addNotifier(setMiniTVFPS)
@@ -478,7 +458,7 @@ def InitLcd():
 		config.usage.lcd_standbypowerled = ConfigSelection(default = "on", choices = [("off", _("Off")), ("on", _("On"))])
 		config.usage.lcd_standbypowerled.addNotifier(setPowerLEDstanbystate)
 
-		if getBoxType() in ('dm900', 'dm920', 'e4hdultra'):
+		if getBoxType() in ('dm900', 'dm920', 'e4hdultra', 'protek4k'):
 			standby_default = 4
 		elif getBoxType() in ('spycat4kmini', 'osmega'):
 			standby_default = 10
@@ -545,14 +525,16 @@ def InitLcd():
 			config.lcd.minitvfps = ConfigSlider(default=30, limits=(0, 30))
 			config.lcd.minitvfps.addNotifier(setLCDminitvfps)
 
-		if SystemInfo["VFD_scroll_repeats"] and getBoxType() not in ('ixussone', 'ixusszero'):
+		if SystemInfo["VFD_scroll_repeats"] and getBoxType() not in ('ixussone', 'ixusszero') and getDisplayType() not in ('7segment'):
 			def scroll_repeats(el):
 				open(SystemInfo["VFD_scroll_repeats"], "w").write(el.value)
 			choicelist = [("0", _("None")), ("1", _("1X")), ("2", _("2X")), ("3", _("3X")), ("4", _("4X")), ("500", _("Continues"))]
 			config.usage.vfd_scroll_repeats = ConfigSelection(default = "3", choices = choicelist)
 			config.usage.vfd_scroll_repeats.addNotifier(scroll_repeats, immediate_feedback = False)
+		else:
+			config.usage.vfd_scroll_repeats = ConfigNothing()
 
-		if SystemInfo["VFD_scroll_delay"] and getBoxType() not in ('ixussone', 'ixusszero'):
+		if SystemInfo["VFD_scroll_delay"] and getBoxType() not in ('ixussone', 'ixusszero')  and getDisplayType() not in ('7segment'):
 			def scroll_delay(el):
 				# add workaround for Boxes who need hex code
 				if getBoxType() in ('sf4008', 'beyonwizu4'):
@@ -564,8 +546,9 @@ def InitLcd():
 			config.lcd.hdd = ConfigSelection([("0", _("No")), ("1", _("Yes"))], "1")
 		else:
 			config.lcd.hdd = ConfigNothing()
+			config.usage.vfd_scroll_delay = ConfigNothing()
 
-		if SystemInfo["VFD_initial_scroll_delay"] and getBoxType() not in ('ixussone', 'ixusszero'):
+		if SystemInfo["VFD_initial_scroll_delay"] and getBoxType() not in ('ixussone', 'ixusszero')  and getDisplayType() not in ('7segment'):
 			def initial_scroll_delay(el):
 				if getBoxType() in ('sf4008', 'beyonwizu4'):
 					# add workaround for Boxes who need hex code
@@ -582,8 +565,10 @@ def InitLcd():
 			("0", _("no delay"))]
 			config.usage.vfd_initial_scroll_delay = ConfigSelection(default = "10000", choices = choicelist)
 			config.usage.vfd_initial_scroll_delay.addNotifier(initial_scroll_delay, immediate_feedback = False)
+		else:
+			config.usage.vfd_initial_scroll_delay = ConfigNothing()
 
-		if SystemInfo["VFD_final_scroll_delay"] and getBoxType() not in ('ixussone', 'ixusszero'):
+		if SystemInfo["VFD_final_scroll_delay"] and getBoxType() not in ('ixussone', 'ixusszero')  and getDisplayType() not in ('7segment'):
 			def final_scroll_delay(el):
 				if getBoxType() in ('sf4008', 'beyonwizu4'):
 					# add workaround for Boxes who need hex code
@@ -600,6 +585,8 @@ def InitLcd():
 			("0", _("no delay"))]
 			config.usage.vfd_final_scroll_delay = ConfigSelection(default = "10000", choices = choicelist)
 			config.usage.vfd_final_scroll_delay.addNotifier(final_scroll_delay, immediate_feedback = False)
+		else:
+			config.usage.vfd_final_scroll_delay = ConfigNothing()
 
 		if fileExists("/proc/stb/lcd/show_symbols"):
 			config.lcd.mode = ConfigSelection([("0", _("No")), ("1", _("Yes"))], "1")
diff --git a/lib/python/Components/Network.py b/lib/python/Components/Network.py
index 203e4f5..220d2f1 100644
--- a/lib/python/Components/Network.py
+++ b/lib/python/Components/Network.py
@@ -42,7 +42,7 @@ class Network:
 		return self.remoteRootFS
 
 	def isBlacklisted(self, iface):
-		return iface in ('lo', 'wifi0', 'wmaster0', 'sit0', 'tun0', 'tap0', 'sys0', 'p2p0')
+		return iface in ('lo', 'wifi0', 'wmaster0', 'sit0', 'tun0', 'tap0', 'sys0', 'p2p0', 'tunl0')
 
 	def getInterfaces(self, callback = None):
 		self.configuredInterfaces = []
diff --git a/lib/python/Components/NimManager.py b/lib/python/Components/NimManager.py
index b124f08..97419aa 100644
--- a/lib/python/Components/NimManager.py
+++ b/lib/python/Components/NimManager.py
@@ -180,6 +180,9 @@ class SecConfigure:
 					if "DVB-S2" in types:
 						# DVB-S2 implies DVB-S support
 						types.remove("DVB-S")
+					if "DVB-S2X" in types:
+						# DVB-S2X implies DVB-S2 support
+						types.remove("DVB-S2")
 					if len(types) > 1:
 						slot.multi_type = {}
 						for type in types:
@@ -195,8 +198,9 @@ class SecConfigure:
 					(slot.canBeCompatible("ATSC") and (slot.config.atsc.configMode.value != "nothing" and True or False)) or
 					(slot.canBeCompatible("DVB-S") and (slot.config.dvbs.configMode.value != "nothing" and True or False)) or
 					(slot.canBeCompatible("DVB-C") and (slot.config.dvbc.configMode.value != "nothing" and True or False)) or
-					(slot.canBeCompatible("DVB-T") and (slot.config.dvbt.configMode.value != "nothing" and True or False)),
-					slot.canBeCompatible("DVB-S2") and (slot.config.dvbs.configMode.value != "nothing" and True or False),
+					(slot.canBeCompatible("DVB-T") and (slot.config.dvbt.configMode.value != "nothing" and True or False)) or
+					(slot.canBeCompatible("DVB-S2") and (slot.config.dvbs.configMode.value != "nothing" and True or False)),
+					slot.canBeCompatible("DVB-S2X") and (slot.config.dvbs.configMode.value != "nothing" and True or False),
 					slot.frontend_id is None and -1 or slot.frontend_id))
 		eDVBResourceManager.getInstance().setFrontendSlotInformations(used_nim_slots)
 
@@ -419,7 +423,7 @@ class SecConfigure:
 								sec.setLNBLOFL(manufacturer.lofl[product_name][position_idx].value * 1000)
 								sec.setLNBLOFH(manufacturer.lofh[product_name][position_idx].value * 1000)
 								sec.setLNBThreshold(manufacturer.loft[product_name][position_idx].value * 1000)
-								sec.setLNBSatCRTuningAlgo(currLnb.unicableTuningAlgo.value == "reliable" and 1 or 0)
+								sec.setLNBSatCRTuningAlgo(["traditional", "reliable", "traditional_retune", "reliable_retune"].index(currLnb.unicableTuningAlgo.value))
 								sec.setLNBBootupTime(manufacturer.bootuptime[product_name][0].value)
 								configManufacturer.save_forced = True
 								manufacturer.product.save_forced = True
@@ -711,11 +715,11 @@ class SecConfigure:
 		self.update()
 
 class NIM(object):
-	def __init__(self, slot, type, description, has_outputs=True, internally_connectable=None, multi_type=None, frontend_id=None, i2c=None, is_empty=False, input_name = None):
+	def __init__(self, slot, type, description, has_outputs=True, internally_connectable=None, multi_type=None, frontend_id=None, i2c=None, is_empty=False, input_name = None, supports_blind_scan = False):
 		if not multi_type: multi_type = {}
 		self.slot = slot
 
-		if type not in ("DVB-S", "DVB-C", "DVB-T", "DVB-S2", "DVB-T2", "DVB-C2", "ATSC", None):
+		if type not in ("DVB-S", "DVB-C", "DVB-T", "DVB-S2", "DVB-S2X", "DVB-T2", "DVB-C2", "ATSC", None):
 			print "warning: unknown NIM type %s, not using." % type
 			type = None
 
@@ -724,6 +728,7 @@ class NIM(object):
 		self.has_outputs = has_outputs
 		self.internally_connectable = internally_connectable
 		self.multi_type = multi_type
+		self.supports_blind_scan = supports_blind_scan
 		self.i2c = i2c
 		self.frontend_id = frontend_id
 		self.__is_empty = is_empty
@@ -735,6 +740,7 @@ class NIM(object):
 				"DVB-C": ("DVB-C", None),
 				"DVB-T": ("DVB-T", None),
 				"DVB-S2": ("DVB-S", "DVB-S2", None),
+				"DVB-S2X": ("DVB-S", "DVB-S2", "DVB-S2X", None),
 				"DVB-C2": ("DVB-C", "DVB-C2", None),
 				"DVB-T2": ("DVB-T", "DVB-T2", None),
 				"ATSC": ("ATSC", None),
@@ -774,6 +780,7 @@ class NIM(object):
 				"DVB-C": ("DVB-C", "DVB-C2"),
 				"DVB-T": ("DVB-T","DVB-T2"),
 				"DVB-S2": ("DVB-S", "DVB-S2"),
+				"DVB-S2X": ("DVB-S", "DVB-S2", "DVB-S2X"),
 				"DVB-C2": ("DVB-C", "DVB-C2"),
 				"DVB-T2": ("DVB-T", "DVB-T2"),
 				"ATSC": "ATSC",
@@ -843,6 +850,9 @@ class NIM(object):
 			multistream = True
 		return multistream
 
+	def supportsBlindScan(self):
+		return self.supports_blind_scan
+
 	# returns dict {<slotid>: <type>}
 	def getMultiTypeList(self):
 		return self.multi_type
@@ -855,6 +865,7 @@ class NIM(object):
 			"DVB-T": "DVB-T",
 			"DVB-C": "DVB-C",
 			"DVB-S2": "DVB-S2",
+			"DVB-S2X": "DVB-S2X",
 			"DVB-T2": "DVB-T2",
 			"DVB-C2": "DVB-C2",
 			"ATSC": "ATSC",
@@ -983,6 +994,23 @@ class NimManager:
 		self.transpondersatsc = { }
 		db = eDVBDB.getInstance()
 
+		try:
+			for slot in self.nim_slots:
+				if slot.frontend_id is not None:
+					types = [type for type in ["DVB-C", "DVB-T", "DVB-T2", "DVB-S", "DVB-S2", "DVB-S2X", "ATSC"] if eDVBResourceManager.getInstance().frontendIsCompatible(slot.frontend_id, type)]
+					if "DVB-T2" in types:
+						# DVB-T2 implies DVB-T support
+						types.remove("DVB-T")
+					if "DVB-S2" in types:
+						# DVB-S2 implies DVB-S support
+						types.remove("DVB-S")
+					if len(types) > 1:
+						slot.multi_type = {}
+						for type in types:
+							slot.multi_type[str(types.index(type))] = type
+		except:
+			pass
+
 		if self.hasNimType("DVB-S"):
 			print "Reading satellites.xml"
 			if db.readSatellites(self.satList, self.satellites, self.transponders):
@@ -1163,7 +1191,7 @@ class NimManager:
 		#          Name: Alps BSBE1 702A
 
 		#
-		# Type will be either "DVB-S", "DVB-S2", "DVB-T", "DVB-C" or None.
+		# Type will be either "DVB-S", "DVB-S2", "DVB-S2X", "DVB-T", "DVB-C" or None.
 
 		# nim_slots is an array which has exactly one entry for each slot, even for empty ones.
 		self.nim_slots = [ ]
@@ -1186,8 +1214,6 @@ class NimManager:
 				entries[current_slot] = {}
 			elif line.startswith("Type:"):
 				entries[current_slot]["type"] = str(line[6:])
-				if entries[current_slot]["type"] == "DVB-S2X":
-					entries[current_slot]["type"] = "DVB-S2"
 				entries[current_slot]["isempty"] = False
 			elif line.strip().startswith("Input_Name:"):
 				entries[current_slot]["input_name"] = str(line.strip()[12:])
@@ -1200,6 +1226,9 @@ class NimManager:
 			elif line.startswith("Internally_Connectable:"):
 				input = int(line[len("Internally_Connectable:") + 1:])
 				entries[current_slot]["internally_connectable"] = input
+			elif line.startswith("Supports_Blind_Scan:"):
+				input = str(line[len("Supports_Blind_Scan:") + 1:])
+				entries[current_slot]["supports_blind_scan"] = (input == "yes")
 			elif line.startswith("Frontend_Device:"):
 				input = int(line[len("Frontend_Device:") + 1:])
 				entries[current_slot]["frontend_device"] = input
@@ -1245,7 +1274,9 @@ class NimManager:
 					entry["multi_type"] = {}
 			if not (entry.has_key("input_name")):
 				entry["input_name"] = chr(ord('A') + id)
-			self.nim_slots.append(NIM(slot = id, description = entry["name"], type = entry["type"], has_outputs = entry["has_outputs"], internally_connectable = entry["internally_connectable"], multi_type = entry["multi_type"], frontend_id = entry["frontend_device"], i2c = entry["i2c"], is_empty = entry["isempty"], input_name = entry.get("input_name", None)))
+			if "supports_blind_scan" not in entry:
+				entry["supports_blind_scan"] = False
+			self.nim_slots.append(NIM(slot = id, description = entry["name"], type = entry["type"], has_outputs = entry["has_outputs"], internally_connectable = entry["internally_connectable"], multi_type = entry["multi_type"], frontend_id = entry["frontend_device"], i2c = entry["i2c"], is_empty = entry["isempty"], input_name = entry.get("input_name", None), supports_blind_scan = entry["supports_blind_scan"]))
 
 	def hasNimType(self, chktype):
 		for slot in self.nim_slots:
@@ -1337,7 +1368,7 @@ class NimManager:
 
 	def canEqualTo(self, slotid):
 		type = self.getNimType(slotid)
-		type = type[:5] # DVB-S2 --> DVB-S, DVB-T2 --> DVB-T, DVB-C2 --> DVB-C
+		type = type[:5] # DVB-S2X --> DVB-S2 --> DVB-S, DVB-T2 --> DVB-T, DVB-C2 --> DVB-C
 		nimList = self.getNimListOfType(type, slotid)
 		for nim in nimList[:]:
 			if self.nim_slots[nim].canBeCompatible('DVB-S'):
@@ -1348,7 +1379,7 @@ class NimManager:
 
 	def canDependOn(self, slotid):
 		type = self.getNimType(slotid)
-		type = type[:5] # DVB-S2 --> DVB-S, DVB-T2 --> DVB-T, DVB-C2 --> DVB-C
+		type = type[:5] # DVB-S2X --> DVB-S2 --> DVB-S, DVB-T2 --> DVB-T, DVB-C2 --> DVB-C
 		nimList = self.getNimListOfType(type, slotid)
 		positionerList = []
 		for nim in nimList[:]:
@@ -1914,7 +1945,7 @@ def InitNimManager(nimmgr, update_slots = []):
 				txt = _("Misconfigured unicable connection from tuner %s to tuner %s!\nTuner %s option \"connected to\" are disabled now") % (chr(int(x) + ord('A')), chr(int(nim.advanced.unicableconnectedTo.saved_value) + ord('A')), chr(int(x) + ord('A')),)
 				AddPopup(txt, type = MessageBox.TYPE_ERROR, timeout = 0, id = "UnicableConnectionFailed")
 
-			section.unicableTuningAlgo = ConfigSelection([("reliable", _("reliable")),("traditional", _("traditional (fast)"))], default="reliable")
+			section.unicableTuningAlgo = ConfigSelection([("reliable", _("reliable")),("traditional", _("traditional (fast)")),("reliable_retune", _("reliable, retune")),("traditional_retune", _("traditional (fast), retune"))], default="reliable_retune")
 
 	def configDiSEqCModeChanged(configElement):
 		section = configElement.section
@@ -2025,6 +2056,14 @@ def InitNimManager(nimmgr, update_slots = []):
 			f.write(configElement.value)
 			f.close()
 
+	def t2miRawModeChanged(configElement):
+		fe_id = configElement.fe_id
+		slot_id = configElement.slot_id
+		if path.exists("/proc/stb/frontend/%d/t2mirawmode" % fe_id):
+			f = open("/proc/stb/frontend/%d/t2mirawmode" % fe_id, "w")
+			f.write(configElement.value)
+			f.close()
+
 	def connectedToChanged(slot_id, nimmgr, configElement):
 		configMode = nimmgr.getNimConfig(slot_id).dvbs.configMode
 		if configMode.value == 'loopthrough':
@@ -2047,6 +2086,10 @@ def InitNimManager(nimmgr, update_slots = []):
 			nim.scpcSearchRange.fe_id = x - empty_slots
 			nim.scpcSearchRange.slot_id = x
 			nim.scpcSearchRange.addNotifier(scpcSearchRangeChanged)
+			nim.t2miRawMode = ConfigSelection([("disable", _("disabled")), ("enable", _("enabled"))], "disable")
+			nim.t2miRawMode.fe_id = x - empty_slots
+			nim.t2miRawMode.slot_id = x
+			nim.t2miRawMode.addNotifier(t2miRawModeChanged)
 			nim.diseqc13V = ConfigYesNo(False)
 			nim.diseqcMode = ConfigSelection(diseqc_mode_choices, "single")
 			nim.connectedTo = ConfigSelection([(str(id), nimmgr.getNimDescription(id)) for id in nimmgr.getNimListOfType("DVB-S") if id != x])
@@ -2083,10 +2126,8 @@ def InitNimManager(nimmgr, update_slots = []):
 		except:
 			list = [(x[0], x[0]) for x in nimmgr.cablesList]
 			nim.scan_networkid = ConfigInteger(default = 0, limits = (0, 99999))
-			possible_scan_types = [("bands", _("Frequency bands")), ("steps", _("Frequency steps"))]
-			if list:
-				possible_scan_types.append(("provider", _("Provider")))
-				nim.scan_provider = ConfigSelection(default = "0", choices = list)
+			possible_scan_types = [("bands", _("Frequency bands")), ("steps", _("Frequency steps")), ("provider", _("Provider"))]
+			nim.scan_provider = ConfigSelection(default = "0", choices = list)
 			nim.scan_type = ConfigSelection(default = "provider", choices = possible_scan_types)
 			nim.scan_band_EU_VHF_I = ConfigYesNo(default = True)
 			nim.scan_band_EU_MID = ConfigYesNo(default = True)
@@ -2129,13 +2170,16 @@ def InitNimManager(nimmgr, update_slots = []):
 	try:
 		for slot in nimmgr.nim_slots:
 			if slot.frontend_id is not None:
-				types = [type for type in ["DVB-C", "DVB-T", "DVB-T2", "DVB-S", "DVB-S2", "ATSC"] if eDVBResourceManager.getInstance().frontendIsCompatible(slot.frontend_id, type)]
+				types = [type for type in ["DVB-C", "DVB-T", "DVB-T2", "DVB-S", "DVB-S2", "DVB-S2X", "ATSC"] if eDVBResourceManager.getInstance().frontendIsCompatible(slot.frontend_id, type)]
 				if "DVB-T2" in types:
 					# DVB-T2 implies DVB-T support
 					types.remove("DVB-T")
 				if "DVB-S2" in types:
 					# DVB-S2 implies DVB-S support
 					types.remove("DVB-S")
+				if "DVB-S2X" in types:
+					# DVB-S2X implies DVB-S2 support
+					types.remove("DVB-S2")
 				if len(types) > 1:
 					slot.multi_type = {}
 					for type in types:
diff --git a/lib/python/Components/ParentalControl.py b/lib/python/Components/ParentalControl.py
index 2edd85f..083e064 100644
--- a/lib/python/Components/ParentalControl.py
+++ b/lib/python/Components/ParentalControl.py
@@ -37,7 +37,7 @@ def InitParentalControl():
 	config.ParentalControl.config_sections.standby_menu = ConfigYesNo(default = False)
 	config.ParentalControl.config_sections.movie_list = ConfigYesNo(default = False)
 	config.ParentalControl.config_sections.context_menus = ConfigYesNo(default = False)
-	config.ParentalControl.config_sections.openpanel = ConfigYesNo(default = False)
+	config.ParentalControl.config_sections.infopanel = ConfigYesNo(default = False)
 	config.ParentalControl.config_sections.quickmenu = ConfigYesNo(default = False)
 
 	#Added for backwards compatibility with some 3rd party plugins that depend on this config
diff --git a/lib/python/Components/PowerTimerList.py b/lib/python/Components/PowerTimerList.py
index 26c7dd6..f809273 100644
--- a/lib/python/Components/PowerTimerList.py
+++ b/lib/python/Components/PowerTimerList.py
@@ -67,7 +67,7 @@ class PowerTimerList(HTMLComponent, GUIComponent, object):
 			autosleepwindow = ""
 			if timer.autosleepwindow == 'yes':
 				autosleepwindow = _("Time range:") + " " + FuzzyTime(timer.autosleepbegin)[1] + " ... " + FuzzyTime(timer.autosleepend)[1] + ", "
-			res.append((eListboxPythonMultiContent.TYPE_TEXT, self.satPosLeft, self.rowSplit, width-self.satPosLeft, self.itemHeight - self.rowSplit, 1, RT_HALIGN_RIGHT|RT_VALIGN_TOP, autosleepwindow + _("Delay:") + " " + str(timer.autosleepdelay) + "(" + _("mins") + ")"))
+			res.append((eListboxPythonMultiContent.TYPE_TEXT, self.satPosLeft, self.rowSplit, width-self.satPosLeft, self.itemHeight - self.rowSplit, 1, RT_HALIGN_RIGHT|RT_VALIGN_TOP, autosleepwindow + _("Delay:") + " " + str(timer.autosleepdelay) + " (" + _("mins") + ")"))
 		else:
 			res.append((eListboxPythonMultiContent.TYPE_TEXT, self.satPosLeft, 0, width - self.satPosLeft, self.rowSplit, 2, RT_HALIGN_RIGHT|RT_VALIGN_BOTTOM, _('At End:') + ' ' + getafterEvent(timer)))
 			begin = FuzzyTime(timer.begin)
diff --git a/lib/python/Components/Renderer/LcdPicon.py b/lib/python/Components/Renderer/LcdPicon.py
index b0759ec..a62473c 100644
--- a/lib/python/Components/Renderer/LcdPicon.py
+++ b/lib/python/Components/Renderer/LcdPicon.py
@@ -4,7 +4,7 @@ from enigma import ePixmap, ePicLoad
 from Tools.Alternatives import GetWithAlternative
 from Tools.Directories import pathExists, SCOPE_ACTIVE_SKIN, resolveFilename
 from Components.Harddisk import harddiskmanager
-from boxbranding import getBoxType
+from boxbranding import getDisplayType
 from ServiceReference import ServiceReference
 from Components.SystemInfo import SystemInfo
 
@@ -22,7 +22,7 @@ def initLcdPiconPaths():
 def onMountpointAdded(mountpoint):
 	global searchPaths
 	try:
-		if getBoxType() in ('vuultimo', 'et10000', 'mutant2400', 'xpeedlx3', 'quadbox2400', 'sezammarvel', 'atemionemesis', 'mbultra', 'beyonwizt4', 'dm7020hd', 'dm7080') and not SystemInfo["grautec"] or os.path.isdir(mountpoint + 'piconlcd'):
+		if getDisplayType() in ('bwlcd255', 'bwlcd140') and not SystemInfo["grautec"] or os.path.isdir(mountpoint + 'piconlcd'):
 			path = os.path.join(mountpoint, 'piconlcd') + '/'
 		else:
 			path = os.path.join(mountpoint, 'picon') + '/'
@@ -37,7 +37,7 @@ def onMountpointAdded(mountpoint):
 
 def onMountpointRemoved(mountpoint):
 	global searchPaths
-	if getBoxType() in ('vuultimo', 'et10000', 'mutant2400', 'xpeedlx3', 'quadbox2400', 'sezammarvel', 'atemionemesis', 'mbultra', 'beyonwizt4', 'dm7020hd', 'dm7080') and not SystemInfo["grautec"] or os.path.isdir(mountpoint + 'piconlcd'):
+	if getDisplayType() in ('bwlcd255', 'bwlcd140') and not SystemInfo["grautec"] or os.path.isdir(mountpoint + 'piconlcd'):
 		path = os.path.join(mountpoint, 'piconlcd') + '/'
 	else:
 		path = os.path.join(mountpoint, 'picon') + '/'
@@ -109,20 +109,20 @@ class LcdPicon(Renderer):
 		self.piconsize = (0,0)
 		self.pngname = ""
 		self.lastPath = None
-		if getBoxType() in ('vuultimo', 'et10000', 'mutant2400', 'xpeedlx3', 'quadbox2400', 'sezammarvel', 'atemionemesis', 'mbultra', 'beyonwizt4', 'dm7020hd', 'dm7080') and not SystemInfo["grautec"]:
+		if getDisplayType() in ('bwlcd255', 'bwlcd140') and not SystemInfo["grautec"]:
 			pngname = findLcdPicon("lcd_picon_default")
 		else:
 			pngname = findLcdPicon("picon_default")
 		self.defaultpngname = None
 		if not pngname:
-			if getBoxType() in ('vuultimo', 'et10000', 'mutant2400', 'xpeedlx3', 'quadbox2400', 'sezammarvel', 'atemionemesis', 'mbultra', 'beyonwizt4', 'dm7020hd', 'dm7080') and not SystemInfo["grautec"]:
+			if getDisplayType() in ('bwlcd255', 'bwlcd140') and not SystemInfo["grautec"]:
 				tmp = resolveFilename(SCOPE_ACTIVE_SKIN, "lcd_picon_default.png")
 			else:
 				tmp = resolveFilename(SCOPE_ACTIVE_SKIN, "picon_default.png")
 			if pathExists(tmp):
 				pngname = tmp
 			else:
-				if getBoxType() in ('vuultimo', 'et10000', 'mutant2400', 'xpeedlx3', 'quadbox2400', 'sezammarvel', 'atemionemesis', 'mbultra', 'beyonwizt4', 'dm7020hd', 'dm7080') and not SystemInfo["grautec"]:
+				if getDisplayType() in ('bwlcd255', 'bwlcd140') and not SystemInfo["grautec"]:
 					pngname = resolveFilename(SCOPE_ACTIVE_SKIN, "lcd_picon_default.png")
 				else:
 					pngname = resolveFilename(SCOPE_ACTIVE_SKIN, "picon_default.png")
diff --git a/lib/python/Components/Renderer/Picon.py b/lib/python/Components/Renderer/Picon.py
index 6c9b313..662ad3c 100644
--- a/lib/python/Components/Renderer/Picon.py
+++ b/lib/python/Components/Renderer/Picon.py
@@ -171,6 +171,9 @@ class Picon(Renderer):
 					else:
 						self.instance.hide()
 					self.pngname = pngname
+			elif what[0] == 2:
+				self.pngname = ""
+				self.instance.hide()
 
 harddiskmanager.on_partition_list_change.append(onPartitionChange)
 initPiconPaths()
diff --git a/lib/python/Components/Renderer/VtiImageVersion.py b/lib/python/Components/Renderer/VtiImageVersion.py
index 97d0009..3337492 100644
--- a/lib/python/Components/Renderer/VtiImageVersion.py
+++ b/lib/python/Components/Renderer/VtiImageVersion.py
@@ -21,4 +21,4 @@ class VtiImageVersion(VariableText, Renderer):
 
     def ATVImageVersion(self):
         atvversion = getImageVersion()
-        return 'Open-Plus Image Release v. %s' % atvversion
\ No newline at end of file
+        return 'openATV Image Release v. %s' % atvversion
\ No newline at end of file
diff --git a/lib/python/Components/SetupDevices.py b/lib/python/Components/SetupDevices.py
index a1b842c..201b299 100644
--- a/lib/python/Components/SetupDevices.py
+++ b/lib/python/Components/SetupDevices.py
@@ -24,7 +24,12 @@ def InitSetupDevices():
 		language.activateLanguage(configElement.value)
 
 	config.osd = ConfigSubsection()
-	config.osd.language = ConfigText(default = "es_ES")
+	if getMachineBrand() in ('Vimastec'):
+		config.osd.language = ConfigText(default = "fr_FR")
+	elif getMachineBrand() in ('Zgemma','Beyonwiz') or getBrandOEM() in ('airdigital'):
+		config.osd.language = ConfigText(default = "en_US")
+	else:
+		config.osd.language = ConfigText(default = "de_DE")
 	config.osd.language.addNotifier(languageNotifier)
 
 	config.parental = ConfigSubsection()
diff --git a/lib/python/Components/Sources/CurrentService.py b/lib/python/Components/Sources/CurrentService.py
index c62e6fd..6d0e647 100644
--- a/lib/python/Components/Sources/CurrentService.py
+++ b/lib/python/Components/Sources/CurrentService.py
@@ -18,6 +18,7 @@ class CurrentService(PerServiceBase, Source):
 				iPlayableService.evNewProgramInfo: self.serviceEvent,
 				iPlayableService.evCuesheetChanged: self.serviceEvent,
 				iPlayableService.evVideoSizeChanged: self.serviceEvent,
+				iPlayableService.evVideoGammaChanged: self.serviceEvent,
 				iPlayableService.evHBBTVInfo: self.serviceEvent
 			}, with_event=True)
 		self.navcore = navcore
diff --git a/lib/python/Components/Sources/StaticText.py b/lib/python/Components/Sources/StaticText.py
index 8e6f824..530b85b 100644
--- a/lib/python/Components/Sources/StaticText.py
+++ b/lib/python/Components/Sources/StaticText.py
@@ -22,3 +22,8 @@ class StaticText(Source):
 		self.changed((self.CHANGED_ALL,))
 
 	text = property(getText, setText)
+
+	def getBoolean(self):
+		return bool(self.__text)
+
+	boolean = property(getBoolean)
diff --git a/lib/python/Components/SystemInfo.py b/lib/python/Components/SystemInfo.py
index ddc65b4..005bff0 100644
--- a/lib/python/Components/SystemInfo.py
+++ b/lib/python/Components/SystemInfo.py
@@ -5,7 +5,7 @@ from enigma import eDVBResourceManager, Misc_Options
 from Tools.Directories import fileExists, fileCheck
 from Tools.HardwareInfo import HardwareInfo
 
-from boxbranding import getBoxType, getMachineBuild
+from boxbranding import getBoxType, getMachineBuild, getDisplayType, getHaveRCA, getHaveDVI, getHaveYUV, getHaveSCART, getHaveAVJACK, getHaveSCARTYUV, getHaveHDMI
 
 SystemInfo = { }
 
@@ -31,10 +31,13 @@ def countFrontpanelLEDs():
 
 	return leds
 
+SystemInfo["FrontpanelDisplay"] = fileExists("/dev/dbox/oled0") or fileExists("/dev/dbox/lcd0")
+SystemInfo["7segment"] = getDisplayType() in ('7segment')
+SystemInfo["ConfigDisplay"] = SystemInfo["FrontpanelDisplay"] and getDisplayType() not in ('7segment')
+SystemInfo["LCDSKINSetup"] = path.exists("/usr/share/enigma2/display") and getDisplayType() not in ('7segment')
 SystemInfo["12V_Output"] = Misc_Options.getInstance().detected_12V_output()
 SystemInfo["ZapMode"] = fileCheck("/proc/stb/video/zapmode") or fileCheck("/proc/stb/video/zapping_mode")
 SystemInfo["NumFrontpanelLEDs"] = countFrontpanelLEDs()
-SystemInfo["FrontpanelDisplay"] = fileExists("/dev/dbox/oled0") or fileExists("/dev/dbox/lcd0")
 SystemInfo["OledDisplay"] = fileExists("/dev/dbox/oled0") or getBoxType() in ('osminiplus')
 SystemInfo["LcdDisplay"] = fileExists("/dev/dbox/lcd0")
 SystemInfo["FBLCDDisplay"] = fileCheck("/proc/stb/fb/sd_detach")
@@ -54,13 +57,12 @@ SystemInfo["HasExternalPIP"] = getMachineBuild() not in ('et9x00', 'et6x00', 'et
 SystemInfo["hasPIPVisibleProc"] = fileCheck("/proc/stb/vmpeg/1/visible")
 SystemInfo["VideoDestinationConfigurable"] = fileExists("/proc/stb/vmpeg/0/dst_left")
 SystemInfo["GBWOL"] = fileExists("/usr/bin/gigablue_wol")
-SystemInfo["LCDSKINSetup"] = path.exists("/usr/share/enigma2/display")
 SystemInfo["VFD_scroll_repeats"] = fileCheck("/proc/stb/lcd/scroll_repeats")
 SystemInfo["VFD_scroll_delay"] = fileCheck("/proc/stb/lcd/scroll_delay")
 SystemInfo["VFD_initial_scroll_delay"] = fileCheck("/proc/stb/lcd/initial_scroll_delay")
 SystemInfo["VFD_final_scroll_delay"] = fileCheck("/proc/stb/lcd/final_scroll_delay")
 SystemInfo["LCDMiniTV"] = fileExists("/proc/stb/lcd/mode")
-SystemInfo["LCDMiniTVPiP"] = SystemInfo["LCDMiniTV"] and getBoxType() != 'gb800ueplus'
+SystemInfo["LCDMiniTVPiP"] = SystemInfo["LCDMiniTV"] and getBoxType() not in ('gb800ueplus','gbquad4k','gbue4k')
 SystemInfo["LcdLiveTV"] = fileCheck("/proc/stb/fb/sd_detach") or fileCheck("/proc/stb/lcd/live_enable")
 SystemInfo["LcdLiveTVPiP"] = fileCheck("/proc/stb/lcd/live_decoder")
 SystemInfo["MiniTV"] = fileCheck("/proc/stb/fb/sd_detach") or fileCheck("/proc/stb/lcd/live_enable")
@@ -73,10 +75,13 @@ SystemInfo["CanUse3DModeChoices"] = fileExists('/proc/stb/fb/3dmode_choices') an
 SystemInfo["HaveMultiBoot"] = (fileCheck("/boot/STARTUP") or fileCheck("/boot/cmdline.txt"))
 SystemInfo["HaveMultiBootHD"] = fileCheck("/boot/STARTUP") and getMachineBuild() in ('hd51','vs1500','h7')
 SystemInfo["HaveMultiBootCY"] = fileCheck("/boot/STARTUP") and getMachineBuild() in ('8100s')
+SystemInfo["HaveMultiBootOS"] = fileCheck("/boot/STARTUP") and getMachineBuild() in ('osmio4k')
 SystemInfo["HaveMultiBootXC"] = fileCheck("/boot/cmdline.txt")
 SystemInfo["HaveMultiBootGB"] = fileCheck("/boot/STARTUP") and getMachineBuild() in ('gb7252')
+SystemInfo["HaveMultiBootDS"] = fileCheck("/boot/STARTUP") and getMachineBuild() in ('cc1','sf8008','sf8008s','ustym4kpro') and fileCheck("/dev/sda")
 SystemInfo["need_dsw"] = getBoxType() not in ('osminiplus','osmega')
 SystemInfo["HaveCISSL"] = fileCheck("/etc/ssl/certs/customer.pem") and fileCheck("/etc/ssl/certs/device.pem")
+SystemInfo["HaveID"] = fileCheck("/etc/.id")
 SystemInfo["HaveTouchSensor"] = getBoxType() in ('dm520', 'dm525', 'dm900', 'dm920')
 SystemInfo["DefaultDisplayBrightness"] = getBoxType() in ('dm900', 'dm920') and 8 or 5
 SystemInfo["RecoveryMode"] = fileCheck("/proc/stb/fp/boot_mode")
@@ -84,4 +89,11 @@ SystemInfo["ForceLNBPowerChanged"] = fileCheck("/proc/stb/frontend/fbc/force_lnb
 SystemInfo["ForceToneBurstChanged"] = fileCheck("/proc/stb/frontend/fbc/force_toneburst")
 SystemInfo["USETunersetup"] = SystemInfo["ForceLNBPowerChanged"] or SystemInfo["ForceToneBurstChanged"]
 SystemInfo["XcoreVFD"] = getMachineBuild() in ('xc7346','xc7439') 
-SystemInfo["HDMIin"] = getMachineBuild() in ('inihdp', 'hd2400', 'et10000', 'dm7080', 'dm820', 'dm900', 'dm920', 'vuultimo4k', 'et13000', 'sf5008', 'vuuno4kse') or getBoxType() in ('spycat4k','spycat4kcombo','gbquad4k')
+SystemInfo["HDMIin"] = getMachineBuild() in ('inihdp', 'hd2400', 'et10000', 'dm7080', 'dm820', 'dm900', 'dm920', 'vuultimo4k', 'et13000', 'sf5008', 'vuuno4kse', 'vuduo4k') or getBoxType() in ('spycat4k','spycat4kcombo','gbquad4k')
+SystemInfo["HaveRCA"] = getHaveRCA() in ('True')
+SystemInfo["HaveDVI"] = getHaveDVI() in ('True')
+SystemInfo["HaveAVJACK"] = getHaveAVJACK() in ('True')
+SystemInfo["HAVESCART"] = getHaveSCART() in ('True')
+SystemInfo["HAVESCARTYUV"] = getHaveSCARTYUV() in ('True')
+SystemInfo["HAVEYUV"] = getHaveYUV() in ('True')
+SystemInfo["HAVEHDMI"] = getHaveHDMI() in ('True')
diff --git a/lib/python/Components/Timeshift.py b/lib/python/Components/Timeshift.py
index d34e34f..1c317fe 100644
--- a/lib/python/Components/Timeshift.py
+++ b/lib/python/Components/Timeshift.py
@@ -47,7 +47,7 @@ from Tools.BoundFunction import boundFunction
 from Tools.Directories import pathExists, fileExists, getRecordingFilename, copyfile, resolveFilename, SCOPE_TIMESHIFT, SCOPE_AUTORECORD
 from Tools.TimeShift import CopyTimeshiftJob, MergeTimeshiftJob, CreateAPSCFilesJob
 
-from enigma import eBackgroundFileEraser, eTimer, eServiceCenter, iServiceInformation, iPlayableService, eEPGCache
+from enigma import eBackgroundFileEraser, eTimer, eServiceCenter, iServiceInformation, iPlayableService, eEPGCache, eServiceReference
 from boxbranding import getBoxType, getBrandOEM
 
 from time import time, localtime, strftime
@@ -65,7 +65,15 @@ class InfoBarTimeshift:
 				"timeshiftStart": (self.startTimeshift, _("Start timeshift")),  # the "yellow key"
 				"timeshiftStop": (self.stopTimeshift, _("Stop timeshift")),     # currently undefined :), probably 'TV'
 				"instantRecord": self.instantRecord,
-				"restartTimeshift": self.restartTimeshift
+				"restartTimeshift": self.restartTimeshift,
+				"seekFwdManual": (self.seekFwdManual, _("Seek forward (enter time)")),
+				"seekBackManual": (self.seekBackManual, _("Seek backward (enter time)")),
+				"seekdef:1": (boundFunction(self.seekdef,1), _("Seek")),
+				"seekdef:3": (boundFunction(self.seekdef,3), _("Seek")),
+				"seekdef:4": (boundFunction(self.seekdef,4), _("Seek")),
+				"seekdef:6": (boundFunction(self.seekdef,6), _("Seek")),
+				"seekdef:7": (boundFunction(self.seekdef,7), _("Seek")),
+				"seekdef:9": (boundFunction(self.seekdef,9), _("Seek"))
 			}, prio=1)
 		self["TimeshiftActivateActions"] = ActionMap(["InfobarTimeshiftActivateActions"],
 			{
@@ -376,6 +384,16 @@ class InfoBarTimeshift:
 						self.event_changed = True
 					self.pts_delay_timer.start(1000, True)
 
+	def seekdef(self, key):
+		if self.seekstate == self.SEEK_STATE_PLAY:
+			return 0 # trade as unhandled action
+		time = (-config.seek.selfdefined_13.value, False, config.seek.selfdefined_13.value,
+			-config.seek.selfdefined_46.value, False, config.seek.selfdefined_46.value,
+			-config.seek.selfdefined_79.value, False, config.seek.selfdefined_79.value)[key-1]
+		self.doSeekRelative(time * 90000)
+		self.pvrStateDialog.show()
+		return 1
+
 	def getTimeshift(self):
 		if self.ts_disabled or self.pts_delay_timer.isActive():
 			return None
@@ -387,11 +405,28 @@ class InfoBarTimeshift:
 		ts = self.getTimeshift()
 		return ts and ts.isTimeshiftEnabled()
 
+	def playpauseService2(self):
+		service = self.session.nav.getCurrentService()
+		playingref = self.session.nav.getCurrentlyPlayingServiceReference()
+		if not playingref or playingref.type < eServiceReference.idUser:
+			return 0
+		if service and service.streamed():
+			pauseable = service.pause()
+			if pauseable:
+				if self.seekstate == self.SEEK_STATE_PLAY:
+					pauseable.pause()
+					self.seekstate = self.SEEK_STATE_PAUSE
+				else:
+					pauseable.unpause()
+					self.seekstate = self.SEEK_STATE_PLAY
+				return
+		return 0
+
 	def startTimeshift(self):
 		ts = self.getTimeshift()
 		if ts is None:
 			# self.session.open(MessageBox, _("Timeshift not possible!"), MessageBox.TYPE_ERROR, timeout=5)
-			return 0
+			return self.playpauseService2()
 
 		if ts.isTimeshiftEnabled():
 			print "[TIMESHIFT] - hu, timeshift already enabled?"
@@ -936,11 +971,13 @@ class InfoBarTimeshift:
 
 	def ptsEventCleanTimerSTART(self):
 		if not self.pts_cleanEvent_timer.isActive() and int(config.timeshift.timeshiftCheckEvents.value):
-			self.pts_cleanEvent_timer.start(60000*int(config.timeshift.timeshiftCheckEvents.value), False)
+			#self.pts_cleanEvent_timer.start(60000*int(config.timeshift.timeshiftCheckEvents.value), False)
+			self.pts_cleanEvent_timer.startLongTimer(60*int(config.timeshift.timeshiftCheckEvents.value))
 			print "[TIMESHIFT] - 'cleanEvent_timer' is starting"
 
 	def ptsEventCleanTimeshiftFolder(self):
 		print "[TIMESHIFT] - 'cleanEvent_timer' is running"
+		self.ptsEventCleanTimerSTART()
 		self.ptsCleanTimeshiftFolder(justZapped = False)
 
 	def ptsCleanTimeshiftFolder(self, justZapped = True):
diff --git a/lib/python/Components/TuneTest.py b/lib/python/Components/TuneTest.py
index 96f7ba1..6fa1fa5 100644
--- a/lib/python/Components/TuneTest.py
+++ b/lib/python/Components/TuneTest.py
@@ -25,7 +25,7 @@ class Tuner:
 				parm.pls_mode = transponder[11]
 				parm.pls_code = transponder[12]
 			else:
-				parm.is_id = 0 #-1
+				parm.is_id = eDVBFrontendParametersSatellite.No_Stream_Id_Filter
 				parm.pls_mode = 0
 				parm.pls_code = 1
 			self.tuneSatObj(parm)
diff --git a/lib/python/Components/UsageConfig.py b/lib/python/Components/UsageConfig.py
index 264154d..2f85b80 100755
--- a/lib/python/Components/UsageConfig.py
+++ b/lib/python/Components/UsageConfig.py
@@ -10,7 +10,7 @@ from Components.NimManager import nimmanager
 from Components.ServiceList import refreshServiceList
 from SystemInfo import SystemInfo
 from Tools.HardwareInfo import HardwareInfo
-from boxbranding import getBoxType
+from boxbranding import getBoxType, getDisplayType
 from keyids import KEYIDS
 from sys import maxint
 import glob
@@ -60,10 +60,10 @@ def InitUsageConfig():
 	config.usage.boot_action = ConfigSelection(default = "normal", choices = [("normal", _("just boot")), ("standby", _("goto standby"))])
 	config.usage.showdish = ConfigSelection(default = "flashing", choices = [("flashing", _("Flashing")), ("normal", _("Not Flashing")), ("off", _("Off"))])
 	config.usage.multibouquet = ConfigYesNo(default = True)
-	config.usage.maxchannelnumlen = ConfigSelection(default = "4", choices = [("4", _("4")), ("5", _("5"))])
+	config.usage.maxchannelnumlen = ConfigSelection(default = "4", choices = [("1", _("1")), ("2", _("2")),("3", _("3")), ("4", _("4")), ("5", _("5"))])
 	config.usage.numzaptimeoutmode = ConfigSelection(default = "standard", choices = [("standard", _("Standard")), ("userdefined", _("User defined")), ("off", _("off"))])
-	config.usage.numzaptimeout1 = ConfigSlider(default = 3000, increment = 250, limits = (750, 5000))
-	config.usage.numzaptimeout2 = ConfigSlider(default = 1000, increment = 250, limits = (750, 5000))
+	config.usage.numzaptimeout1 = ConfigSlider(default = 3000, increment = 250, limits = (500, 5000))
+	config.usage.numzaptimeout2 = ConfigSlider(default = 1000, increment = 250, limits = (0, 5000))
 	config.usage.numzappicon = ConfigYesNo(default = False)
 	config.usage.use_pig = ConfigYesNo(default = False)
 	config.usage.update_available = NoSave(ConfigYesNo(default = False))
@@ -88,10 +88,11 @@ def InitUsageConfig():
 
 	# just merge note, config.usage.servicelist_column was allready there
 	choicelist = [("-1", _("Disable")), ("0", _("Eventname only"))]
-	for i in range(100,1300,100):
+	for i in range(100,1325,25):
 		choicelist.append(("%d" % i, ngettext("%d pixel wide", "%d pixels wide", i) % i))
 	config.usage.servicelist_column = ConfigSelection(default="-1", choices=choicelist)
 	config.usage.servicelist_column.addNotifier(refreshServiceList)
+	config.usage.servicelist_infokey = ConfigSelection(default = "event", choices = [("epg", _("Single EPG")), ("event", _("Eventview"))])
 
 	config.usage.service_icon_enable = ConfigYesNo(default = False)
 	config.usage.service_icon_enable.addNotifier(refreshServiceList)
@@ -117,10 +118,10 @@ def InitUsageConfig():
 	config.usage.panicbutton = ConfigYesNo(default = False)
 	config.usage.panicchannel = ConfigInteger(default = 1, limits=(1,5000) )
 	config.usage.quickzap_bouquet_change = ConfigYesNo(default = False)
-	config.usage.e1like_radio_mode = ConfigYesNo(default = False)
+	config.usage.e1like_radio_mode = ConfigYesNo(default = True)
 
 	choicelist = []
-	for i in range(1, 30):
+	for i in range(1, 21):
 		choicelist.append(("%d" % i, ngettext("%d second", "%d seconds", i) % i))
 	config.usage.infobar_timeout = ConfigSelection(default = "5", choices = [("0", _("No timeout"))] + choicelist)
 	config.usage.show_infobar_on_zap = ConfigYesNo(default = True)
@@ -132,7 +133,7 @@ def InitUsageConfig():
 	config.usage.show_infobar_do_dimming = ConfigYesNo(default = False)
 	config.usage.show_infobar_dimming_speed = ConfigSelectionNumber(min = 1, max = 40, stepwidth = 1, default = 10, wraparound = True)
 	config.usage.show_infobar_channel_number = ConfigYesNo(default = False)
-	config.usage.show_second_infobar = ConfigSelection(default = "2", choices = [("0", _("Off")), ("1", _("Event Info")), ("2", _("2nd Infobar INFO")), ("3", _("2nd Infobar ECM"))])
+	config.usage.show_second_infobar = ConfigSelection(default = "1", choices = [("0", _("Off")), ("1", _("Event Info")), ("2", _("2nd Infobar INFO")), ("3", _("2nd Infobar ECM"))])
 	config.usage.second_infobar_timeout = ConfigSelection(default = "5", choices = [("0", _("No timeout"))] + choicelist)
 	def showsecondinfobarChanged(configElement):
 		if config.usage.show_second_infobar.value != "INFOBAREPG":
@@ -311,7 +312,7 @@ def InitUsageConfig():
 	choicelist = [("standby", _("Standby")),("deepstandby", _("Deep Standby"))]
 	config.usage.sleep_timer_action = ConfigSelection(default = "deepstandby", choices = choicelist)
 	choicelist = [("0", _("Disabled")),("event_standby", _("Execute after current event"))]
-	for i in range(900, 7201, 900):
+	for i in range(900, 14401, 900):
 		m = abs(i / 60)
 		m = ngettext("%d minute", "%d minutes", m) % m
 		choicelist.append((str(i), _("Execute in ") + m))
@@ -390,7 +391,7 @@ def InitUsageConfig():
 	config.usage.servicenum_fontsize = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
 	config.usage.servicename_fontsize = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
 	config.usage.serviceinfo_fontsize = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
-	config.usage.serviceitems_per_page = ConfigSelectionNumber(default = 16, stepwidth = 1, min = 8, max = 40, wraparound = True)
+	config.usage.serviceitems_per_page = ConfigSelectionNumber(default = 18, stepwidth = 1, min = 8, max = 40, wraparound = True)
 	config.usage.show_servicelist = ConfigYesNo(default = True)
 	config.usage.servicelist_mode = ConfigSelection(default = "standard", choices = [
 		("standard", _("Standard")),
@@ -437,15 +438,33 @@ def InitUsageConfig():
 	config.usage.show_event_progress_in_servicelist.addNotifier(refreshServiceList)
 	config.usage.show_channel_numbers_in_servicelist.addNotifier(refreshServiceList)
 
-	config.usage.blinking_display_clock_during_recording = ConfigYesNo(default = False)
-	
-	if getBoxType() in ('tiviaraplus','formuler1tc','zgemmah7','vimastec1000', 'vimastec1500','et7000', 'et7500', 'et8000', 'triplex', 'formuler1', 'mutant1200', 'solo2', 'mutant1265', 'mutant1100', 'mutant500c', 'mutant530c', 'mutant1500', 'osminiplus', 'ax51', 'mutant51', '9910lx', '9911lx'):
+	#standby
+	if getDisplayType() in ('textlcd7segment'):
+		config.usage.blinking_display_clock_during_recording = ConfigSelection(default = "Rec", choices = [
+						("Rec", _("REC")), 
+						("RecBlink", _("Blinking REC")), 
+						("Nothing", _("Nothing"))])
+	else:
+		config.usage.blinking_display_clock_during_recording = ConfigYesNo(default = False)
+		
+	#in use
+	if getDisplayType() in ('textlcd'):
 		config.usage.blinking_rec_symbol_during_recording = ConfigSelection(default = "Channel", choices = [
 						("Rec", _("REC Symbol")), 
 						("RecBlink", _("Blinking REC Symbol")), 
 						("Channel", _("Channelname"))])
+	if getDisplayType() in ('textlcd7segment'):
+		config.usage.blinking_rec_symbol_during_recording = ConfigSelection(default = "Rec", choices = [
+						("Rec", _("REC")), 
+						("RecBlink", _("Blinking REC")), 
+						("Time", _("Time"))])
 	else:
 		config.usage.blinking_rec_symbol_during_recording = ConfigYesNo(default = True)
+		
+	if getDisplayType() in ('textlcd7segment'):
+		config.usage.show_in_standby = ConfigSelection(default = "time", choices = [
+						("time", _("Time")), 
+						("nothing", _("Nothing"))])
 
 	config.usage.show_message_when_recording_starts = ConfigYesNo(default = True)
 
@@ -730,12 +749,25 @@ def InitUsageConfig():
 
 	crashlogheader = _("We are really sorry. Your receiver encountered " \
 					 "a software problem, and needs to be restarted.\n" \
-					 "Please send the logfile %senigma2_crash_xxxxxx.log to www.open-plus.es.\n" \
+					 "Please send the logfile %senigma2_crash_xxxxxx.log to www.opena.tv.\n" \
 					 "Your receiver restarts in 10 seconds!\n" \
 					 "Component: enigma2") % config.crash.debug_path.value
 	config.crash.debug_text = ConfigText(default=crashlogheader, fixed_size=False)
 	config.crash.skin_error_crash = ConfigYesNo(default = True)
 
+	def updateStackTracePrinter(configElement):
+		from Components.StackTrace import StackTracePrinter
+		if configElement.value:
+			if (os.path.isfile("/tmp/doPythonStackTrace")):
+				os.remove("/tmp/doPythonStackTrace")
+			from threading import current_thread
+			StackTracePrinter.getInstance().activate(current_thread().ident)
+		else:
+			StackTracePrinter.getInstance().deactivate()
+
+	config.crash.pystackonspinner = ConfigYesNo(default = True)
+	config.crash.pystackonspinner.addNotifier(updateStackTracePrinter, immediate_feedback = False, call_on_save_or_cancel = True, initial_call = True)
+
 	config.usage.timerlist_finished_timer_position = ConfigSelection(default = "end", choices = [("beginning", _("at beginning")), ("end", _("at end"))])
 	config.usage.timerlist_show_epg = ConfigYesNo(default = True)
 
@@ -792,7 +824,7 @@ def InitUsageConfig():
 	config.subtitles.subtitle_fontsize  = ConfigSelection(choices = ["%d" % x for x in range(16,101) if not x % 2], default = "40")
 
 	subtitle_delay_choicelist = []
-	for i in range(-900000, 1845000, 45000):
+	for i in range(-54000000, 54045000, 45000):
 		if i == 0:
 			subtitle_delay_choicelist.append(("0", _("No delay")))
 		else:
@@ -801,7 +833,7 @@ def InitUsageConfig():
 
 	config.subtitles.dvb_subtitles_yellow = ConfigYesNo(default = False)
 	config.subtitles.dvb_subtitles_original_position = ConfigSelection(default = "0", choices = [("0", _("Original")), ("1", _("Fixed")), ("2", _("Relative"))])
-	config.subtitles.dvb_subtitles_centered = ConfigYesNo(default = True)
+	config.subtitles.dvb_subtitles_centered = ConfigYesNo(default = False)
 	config.subtitles.subtitle_bad_timing_delay = ConfigSelection(default = "0", choices = subtitle_delay_choicelist)
 	config.subtitles.dvb_subtitles_backtrans = ConfigSelection(default = "0", choices = [
 		("0", _("No transparency")),
@@ -853,6 +885,7 @@ def InitUsageConfig():
 		("ell gre", _("Greek")),
 		("heb", _("Hebrew")),
 		("hun", _("Hungarian")),
+		("ind", _("Indonesian")),
 		("ita", _("Italian")),
 		("lav", _("Latvian")),
 		("lit", _("Lithuanian")),
@@ -927,8 +960,9 @@ def InitUsageConfig():
 					("pliepg", _("Show Graphical EPG")),
 					("single", _("Show Single EPG")),
 					("multi", _("Show Multi EPG")),
+					("vertical", _("Show Vertical EPG")),
 					("eventview", _("Show Eventview")),
-					("merlinepgcenter", _("Show Merlin EPG Center")),
+#					("merlinepgcenter", _("Show Merlin EPG Center")),
 					("cooltvguide", _("Show CoolTVGuide"))])
 		config.plisettings.PLIINFO_mode = ConfigSelection(default="coolinfoguide", choices = [
 					("eventview", _("Show Eventview")),
@@ -942,6 +976,7 @@ def InitUsageConfig():
 					("pliepg", _("Show Graphical EPG")),
 					("single", _("Show Single EPG")),
 					("multi", _("Show Multi EPG")),
+					("vertical", _("Show Vertical EPG")),
 					("eventview", _("Show Eventview")),
 					("merlinepgcenter", _("Show Merlin EPG Center"))])
 		config.plisettings.PLIINFO_mode = ConfigSelection(default="eventview", choices = [
@@ -965,13 +1000,14 @@ def InitUsageConfig():
 	config.epgselection.infobar_prevtimeperiod = ConfigSelection(default = "180", choices = [("60", _("%d minutes") % 60), ("90", _("%d minutes") % 90), ("120", _("%d minutes") % 120), ("150", _("%d minutes") % 150), ("180", _("%d minutes") % 180), ("210", _("%d minutes") % 210), ("240", _("%d minutes") % 240), ("270", _("%d minutes") % 270), ("300", _("%d minutes") % 300)])
 	config.epgselection.infobar_primetimehour = ConfigSelectionNumber(default = 20, stepwidth = 1, min = 00, max = 23, wraparound = True)
 	config.epgselection.infobar_primetimemins = ConfigSelectionNumber(default = 00, stepwidth = 1, min = 00, max = 59, wraparound = True)
-	config.epgselection.infobar_servicetitle_mode = ConfigSelection(default = "servicename", choices = [("servicename", _("Service Name")),("picon", _("Picon")),("picon+servicename", _("Picon and Service Name")) ])
+	#config.epgselection.infobar_servicetitle_mode = ConfigSelection(default = "servicename", choices = [("servicename", _("Service Name")),("picon", _("Picon")),("picon+servicename", _("Picon and Service Name")) ])
+	config.epgselection.infobar_servicetitle_mode = ConfigSelection(default = "picon+servicename", choices = [("servicename", _("Service Name")),("picon", _("Picon")),("servicenumber+picon+servicename", _("Service Number, Picon and Service Name")),("servicenumber+servicename", _("Service Number and Service Name")),("picon+servicename", _("Picon and Service Name")) ])
 	config.epgselection.infobar_servfs = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
 	config.epgselection.infobar_eventfs = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
-	config.epgselection.infobar_timelinefs = ConfigSelectionNumber(default = -8, stepwidth = 1, min = -8, max = 10, wraparound = True)
+	config.epgselection.infobar_timelinefs = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
 	config.epgselection.infobar_timeline24h = ConfigYesNo(default = True)
 	config.epgselection.infobar_servicewidth = ConfigSelectionNumber(default = 250, stepwidth = 1, min = 70, max = 500, wraparound = True)
-	config.epgselection.infobar_piconwidth = ConfigSelectionNumber(default = 100, stepwidth = 1, min = 70, max = 500, wraparound = True)
+	config.epgselection.infobar_piconwidth = ConfigSelectionNumber(default = 100, stepwidth = 1, min = 50, max = 500, wraparound = True)
 	config.epgselection.infobar_infowidth = ConfigSelectionNumber(default = 25, stepwidth = 25, min = 0, max = 150, wraparound = True)
 	config.epgselection.enhanced_preview_mode = ConfigYesNo(default = True)
 	config.epgselection.enhanced_ok = ConfigSelection(choices = [("Zap",_("Zap")), ("Zap + Exit", _("Zap + Exit"))], default = "Zap")
@@ -996,7 +1032,7 @@ def InitUsageConfig():
 	config.epgselection.graph_prevtimeperiod = ConfigSelection(default = "180", choices = [("60", _("%d minutes") % 60), ("90", _("%d minutes") % 90), ("120", _("%d minutes") % 120), ("150", _("%d minutes") % 150), ("180", _("%d minutes") % 180), ("210", _("%d minutes") % 210), ("240", _("%d minutes") % 240), ("270", _("%d minutes") % 270), ("300", _("%d minutes") % 300)])
 	config.epgselection.graph_primetimehour = ConfigSelectionNumber(default = 20, stepwidth = 1, min = 00, max = 23, wraparound = True)
 	config.epgselection.graph_primetimemins = ConfigSelectionNumber(default = 00, stepwidth = 1, min = 00, max = 59, wraparound = True)
-	config.epgselection.graph_servicetitle_mode = ConfigSelection(default = "picon+servicename", choices = [("servicename", _("Service Name")),("picon", _("Picon")),("picon+servicename", _("Picon and Service Name")) ])
+	config.epgselection.graph_servicetitle_mode = ConfigSelection(default = "picon+servicename", choices = [("servicename", _("Service Name")),("picon", _("Picon")),("servicenumber+picon+servicename", _("Service Number, Picon and Service Name")),("servicenumber+servicename", _("Service Number and Service Name")),("picon+servicename", _("Picon and Service Name")) ])
 	config.epgselection.graph_startmode = ConfigSelection(default = "standard", choices = [("standard", _("Standard")), ("primetime", _("Primetime")),("channel1", _("Channel 1")), ("channel1+primetime", _("Channel 1 with Primetime")) ])
 	config.epgselection.graph_servfs = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
 	config.epgselection.graph_eventfs = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
@@ -1009,13 +1045,13 @@ def InitUsageConfig():
 		( str(RT_HALIGN_RIGHT | RT_VALIGN_CENTER | RT_WRAP) , _("right, wrapped"))]
 	config.epgselection.graph_event_alignment = ConfigSelection(default = possibleAlignmentChoices[0][0], choices = possibleAlignmentChoices)
 	config.epgselection.graph_servicename_alignment = ConfigSelection(default = possibleAlignmentChoices[0][0], choices = possibleAlignmentChoices)
-	config.epgselection.graph_timelinefs = ConfigSelectionNumber(default = -8, stepwidth = 1, min = -8, max = 10, wraparound = True)
+	config.epgselection.graph_timelinefs = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -8, max = 10, wraparound = True)
 	config.epgselection.graph_timeline24h = ConfigYesNo(default = True)
 	config.epgselection.graph_itemsperpage = ConfigSelectionNumber(default = 8, stepwidth = 1, min = 3, max = 20, wraparound = True)
-	config.epgselection.graph_pig = ConfigYesNo(default = True)
+	config.epgselection.graph_pig = ConfigYesNo(default = False)
 	config.epgselection.graph_heightswitch = NoSave(ConfigYesNo(default = False))
 	config.epgselection.graph_servicewidth = ConfigSelectionNumber(default = 250, stepwidth = 1, min = 70, max = 500, wraparound = True)
-	config.epgselection.graph_piconwidth = ConfigSelectionNumber(default = 100, stepwidth = 1, min = 70, max = 500, wraparound = True)
+	config.epgselection.graph_piconwidth = ConfigSelectionNumber(default = 100, stepwidth = 1, min = 50, max = 500, wraparound = True)
 	config.epgselection.graph_infowidth = ConfigSelectionNumber(default = 25, stepwidth = 25, min = 0, max = 150, wraparound = True)
 	config.epgselection.graph_rec_icon_height = ConfigSelection(choices = [("bottom",_("bottom")),("top", _("top")), ("middle", _("middle")),  ("hide", _("hide"))], default = "bottom")
 
@@ -1034,6 +1070,40 @@ def InitUsageConfig():
 	config.epgselection.graph_yellow = ConfigSelection(default='epgsearch',choices=epg_colorkeys)
 	config.epgselection.graph_blue = ConfigSelection(default='autotimer', choices=epg_colorkeys)
 
+	config.epgselection.vertical_itemsperpage = ConfigSelectionNumber(default = 6, stepwidth = 1, min = 3, max = 12, wraparound = True)
+	config.epgselection.vertical_eventfs = ConfigSelectionNumber(default = 0, stepwidth = 1, min = -10, max = 10, wraparound = True)
+	config.epgselection.vertical_ok = ConfigSelection(choices = [("Channel Info", _("Channel Info")),("Zap",_("Zap")), ("Zap + Exit", _("Zap + Exit"))], default = "Channel Info")
+	config.epgselection.vertical_oklong = ConfigSelection(choices = [("Channel Info", _("Channel Info")),("Zap",_("Zap")), ("Zap + Exit", _("Zap + Exit"))], default = "Zap + Exit")
+	config.epgselection.vertical_info = ConfigSelection(choices = [("Channel Info", _("Channel Info")), ("Single EPG", _("Single EPG"))], default = "Channel Info")
+	config.epgselection.vertical_infolong = ConfigSelection(choices = [("Channel Info", _("Channel Info")), ("Single EPG", _("Single EPG"))], default = "Single EPG")
+	config.epgselection.vertical_channelbtn = ConfigSelection(choices = [("page", _("previous/next Page")), ("scroll", _("all up/down")), ("24", _("-24h/+24 Hours"))], default = "page")
+	config.epgselection.vertical_channelbtn_invert = ConfigYesNo(default = False)
+	config.epgselection.vertical_updownbtn = ConfigYesNo(default = True)
+	config.epgselection.vertical_primetimehour = ConfigSelectionNumber(default = 20, stepwidth = 1, min = 00, max = 23, wraparound = True)
+	config.epgselection.vertical_primetimemins = ConfigSelectionNumber(default = 15, stepwidth = 1, min = 00, max = 59, wraparound = True)
+	config.epgselection.vertical_preview_mode = ConfigYesNo(default = True)
+	config.epgselection.vertical_pig = ConfigYesNo(default = False)
+	config.epgselection.vertical_eventmarker = ConfigYesNo(default = False)
+	config.epgselection.vertical_showlines = ConfigYesNo(default = True)
+	config.epgselection.vertical_startmode = ConfigSelection(default = "standard", choices = [("standard", _("Standard")), ("primetime", _("Primetime")),("channel1", _("Channel 1")), ("channel1+primetime", _("Channel 1 with Primetime")) ])
+	config.epgselection.vertical_prevtime = ConfigClock(default = time())
+	vertical_colorkeys = [('autotimer', _('Auto Timer')),
+					('timer', _('Add/Remove Timer')),
+					('24plus', _('24+ Hours')),
+					('24minus', _('24- Hours')),
+					('imdb', _('IMDB search')),
+					('bouquetlist', _('Bouquet List')),
+					('showmovies', _('Show Movies List')),
+					('record', _('Record - same as record button')),
+					('gotodatetime', _('Goto Date/Timer')),
+					('gotoprimetime', _('Goto Primetime')),
+					('setbasetime', _('Set Basetime')),
+					('epgsearch', _('EPG search'))]
+	config.epgselection.vertical_red = ConfigSelection(default='imdb', choices=vertical_colorkeys)
+	config.epgselection.vertical_green = ConfigSelection(default='timer', choices=vertical_colorkeys)
+	config.epgselection.vertical_yellow = ConfigSelection(default='epgsearch',choices=vertical_colorkeys)
+	config.epgselection.vertical_blue = ConfigSelection(default='autotimer', choices=vertical_colorkeys)
+
 	config.oscaminfo = ConfigSubsection()
 	config.oscaminfo.showInExtensions = ConfigYesNo(default=False)
 	config.oscaminfo.userdatafromconf = ConfigYesNo(default = True)
diff --git a/lib/python/Components/VfdSymbols.py b/lib/python/Components/VfdSymbols.py
index 08a0fe6..5d5d2f3 100644
--- a/lib/python/Components/VfdSymbols.py
+++ b/lib/python/Components/VfdSymbols.py
@@ -13,7 +13,7 @@ POLLTIME = 5 # seconds
 
 def SymbolsCheck(session, **kwargs):
 		global symbolspoller, POLLTIME
-		if getBoxType() in ('osnino','osninoplus','tmtwin4k','mbmicrov2','revo4k','force3uhd','wetekplay', 'wetekplay2', 'wetekhub', 'ixussone', 'ixusszero', 'mbmicro', 'e4hd', 'e4hdhybrid', 'dm7020hd', 'dm7020hdv2', '9910lx', '9911lx') or getMachineBuild() in ('dags7362' , 'dags73625', 'dags5'):
+		if getBoxType() in ('ustym4kpro','sf8008','sf8008s','clap4k','alien5','osninopro','osnino','osninoplus','tmtwin4k','mbmicrov2','revo4k','force3uhd','wetekplay', 'wetekplay2', 'wetekhub', 'ixussone', 'ixusszero', 'mbmicro', 'e4hd', 'e4hdhybrid', 'dm7020hd', 'dm7020hdv2', '9910lx', '9911lx', '9920lx') or getMachineBuild() in ('dags7362' , 'dags73625', 'dags5'):
 			POLLTIME = 1
 		symbolspoller = SymbolsCheckPoller(session)
 		symbolspoller.start()
@@ -72,7 +72,7 @@ class SymbolsCheckPoller:
 				open("/proc/stb/lcd/symbol_recording", "w").write("1")
 			else:
 				open("/proc/stb/lcd/symbol_recording", "w").write("0")
-		elif getBoxType() in ('wetekplay', 'wetekplay2', 'wetekhub', 'ixussone', 'ixusszero', '9910lx', '9911lx', 'osnino', 'osninoplus'):
+		elif getBoxType() in ('alien5','osninopro','wetekplay', 'wetekplay2', 'wetekhub', 'ixussone', 'ixusszero', '9910lx', '9911lx', 'osnino', 'osninoplus', '9920lx'):
 			recordings = len(NavigationInstance.instance.getRecordings(False,Components.RecordingConfig.recType(config.recording.show_rec_symbol_for_rec_types.getValue())))
 			self.blink = not self.blink
 			if recordings > 0:
@@ -120,6 +120,15 @@ class SymbolsCheckPoller:
 					self.led = "0"
 			elif self.led == "1":
 				open("/proc/stb/lcd/symbol_rec", "w").write("0")
+		elif getBoxType() in ('sf8008','sf8008s','clap4k','ustym4kpro'):
+			import Screens.Standby
+			recordings = len(NavigationInstance.instance.getRecordings(False,Components.RecordingConfig.recType(config.recording.show_rec_symbol_for_rec_types.getValue())))
+			if recordings > 0:
+				open("/proc/stb/fp/mixerled", "w").write("on")
+			elif not Screens.Standby.inStandby:
+				open("/proc/stb/fp/poweronled", "w").write("on")
+			elif Screens.Standby.inStandby:
+				open("/proc/stb/fp/standbyled", "w").write("on")
 
 		else:
 			if not fileExists("/proc/stb/lcd/symbol_recording") or not fileExists("/proc/stb/lcd/symbol_record_1") or not fileExists("/proc/stb/lcd/symbol_record_2"):
diff --git a/lib/python/Components/VolumeControl.py b/lib/python/Components/VolumeControl.py
index 0dc9f29..01e4af9 100644
--- a/lib/python/Components/VolumeControl.py
+++ b/lib/python/Components/VolumeControl.py
@@ -39,6 +39,7 @@ class VolumeControl:
 		self.volumeDialog.setValue(vol)
 		self.volctrl = eDVBVolumecontrol.getInstance()
 		self.volctrl.setVolume(vol, vol)
+		self.last_vol = vol
 
 	def volSave(self):
 		if self.volctrl.isMuted():
@@ -113,6 +114,7 @@ class VolumeControl:
 		self.volctrl.setVolume(newvol, newvol)
 		is_muted = self.volctrl.isMuted()
 		vol = self.volctrl.getVolume()
+		self.last_vol = vol
 		self.volumeDialog.show()
 		if is_muted:
 			self.volMute() # unmute
@@ -127,7 +129,14 @@ class VolumeControl:
 
 	def volHide(self):
 		self.volumeDialog.hide()
-		self.muteDialog.hide()
+		#//set volume on if muted and volume is changed in webif
+		vol = self.volctrl.getVolume()
+		if self.volctrl.isMuted() and self.last_vol != vol:
+			self.volctrl.volumeUnMute()
+		self.last_vol = vol
+		#//
+		if not self.volctrl.isMuted() or config.av.volume_hide_mute.value:
+			self.muteDialog.hide()
 
 	def showMute(self):
 		if self.volctrl.isMuted():
diff --git a/lib/python/Components/config.py b/lib/python/Components/config.py
index 39347e6..59190d7 100644
--- a/lib/python/Components/config.py
+++ b/lib/python/Components/config.py
@@ -616,7 +616,7 @@ class ConfigSequence(ConfigElement):
 			# position in the block
 			posinblock = self.marked_pos - block_len_total[blocknumber]
 
-			oldvalue = self._value[blocknumber]
+			oldvalue = abs(self._value[blocknumber]) # we are using abs in order to allow change negative values like default -1 on mis
 			olddec = oldvalue % 10 ** (number_len - posinblock) - (oldvalue % 10 ** (number_len - posinblock - 1))
 			newvalue = oldvalue - olddec + (10 ** (number_len - posinblock - 1) * number)
 
diff --git a/lib/python/Plugins/Extensions/CutListEditor/keymap.xml b/lib/python/Plugins/Extensions/CutListEditor/keymap.xml
index 8e554d2..115e66f 100644
--- a/lib/python/Plugins/Extensions/CutListEditor/keymap.xml
+++ b/lib/python/Plugins/Extensions/CutListEditor/keymap.xml
@@ -54,5 +54,6 @@
 		<key id="KEY_OK" mapto="showMenu" flags="m" />
 		<key id="KEY_ENTER" mapto="showMenu" flags="m" />
 		<key id="KEY_MENU" mapto="showMenu" flags="m" />
+		<key id="KEY_STOP" mapto="removeAll" flags="m" />
 	</map>
 </keymap>
diff --git a/lib/python/Plugins/Extensions/CutListEditor/plugin.py b/lib/python/Plugins/Extensions/CutListEditor/plugin.py
index 4e66c60..e08fb5a 100644
--- a/lib/python/Plugins/Extensions/CutListEditor/plugin.py
+++ b/lib/python/Plugins/Extensions/CutListEditor/plugin.py
@@ -54,12 +54,13 @@ class CutListContextMenu(FixedMenu):
 	RET_GRABFRAME = 7
 	RET_TOGGLEINTRO = 8
 	RET_MOVIECUT = 9
+	RET_REMOVEALL = 10
 
 	SHOW_STARTCUT = 0
 	SHOW_ENDCUT = 1
 	SHOW_DELETECUT = 2
 
-	def __init__(self, session, state, nearmark):
+	def __init__(self, session, state, nearmark, removeall=1):
 		menu = [(_("back"), self.close)] #, (None, )]
 
 		if state == self.SHOW_STARTCUT:
@@ -87,6 +88,11 @@ class CutListContextMenu(FixedMenu):
 		else:
 			menu.append((_("remove this mark"), self.removeMark))
 
+		if removeall:
+			menu.append((_("Remove all cuts and marks"), self.removeAll))
+		else:
+			menu.append((_("Remove all cuts and marks"), ))
+
 		menu.append((_("grab this frame as bitmap"), self.grabFrame))
 
 		if config.plugins.CutListEditor.showIntro.value:
@@ -120,6 +126,9 @@ class CutListContextMenu(FixedMenu):
 	def removeAfter(self):
 		self.close(self.RET_REMOVEAFTER)
 
+	def removeAll(self):
+		self.close(self.RET_REMOVEALL)
+
 	def grabFrame(self):
 		self.close(self.RET_GRABFRAME)
 		
@@ -198,6 +207,7 @@ class CutListEditor(Screen, InfoBarBase, InfoBarSeek, InfoBarCueSheetSupport, He
 				"setMark": (self.setMark, _("Make this mark just a mark")),
 				"addMark": (self.__addMark, _("Add a mark")),
 				"removeMark": (self.__removeMark, _("Remove a mark")),
+				"removeAll": (self.__removeAll, _("Remove all cuts and marks")),
 				"leave": (self.exit, _("Exit editor")),
 				"showMenu": (self.showMenu, _("menu")),
 			}, prio=-4)
@@ -217,6 +227,7 @@ class CutListEditor(Screen, InfoBarBase, InfoBarSeek, InfoBarCueSheetSupport, He
 		self.onClose.append(self.__onClose)
 
 	def __onClose(self):
+		self.crashFix()
 		self.session.nav.playService(self.old_service, forceRestart=True)
 
 	def updateStateLabel(self, state):
@@ -259,6 +270,15 @@ class CutListEditor(Screen, InfoBarBase, InfoBarSeek, InfoBarCueSheetSupport, He
 		if m is not None:
 			self.removeMark(m)
 
+	def __removeAll(self):
+		if len(self.cut_list):
+			self.session.openWithCallback(self.__removeAllCallback, MessageBox, _("Are you sure to delete all cuts and marks?"), default=False)
+
+	def __removeAllCallback(self, ret):
+		if ret:
+			self.cut_list = []
+			self.uploadCuesheet()
+
 	def exit(self):
 		self.close()
 
@@ -338,7 +358,7 @@ class CutListEditor(Screen, InfoBarBase, InfoBarSeek, InfoBarCueSheetSupport, He
 		else:
 			nearmark = True
 
-		self.session.openWithCallback(self.menuCallback, CutListContextMenu, state, nearmark)
+		self.session.openWithCallback(self.menuCallback, CutListContextMenu, state, nearmark, len(self.cut_list))
 
 	def menuCallback(self, *result):
 		if not len(result):
@@ -404,6 +424,8 @@ class CutListEditor(Screen, InfoBarBase, InfoBarSeek, InfoBarCueSheetSupport, He
 			self.inhibit_seek = True
 			self.uploadCuesheet()
 			self.inhibit_seek = False
+		elif result == CutListContextMenu.RET_REMOVEALL:
+			self.__removeAllCallback(True)
 		elif result == CutListContextMenu.RET_GRABFRAME:
 			self.grabFrame()
 		elif result == CutListContextMenu.RET_TOGGLEINTRO:
@@ -412,13 +434,21 @@ class CutListEditor(Screen, InfoBarBase, InfoBarSeek, InfoBarCueSheetSupport, He
 			self.inhibit_seek = True
 			self.uploadCuesheet()
 			self.inhibit_seek = False
-			self.session.nav.playService(self.old_service, forceRestart=True) #required for actually writing the .cuts file
+			cservice = self.session.nav.getCurrentlyPlayingServiceReference()
+			self.crashFix()
+			#self.session.nav.playService(self.old_service, forceRestart=True) #required for actually writing the .cuts file
+			self.session.nav.playService(cservice, forceRestart=True) #required for actually writing the .cuts file
 			self.pauseService()
 			try:
-				MovieCut(session=self.session, service=self.session.nav.getCurrentlyPlayingServiceReference())
+				MovieCut(session=self.session, service=cservice)
 			except:
 				print "[CutListEditor] calling MovieCut failed"
 
+	def crashFix(self):
+		# fix possible box freeze (e.g. OS1+)
+		if self.seekstate != self.SEEK_STATE_PLAY:
+			self.unPauseService()
+
 	# we modify the "play" behavior a bit:
 	# if we press pause while being in slowmotion, we will pause (and not play)
 	def playpauseService(self):
diff --git a/lib/python/Plugins/Extensions/Makefile.am b/lib/python/Plugins/Extensions/Makefile.am
index b345664..b9b7774 100644
--- a/lib/python/Plugins/Extensions/Makefile.am
+++ b/lib/python/Plugins/Extensions/Makefile.am
@@ -1,6 +1,6 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
-SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer SocketMMI DVDBurn Openpanel Volume_adjust ProgrammlistenUpdater
+SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer SocketMMI DVDBurn Infopanel Volume_adjust ProgrammlistenUpdater AtileHD
 
 if HAVE_LIBDDVD
 SUBDIRS += DVDPlayer
@@ -23,14 +23,18 @@ SUBDIRS += QuadPip
 endif
 
 if VUUNO4KSE
-SUBDIRS += QuadPip
+SUBDIRS += MiniTV QuadPip
+endif
+
+if VUDUO4K
+SUBDIRS += MiniTV QuadPip
 endif
 
 if S8100
 SUBDIRS += MiniTV
 endif
 
-if HAVE_WETEK_XBMC
+if HAVE_KODI
 SUBDIRS +=  StartKodi
 endif
 
diff --git a/lib/python/Plugins/Extensions/MediaPlayer/settings.py b/lib/python/Plugins/Extensions/MediaPlayer/settings.py
index 59dd761..20cfd5c 100644
--- a/lib/python/Plugins/Extensions/MediaPlayer/settings.py
+++ b/lib/python/Plugins/Extensions/MediaPlayer/settings.py
@@ -20,7 +20,7 @@ def Load_defaults():
 	config.mediaplayer.onMainMenu = ConfigYesNo(default=False)
 
 	config.mediaplayer.useAlternateUserAgent = NoSave(ConfigYesNo(default = False))
-	config.mediaplayer.alternateUserAgent = NoSave(ConfigText(default = "Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;OpenPlus;;;)"))
+	config.mediaplayer.alternateUserAgent = NoSave(ConfigText(default = "Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;openATV;;;)"))
 
 Load_defaults()
 
diff --git a/lib/python/Plugins/Extensions/Openpanel/CamCheck.py b/lib/python/Plugins/Extensions/Openpanel/CamCheck.py
deleted file mode 100644
index ddaeab1..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/CamCheck.py
+++ /dev/null
@@ -1,258 +0,0 @@
-from twisted.internet import threads
-from Components.config import config
-from enigma import eTimer, eConsoleAppContainer
-from os import system, listdir, path, popen
-from datetime import datetime
-
-isBusy = None
-CFG = "/usr/keys/CCcam.cfg"
-
-def CamCheck():
-    global campoller, POLLTIME
-    POLLTIME = int(config.plugins.openpanel_frozencheck.list.value) * 60
-    if campoller is None:
-        campoller = CamCheckPoller()
-    campoller.start()
-
-def CamCheckStop():
-    try:
-        campoller.stop()
-    except:
-        print"CamCheck not running, so no need to stop it !! "
-
-def confPath():
-	search_dirs = [ "/usr", "/var", "/etc" ]
-	sdirs = " ".join(search_dirs)
-	cmd = 'find %s -name "CCcam.cfg" | head -n 1' % sdirs
-	res = popen(cmd).read()
-	if res == "":
-		return None
-	else:
-		return res.replace("\n", "")
-
-def getConfigValue(l):
-	list = l.split(":")
-	ret = ""
-
-	if len(list) > 1:
-		ret = (list[1]).replace("\n", "").replace("\r", "")
-		if ret.__contains__("#"):
-			idx = ret.index("#")
-			ret = ret[:idx]
-		while ret.startswith(" "):
-			ret = ret[1:]
-		while ret.endswith(" "):
-			ret = ret[:-1]
-
-	return ret
-
-class CamCheckPoller:
-    def __init__(self):
-        self.timer = eTimer()
-        self.onClose = []
-
-    def start(self):
-        global isBusy
-        if isBusy:
-            return
-        isBusy = True
-        if self.camcheck not in self.timer.callback:
-            self.timer.callback.append(self.camcheck)
-        self.timer.startLongTimer(60)
-
-    def stop(self):
-        global isBusy
-        if self.camcheck in self.timer.callback:
-            self.timer.callback.remove(self.camcheck)
-        self.timer.stop()
-        isBusy = None
-
-    def camcheck(self):
-        global isBusy
-        isBusy = True
-        threads.deferToThread(self.JobTask)
-        self.timer.startLongTimer(POLLTIME)
-
-    def JobTask(self):
-        self.doCheck()
-        self.timer.startLongTimer(POLLTIME)
-
-
-    def FrozenCCcam(self, cam):
-        if not cam.upper().startswith('CCCAM'):
-            print "[CAMSCHECK] exit Frozen CCcam check, softcam is not CCcam"
-            return False
-        if path.exists(CFG):
-            self.cfg = CFG
-        else:
-            self.cfg = confPath()
-        if not self.cfg:
-            print "[CAMSCHECK] exit Frozen CCcam check, CCcam.cfg not found"
-            return False
-        self.readConfig()
-        ff = system('wget -s ' + self.url + ' 2>/dev/null')
-        if ff > 0:
-            print "[CAMSCHECK] Frozen CCcam detected"
-            return True
-        else:
-            print "[CAMSCHECK] CCcam OK"
-            return False
-
-    def readConfig(self):
-        self.url = "http://127.0.0.1:16001"
-        username = None
-        password = None
-
-        try:
-            f = open(self.cfg, 'r')
-            for l in f:
-                if l.startswith('WEBINFO LISTEN PORT :'):
-                    port = getConfigValue(l)
-                    if port != "":
-                        self.url = self.url.replace('16001', port)
-                elif l.startswith('WEBINFO USERNAME :'):
-                    username = getConfigValue(l)
-                elif l.startswith('WEBINFO PASSWORD :'):
-                    password = getConfigValue(l)
-
-            f.close()
-        except:
-            pass
-
-        if (username is not None) and (password is not None) and (username != "") and (password != ""):
-            self.url = self.url.replace('http://', ("http://%s:%s@" % (username, password)))
-#modificacion
-    def doCheck(self):
-        emuDir = "/usr/CamEmu"
-        self.emuList = []
-        self.mlist = []
-        self.emuDirlist = []
-        self.emuBin = []
-        self.emuStart = []
-        self.emuStop = []
-        self.emuDirlist = listdir(emuDir)
-        cam_name = config.softcam.actCam.value
-        cam_name2 = config.softcam.actCam2.value
-        if (cam_name == "no CAM 1 active" or cam_name == "") and (cam_name2 == "no CAM 2 active" or cam_name2 == ""):
-            print "[CAMSCHECK] No Cam to Check, Exit"
-            global isBusy
-            isBusy = None
-            return
-
-
-        for x in self.emuDirlist:
-            #// if file contains the string "emu" (then this is a emu config file)
-#modificacion
-            if x.find("camemu") > -1:
-                self.emuList.append(emuDir + x)
-                em = open(emuDir + x)
-                #// read the emu config file
-                for line in em.readlines():
-                    line1 = line
-                    #// emuname
-                    if line.find("emuname") > -1:
-                        line = line.split("=")
-                        self.mlist.append(line[1].strip())
-                    #// binname
-                    line = line1
-                    if line.find("binname") > -1:
-                        line = line.split("=")
-                        self.emuBin.append(line[1].strip())
-                    #// startcam
-                    line = line1
-                    if line.find("startcam") > -1:
-                        line = line.split("=")
-                        self.emuStart.append(line[1].strip())
-                    #// stopcam
-                    line = line1
-                    if line.find("stopcam") > -1:
-                        line = line.split("=")
-                        self.emuStop.append(line[1].strip())
-
-                em.close()
-
-        camrunning = 0
-        camfound = 0
-        camfrozen = 0
-        indexcam = -1
-        camrunning2 = 0
-        camfound2 = 0
-        camfrozen2 = 0
-        indexcam2 = -1
-        tel = 0
-
-        for x in self.mlist:
-            #print '[CAMSTARTER] searching active cam: ' + x
-            if x == cam_name:
-                camfound = 1
-                indexcam = tel
-                cam_bin = self.emuBin[tel]
-                p = system('pidof %s' % cam_bin)
-                if p != '':
-                    if int(p) == 0:
-                        actcam = self.mlist[tel]
-                        print datetime.now()
-                        print '[CAMSTARTER] CAM 1 is Running, active cam 1: ' + actcam
-                        camrunning = 1
-                        if self.FrozenCCcam(actcam):
-                            camfrozen = 1
-                tel +=1
-            elif x == cam_name2:
-                camfound2 = 1
-                indexcam2 = tel
-                cam_bin = self.emuBin[tel]
-                p = system('pidof %s' % cam_bin)
-                if p != '':
-                    if int(p) == 0:
-                        actcam = self.mlist[tel]
-                        print datetime.now()
-                        print '[CAMSTARTER] CAM 2 is Running, active cam 2: ' + actcam
-                        camrunning2 = 1
-                        if self.FrozenCCcam(actcam):
-                            camfrozen2 = 1
-                tel +=1
-            else:
-                tel +=1
-        try:
-
-            #// CAM IS NOT RUNNING SO START
-            if camrunning == 0 or camfrozen == 1 or (camfound2 == 1 and camrunning2 == 0 or camfrozen2 == 1):
-                #// AND CAM IN LIST
-                if camfound == 1:
-                    stop = self.emuStop[indexcam]
-                    print "[CAMSTARTER] CAM 1 not running, stop " + stop
-                    self.container = eConsoleAppContainer()
-                    self.container.execute(stop)
-
-                    start = self.emuStart[indexcam]
-                    print "[CAMSTARTER] no CAM 1 active, starting " + start
-                    system("echo %s Started cam 1 at: %s >> /tmp/camcheck.txt" % (start, datetime.now()))
-                    self.container = eConsoleAppContainer()
-                    self.container.execute(start)
-                    if camrunning2 == 0 or camfrozen2 == 1:
-                        #// AND CAM IN LIST
-                        if camfound2 == 1:
-                            stop = self.emuStop[indexcam2]
-                            print "[CAMSTARTER] CAM 2 not running, stop " + stop
-                            self.container = eConsoleAppContainer()
-                            self.container.execute(stop)
-                            
-                            import time
-                            time.sleep (int(config.softcam.waittime.value))
-                            start = self.emuStart[indexcam2]
-                            print "[CAMSTARTER] no CAM 2 active, starting " + start
-                            system("echo %s Started cam 2 at: %s >> /tmp/camcheck.txt" % (start, datetime.now()))
-                            self.container = eConsoleAppContainer()
-                            self.container.execute(start)
-            else:
-                if camfound == 0:
-                    print "[CAMSTARTER] No Cam found to start"
-
-        except:
-            print "[CAMSCHECK] Error, can not start Cam"
-
-        global isBusy
-        isBusy = None
-
-campoller = None
-
diff --git a/lib/python/Plugins/Extensions/Openpanel/CamStart.py b/lib/python/Plugins/Extensions/Openpanel/CamStart.py
deleted file mode 100644
index ceb887b..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/CamStart.py
+++ /dev/null
@@ -1,199 +0,0 @@
-from Components.config import config, ConfigSubsection, ConfigText, ConfigSelection, ConfigYesNo
-from enigma import *
-import os
-import datetime
-
-config.softcam.actCam = ConfigText(visible_width = 200)
-config.softcam.restartRunning = ConfigYesNo(default=True)
-config.softcam.restartAttempts =  ConfigSelection(
-                    [
-                    ("0", _("0 (disabled)")),
-                    ("1", _("1")),
-                    ("3", _("3")),
-                    ("5", _("5 (default)")),
-                    ("10", _("10")),
-                    ], "5")
-config.softcam.restartTime = ConfigSelection(
-                    [
-                    ("5", _("5")),
-                    ("10", _("10 (default)")),
-                    ("20", _("20")),
-                    ("30", _("30")),
-                    ("60", _("60")),
-                    ("120", _("120")),
-                    ("240", _("240")),
-                    ], "10")
-config.softcam.camstartMode =  ConfigSelection(
-                    [
-                    ("0", _("Python Camstarter (default)")),
-                    ("1", _("Init.d")),
-                    ], "0")
-
-def command(comandline, strip=1):
-	comandline = comandline + " >/tmp/command.txt"
-	os.system(comandline)
-	text = ""
-	if os.path.exists("/tmp/command.txt") is True:
-		file = open("/tmp/command.txt", "r")
-		if strip == 1:
-			for line in file:
-				text = text + line.strip() + '\n'
-		else:
-			for line in file:
-				text = text + line
-				if text[-1:] != '\n': text = text + "\n"
-		file.close()
-	# if one or last line then remove linefeed
-	if text[-1:] == '\n': text = text[:-1]
-	comandline = text
-	os.system("rm /tmp/command.txt")
-	return comandline
-
-class CamStart:
-
-	def __init__(self, session):
-		self.count = 0
-		self.timerTime = 2
-		self.session = session
-		self.timer = eTimer()
-		self.timer.timeout.get().append(self.timerEvent)
-		self.service = None
-
-	def startTimer(self):
-		if self.timer.isActive():
-			# Disable Timer?
-			pass
-		else:
-			self.timer.startLongTimer(self.timerTime)
-
-	def StopTimer(self, result):
-		if result:
-			self.timer.stop()
-			self.service = None
-
-	def timerEvent(self):
-		if config.softcam.restartAttempts.value == "0":
-			return
-		self.timerTime = int(config.softcam.restartTime.value)
-		emuDir = "/usr/CamEmu/"
-		self.emuList = []
-		self.mlist = []
-		self.emuDirlist = []
-		self.emuBin = []
-		self.emuStart = []
-		self.emuDirlist = os.listdir(emuDir)
-		cam_name = config.softcam.actCam.value
-		cam_name2 = config.softcam.actCam2.value
-		if (cam_name == "no CAM 1 active" or cam_name == "") and (cam_name2 == "no CAM 1 active" or cam_name2 == ""):
-			self.timer.stop()
-			self.service = None
-			print "[CAMSTARTER] No Cam to Start, Exit"
-		else:
-			self.count += 1
-			print '[CAMSTARTER] Start/Check: ' + str(self.count)
-			#// check emu dir for config files
-			for x in self.emuDirlist:
-				#// if file contains the string "emu" (then this is a emu config file)
-				if x.find("camemu") > -1:
-					self.emuList.append(emuDir + x)
-					em = open(emuDir + x)
-					#// read the emu config file
-					for line in em.readlines():
-						line1 = line
-						#// emuname
-						if line.find("emuname") > -1:
-							line = line.split("=")
-							self.mlist.append(line[1].strip())
-						#// binname
-						line = line1
-						if line.find("binname") > -1:
-							line = line.split("=")
-							self.emuBin.append(line[1].strip())
-						#// startcam
-						line = line1
-						if line.find("startcam") > -1:
-							line = line.split("=")
-							self.emuStart.append(line[1].strip())
-
-					em.close()
-
-			camrunning = 0
-			camfound = 0
-			indexcam = -1
-			camrunning2 = 0
-			camfound2 = 0
-			indexcam2 = -1
-			tel = 0
-			for x in self.mlist:
-				#print '[CAMSTARTER] searching active cam: ' + x
-				if x == cam_name:
-					camfound = 1
-					indexcam = tel
-					cam_bin = self.emuBin[tel]
-					p = command('pidof %s |wc -w' % cam_bin)
-					if p != '':
-						if int(p) > 0:
-							actcam = self.mlist[tel]
-							print datetime.datetime.now()
-							print '[CAMSTARTER] CAM 1 is Running, active cam 1: ' + actcam
-							camrunning = 1
-					tel +=1
-				elif x == cam_name2:
-					camfound2 = 1
-					indexcam2 = tel
-					cam_bin = self.emuBin[tel]
-					p = command('pidof %s |wc -w' % cam_bin)
-					if p != '':
-						if int(p) > 0:
-							actcam = self.mlist[tel]
-							print datetime.datetime.now()
-							print '[CAMSTARTER] CAM 2 is Running, active cam 2: ' + actcam
-							camrunning2 = 1
-					tel +=1
-				else:
-					tel +=1
-			try:
-				#// CAM IS NOT RUNNING SO START
-				if camrunning == 0:
-					#// AND CAM IN LIST
-					if camfound == 1:
-						start = self.emuStart[indexcam]
-						print "[CAMSTARTER] no CAM active, starting " + start
-						os.system("echo Start attempts cam 1: " + str(self.count) + " cmd=" + start + " > " + "/tmp/camstarter.txt")
-						self.container = eConsoleAppContainer()
-						self.container.execute(start)
-						if camrunning2 == 0:
-							#// AND CAM IN LIST
-							if camfound2 == 1:
-								import time
-								time.sleep (int(config.softcam.waittime.value))
-								start = self.emuStart[indexcam2]
-								print "[CAMSTARTER] no CAM active, starting " + start
-								os.system("echo Start attempts cam 2: " + str(self.count) + " cmd=" + start + " >> " + "/tmp/camstarter.txt")
-								self.container = eConsoleAppContainer()
-								self.container.execute(start)
-				else:
-					if camfound == 0:
-						print "[CAMSTARTER] No Cam found to start"
-				
-				# If Cam is running don't check anymore
-				if config.softcam.restartRunning.value and camrunning == 1:
-					if camfound2 == 1:
-						if camrunning2 == 1:
-							print "[CAMSTARTER] Cam is running, exit camstarter"
-							self.count = 0
-							return
-					else:
-						print "[CAMSTARTER] Cam is running, exit camstarter"
-						self.count = 0
-						return
-
-			except:
-				pass
-
-			if self.count < int(config.softcam.restartAttempts.value):
-				self.startTimer()
-			else:
-				self.count = 0
-
-timerInstance = None
diff --git a/lib/python/Plugins/Extensions/Openpanel/CronManager.py b/lib/python/Plugins/Extensions/Openpanel/CronManager.py
deleted file mode 100755
index 426ed35..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/CronManager.py
+++ /dev/null
@@ -1,392 +0,0 @@
-from Components.ActionMap import ActionMap
-from Components.config import getConfigListEntry, config, ConfigSubsection, ConfigText, ConfigSelection, ConfigInteger, ConfigClock, NoSave, configfile
-from Components.ConfigList import ConfigListScreen
-from Components.Label import Label
-from Components.Sources.List import List
-from Components.Pixmap import Pixmap
-from Screens.Screen import Screen
-from Screens.MessageBox import MessageBox
-from Components.Console import Console
-from os import system, listdir, rename, symlink, unlink, path, mkdir
-from time import sleep
-
-config.openpanel = ConfigSubsection()
-config.openpanel.cronmanager_commandtype = NoSave(ConfigSelection(choices = [ ('custom',_("Custom")),('predefined',_("Predefined")) ]))
-config.openpanel.cronmanager_cmdtime = NoSave(ConfigClock(default=0))
-config.openpanel.cronmanager_cmdtime.value, mytmpt = ([0, 0], [0, 0])
-config.openpanel.cronmanager_user_command = NoSave(ConfigText(fixed_size=False))
-config.openpanel.cronmanager_runwhen = NoSave(ConfigSelection(default='Daily', choices = [('Hourly', _("Hourly")),('Daily', _("Daily")),('Weekly', _("Weekly")),('Monthly', _("Monthly"))]))
-config.openpanel.cronmanager_dayofweek = NoSave(ConfigSelection(default='Monday', choices = [('Monday', _("Monday")),('Tuesday', _("Tuesday")),('Wednesday', _("Wednesday")),('Thursday', _("Thursday")),('Friday', _("Friday")),('Saturday', _("Saturday")),('Sunday', _("Sunday"))]))
-config.openpanel.cronmanager_dayofmonth = NoSave(ConfigInteger(default=1, limits=(1, 31)))
-
-class CronManager(Screen):
-	skin = """
-		<screen position="center,center" size="590,400" title="Cron Manager">
-			<widget name="lab1" position="10,0" size="100,24" font="Regular;20" valign="center" transparent="0" />
-			<widget name="labdisabled" position="110,0" size="100,24" font="Regular;20" valign="center" halign="center" backgroundColor="red" zPosition="1" />
-			<widget name="labactive" position="110,0" size="100,24" font="Regular;20" valign="center" halign="center" backgroundColor="green" zPosition="2" />
-			<widget name="lab2" position="240,0" size="150,24" font="Regular;20" valign="center" transparent="0" />
-			<widget name="labstop" position="390,0" size="100,24" font="Regular;20" valign="center" halign="center" backgroundColor="red" zPosition="1" />
-			<widget name="labrun" position="390,0" size="100,24" font="Regular;20" valign="center" halign="center" backgroundColor="green" zPosition="2"/>
-			<widget source="list" render="Listbox" position="10,35" size="540,325" scrollbarMode="showOnDemand" >
-				<convert type="StringList" />
-			</widget>
-			<ePixmap pixmap="skin_default/buttons/red.png" position="0,350" size="140,40" alphatest="on" />
-			<ePixmap pixmap="skin_default/buttons/yellow.png" position="150,350" size="140,40" alphatest="on" />
-			<ePixmap pixmap="skin_default/buttons/green.png" position="300,350" size="140,40" alphatest="on" />
-			<ePixmap pixmap="skin_default/buttons/blue.png" position="450,350" size="140,40" alphatest="on" />
-			<widget name="key_red" position="0,350" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#9f1313" transparent="1" />
-			<widget name="key_yellow" position="150,350" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#a08500" transparent="1" />
-			<widget name="key_green" position="300,350" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#a08500" transparent="1" />
-			<widget name="key_blue" position="450,350" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#a08500" transparent="1" />
-		</screen>"""
-
-
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		if not path.exists('/usr/script'):
-			mkdir('/usr/script', 0755)
-		Screen.setTitle(self, _("Cron Manager"))
-		self['lab1'] = Label(_("Autostart:"))
-		self['labactive'] = Label(_(_("Active")))
-		self['labdisabled'] = Label(_(_("Disabled")))
-		self['lab2'] = Label(_("Current Status:"))
-		self['labstop'] = Label(_("Stopped"))
-		self['labrun'] = Label(_("Running"))
-		self['key'] = Label(_("H: = Hourly / D: = Daily / W: = Weekly / M: = Monthly"))
-		self.Console = Console()
-		self.my_crond_active = False
-		self.my_crond_run = False
-		
-		self['key_red'] = Label(_("Add"))
-		self['key_green'] = Label(_("Delete"))
-		self['key_yellow'] = Label(_("Start"))
-		self['key_blue'] = Label(_("Autostart"))
-		self.list = []
-		self['list'] = List(self.list)
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions', "MenuActions"], {'ok': self.info, 'back': self.close, 'red': self.addtocron, 'green': self.delcron, 'yellow': self.CrondStart, 'blue': self.autostart, "menu": self.closeRecursive})
-		self.onLayoutFinish.append(self.updateList)
-
-	def CrondStart(self):
-		if not self.my_crond_run:
-			self.Console.ePopen('/etc/init.d/crond start', self.StartStopCallback)
-		elif self.my_crond_run:
-			self.Console.ePopen('/etc/init.d/crond stop', self.StartStopCallback)
-
-	def StartStopCallback(self, result = None, retval = None, extra_args = None):
-		sleep(3)
-		self.updateList()
-
-	def autostart(self):
-		if path.exists('/etc/rc0.d/K60crond'):
-			unlink('/etc/rc0.d/K60crond')
-		else:
-			symlink('/etc/init.d/crond', '/etc/rc0.d/K60crond')
-
-		if path.exists('/etc/rc1.d/K60crond'):
-			unlink('/etc/rc1.d/K60crond')
-		else:
-			symlink('/etc/init.d/crond', '/etc/rc1.d/K60crond')
-
-		if path.exists('/etc/rc2.d/S90crond'):
-			unlink('/etc/rc2.d/S90crond')
-		else:
-			symlink('/etc/init.d/crond', '/etc/rc2.d/S90crond')
-
-		if path.exists('/etc/rc3.d/S90crond'):
-			unlink('/etc/rc3.d/S90crond')
-		else:
-			symlink('/etc/init.d/crond', '/etc/rc3.d/S90crond')
-
-		if path.exists('/etc/rc4.d/S90crond'):
-			unlink('/etc/rc4.d/S90crond')
-		else:
-			symlink('/etc/init.d/crond', '/etc/rc4.d/S90crond')
-
-		if path.exists('/etc/rc5.d/S90crond'):
-			unlink('/etc/rc5.d/S90crond')
-		else:
-			symlink('/etc/init.d/crond', '/etc/rc5.d/S90crond')
-
-		if path.exists('/etc/rc6.d/K60crond'):
-			unlink('/etc/rc6.d/K60crond')
-		else:
-			symlink('/etc/init.d/crond', '/etc/rc6.d/K60crond')
-
-		self.updateList()
-
-	def addtocron(self):
-		self.session.openWithCallback(self.updateList, SetupCronConf)
-
-	def updateList(self):
-		import process
-		p = process.ProcessList()
-		crond_process = str(p.named('crond')).strip('[]')
-		self['labrun'].hide()
-		self['labstop'].hide()
-		self['labactive'].hide()
-		self['labdisabled'].hide()
-		self.my_crond_active = False
-		self.my_crond_run = False
-		if path.exists('/etc/rc3.d/S90crond'):
-			self['labdisabled'].hide()
-			self['labactive'].show()
-			self.my_crond_active = True
-		else:
-			self['labactive'].hide()
-			self['labdisabled'].show()
-		if crond_process:
-			self.my_crond_run = True
-		if self.my_crond_run == True:
-			self['labstop'].hide()
-			self['labrun'].show()
-			self['key_yellow'].setText(_("Stop"))
-		else:
-			self['labstop'].show()
-			self['labrun'].hide()
-			self['key_yellow'].setText(_("Start"))
-
-		self.list = []
-		if path.exists('/etc/cron/crontabs/root'):
-			f = open('/etc/cron/crontabs/root', 'r')
-			for line in f.readlines():
-				parts = line.strip().split()
-				if parts:
-					if parts[1] == '*':
-						try:
-							line2 = 'H: 00:' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7] + parts[8] + parts[9]
-						except:
-							try:
-								line2 = 'H: 00:' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7] + parts[8]
-							except:
-								try:
-									line2 = 'H: 00:' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7]
-								except:
-									try:
-										line2 = 'H: 00:' + parts[0].zfill(2) + '\t' + parts[5] + parts[6]
-									except:
-										line2 = 'H: 00:' + parts[0].zfill(2) + '\t' + parts[5]
-						res = (line2, line)
-						self.list.append(res)
-					elif parts[2] == '*' and parts[4] == '*':
-						try:
-							line2 = 'D: ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7] + parts[8] + parts[9]
-						except:
-							try:
-								line2 = 'D: ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7] + parts[8]
-							except:
-								try:
-									line2 = 'D: ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7]
-								except:
-									try:
-										line2 = 'D: ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6]
-									except:
-										line2 = 'D: ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5]
-						res = (line2, line)
-						self.list.append(res)
-					elif parts[3] == '*':
-						if parts[4] == "*":
-							try:
-								line2 = 'M:  Day ' + parts[2] + '  ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7] + parts[8] + parts[9]
-							except:
-								try:
-									line2 = 'M:  Day ' + parts[2] + '  ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7] + parts[8]
-								except:
-									try:
-										line2 = 'M:  Day ' + parts[2] + '  ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7]
-									except:
-										try:
-											line2 = 'M:  Day ' + parts[2] + '  ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6]
-										except:
-											line2 = 'M:  Day ' + parts[2] + '  ' + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5]
-						header = 'W:  '
-						day = ""
-						if str(parts[4]).find('0') >= 0:
-							day = 'Sun '
-						if str(parts[4]).find('1') >= 0:
-							day += 'Mon '
-						if str(parts[4]).find('2') >= 0:
-							day += 'Tues '
-						if str(parts[4]).find('3') >= 0:
-							day += 'Wed '
-						if str(parts[4]).find('4') >= 0:
-							day += 'Thurs '
-						if str(parts[4]).find('5') >= 0:
-							day += 'Fri '
-						if str(parts[4]).find('6') >= 0:
-							day += 'Sat '
-
-						if day:
-							try:
-								line2 = header + day + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7] + parts[8] + parts[9]
-							except:
-								try:
-									line2 = header + day + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7] + parts[8]
-								except:
-									try:
-										line2 = header + day + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6] + parts[7]
-									except:
-										try:
-											line2 = header + day + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5] + parts[6]
-										except:
-											line2 = header + day + parts[1].zfill(2) + ':' + parts[0].zfill(2) + '\t' + parts[5]
-						res = (line2, line)
-						self.list.append(res)
-			f.close()
-		self['list'].list = self.list
-
-	def delcron(self):
-		self.sel = self['list'].getCurrent()
-		if self.sel:
-			parts = self.sel[0]
-			parts = parts.split('\t')
-			message = _("Are you sure you want to delete this:\n ") + parts[1]
-			ybox = self.session.openWithCallback(self.doDelCron, MessageBox, message, MessageBox.TYPE_YESNO)
-			ybox.setTitle(_("Remove Confirmation"))
-
-	def doDelCron(self, answer):
-		if answer:
-			mysel = self['list'].getCurrent()
-			if mysel:
-				myline = mysel[1]
-				file('/etc/cron/crontabs/root.tmp', 'w').writelines([l for l in file('/etc/cron/crontabs/root').readlines() if myline not in l])
-				rename('/etc/cron/crontabs/root.tmp','/etc/cron/crontabs/root')
-				rc = system('crontab /etc/cron/crontabs/root -c /etc/cron/crontabs')
-				self.updateList()
-
-	def info(self):
-		mysel = self['list'].getCurrent()
-		if mysel:
-			myline = mysel[1]
-			self.session.open(MessageBox, _(myline), MessageBox.TYPE_INFO)
-
-	def closeRecursive(self):
-		self.close(True)
-
-class SetupCronConf(Screen, ConfigListScreen):
-	skin = """
-		<screen position="center,center" size="560,400" title="Cron Manager">
-			<widget name="config" position="10,20" size="540,400" scrollbarMode="showOnDemand" />
-			<ePixmap pixmap="skin_default/buttons/red.png" position="90,350" size="140,40" alphatest="on" />
-			<widget name="key_red" position="90,350" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#9f1313" transparent="1" />
-			<widget name="HelpWindow" pixmap="skin_default/vkey_icon.png" position="340,300" zPosition="1" size="1,1" transparent="1" alphatest="on" />
-			<ePixmap pixmap="skin_default/buttons/key_text.png" position="250,353" zPosition="4" size="35,25" alphatest="on" transparent="1" />
-		</screen>"""
-
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Cron Manager"))
-		self.onChangedEntry = [ ]
-		self.list = []
-		ConfigListScreen.__init__(self, self.list, session = self.session, on_change = self.changedEntry)
-		self['key_red'] = Label(_("Save"))
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions', 'VirtualKeyboardActions', "MenuActions"], {'red': self.checkentry, 'back': self.close, 'showVirtualKeyboard': self.KeyText, "menu": self.closeRecursive})
-		self["HelpWindow"] = Pixmap()
-		self["HelpWindow"].hide()
-		self.createSetup()
-
-	def createSetup(self):
-		predefinedlist = []
-		f = listdir('/usr/script')
-		if f:
-			for line in f:
-				parts = line.split()
-				path = "/usr/script/"
-				pkg = parts[0]
-				description = path + parts[0]
-				if pkg.find('.sh') >= 0:
-					predefinedlist.append((description, pkg))
-			predefinedlist.sort()
-		config.openpanel.cronmanager_predefined_command = NoSave(ConfigSelection(choices = predefinedlist))
-		self.editListEntry = None
-		self.list = []
-		self.list.append(getConfigListEntry(_("Run how often ?"), config.openpanel.cronmanager_runwhen))
-		if config.openpanel.cronmanager_runwhen.value != 'Hourly':
-			self.list.append(getConfigListEntry(_("Time to execute command or script"), config.openpanel.cronmanager_cmdtime))
-		if config.openpanel.cronmanager_runwhen.value == 'Weekly':
-			self.list.append(getConfigListEntry(_("What Day of week ?"), config.openpanel.cronmanager_dayofweek))
-		if config.openpanel.cronmanager_runwhen.value == 'Monthly':
-			self.list.append(getConfigListEntry(_("What Day of month ?"), config.openpanel.cronmanager_dayofmonth))
-		self.list.append(getConfigListEntry(_("Command type"), config.openpanel.cronmanager_commandtype))
-		if config.openpanel.cronmanager_commandtype.value == 'custom':
-			self.list.append(getConfigListEntry(_("Command To Run"), config.openpanel.cronmanager_user_command))
-		else:
-			self.list.append(getConfigListEntry(_("Command To Run"), config.openpanel.cronmanager_predefined_command))
-		self["config"].list = self.list
-		self["config"].setList(self.list)
-
-	# for summary:
-	def changedEntry(self):
-		if self["config"].getCurrent()[0] == _("Run how often ?") or self["config"].getCurrent()[0] == _("Command type"):
-			self.createSetup()
-		for x in self.onChangedEntry:
-			x()
-
-	def getCurrentEntry(self):
-		return self["config"].getCurrent()[0]
-
-	def KeyText(self):
-		sel = self['config'].getCurrent()
-		if sel:
-			self.vkvar = sel[0]
-			if self.vkvar == _("Command To Run"):
-				from Screens.VirtualKeyBoard import VirtualKeyBoard
-				self.session.openWithCallback(self.VirtualKeyBoardCallback, VirtualKeyBoard, title = self["config"].getCurrent()[0], text = self["config"].getCurrent()[1].value)
-
-	def VirtualKeyBoardCallback(self, callback = None):
-		if callback is not None and len(callback):
-			self["config"].getCurrent()[1].value = callback
-			self["config"].invalidate(self["config"].getCurrent())
-
-	def checkentry(self):
-		msg = ''
-		if (config.openpanel.cronmanager_commandtype.value == 'predefined' and config.openpanel.cronmanager_predefined_command.value == '') or config.openpanel.cronmanager_commandtype.value == 'custom' and config.openpanel.cronmanager_user_command.value == '':
-			msg = _("You must set at least one Command")
-		if msg:
-			self.session.open(MessageBox, msg, MessageBox.TYPE_ERROR)
-		else:
-			self.saveMycron()
-
-	def saveMycron(self):
-		hour = '%02d' % config.openpanel.cronmanager_cmdtime.value[0]
-		minutes = '%02d' % config.openpanel.cronmanager_cmdtime.value[1]
-		if config.openpanel.cronmanager_commandtype.value == 'predefined' and config.openpanel.cronmanager_predefined_command.value != '':
-			command = config.openpanel.cronmanager_predefined_command.value
-		else:
-			command = config.openpanel.cronmanager_user_command.value
-
-		if config.openpanel.cronmanager_runwhen.value == 'Hourly':
-			newcron = minutes + ' ' + ' * * * * ' + command.strip() + '\n'
-		elif config.openpanel.cronmanager_runwhen.value == 'Daily':
-			newcron = minutes + ' ' + hour + ' * * * ' + command.strip() + '\n'
-		elif config.openpanel.cronmanager_runwhen.value == 'Weekly':
-			if config.openpanel.cronmanager_dayofweek.value == 'Sunday':
-				newcron = minutes + ' ' + hour + ' * * 0 ' + command.strip() + '\n'
-			elif config.openpanel.cronmanager_dayofweek.value == 'Monday':
-				newcron = minutes + ' ' + hour + ' * * 1 ' + command.strip() + '\n'
-			elif config.openpanel.cronmanager_dayofweek.value == 'Tuesday':
-				newcron = minutes + ' ' + hour + ' * * 2 ' + command.strip() + '\n'
-			elif config.openpanel.cronmanager_dayofweek.value == 'Wednesday':
-				newcron = minutes + ' ' + hour + ' * * 3 ' + command.strip() + '\n'
-			elif config.openpanel.cronmanager_dayofweek.value == 'Thursday':
-				newcron = minutes + ' ' + hour + ' * * 4 ' + command.strip() + '\n'
-			elif config.openpanel.cronmanager_dayofweek.value == 'Friday':
-				newcron = minutes + ' ' + hour + ' * * 5 ' + command.strip() + '\n'
-			elif config.openpanel.cronmanager_dayofweek.value == 'Saturday':
-				newcron = minutes + ' ' + hour + ' * * 6 ' + command.strip() + '\n'
-		elif config.openpanel.cronmanager_runwhen.value == 'Monthly':
-			newcron = minutes + ' ' + hour + ' ' + str(config.openpanel.cronmanager_dayofmonth.value) + ' * * ' + command.strip() + '\n'
-		else:
-			command = config.openpanel.cronmanager_user_command.value
-
-		out = open('/etc/cron/crontabs/root', 'a')
-		out.write(newcron)
-		out.close()
-		rc = system('crontab /etc/cron/crontabs/root -c /etc/cron/crontabs')
-		config.openpanel.cronmanager_predefined_command.value = 'None'
-		config.openpanel.cronmanager_user_command.value = 'None'
-		config.openpanel.cronmanager_runwhen.value = 'Daily'
-		config.openpanel.cronmanager_dayofweek.value = 'Monday'
-		config.openpanel.cronmanager_dayofmonth.value = "1"
-		config.openpanel.cronmanager_cmdtime.value, mytmpt = ([0, 0], [0, 0])
-		self.close()
diff --git a/lib/python/Plugins/Extensions/Openpanel/Makefile.am b/lib/python/Plugins/Extensions/Openpanel/Makefile.am
deleted file mode 100644
index 27f1871..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/Makefile.am
+++ /dev/null
@@ -1,7 +0,0 @@
-installdir = $(pkglibdir)/python/Plugins/Extensions/Openpanel
-
-SUBDIRS = icons meta
-
-install_PYTHON = *.py
-
-install_DATA = open.png openhd.png speedtesting.py
\ No newline at end of file
diff --git a/lib/python/Plugins/Extensions/Openpanel/MountManager.py b/lib/python/Plugins/Extensions/Openpanel/MountManager.py
deleted file mode 100644
index f466c93..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/MountManager.py
+++ /dev/null
@@ -1,687 +0,0 @@
-from Screens.Screen import Screen
-from enigma import eTimer
-from boxbranding import getMachineBrand, getMachineName, getBoxType, getMachineBuild
-from Screens.MessageBox import MessageBox
-from Screens.Standby import TryQuitMainloop
-from Components.ActionMap import ActionMap
-from Components.Label import Label
-from Components.Pixmap import Pixmap
-from Components.ConfigList import ConfigListScreen
-from Components.config import getConfigListEntry, config, ConfigSelection, NoSave, configfile
-from Components.Console import Console
-from Components.Sources.List import List
-from Components.Sources.StaticText import StaticText
-from Tools.LoadPixmap import LoadPixmap
-from os import system, rename, path, mkdir, remove
-from time import sleep
-from re import search
-
-class HddMount(Screen):
-	skin = """
-	<screen position="center,center" size="640,460" title="Mount Manager">
-		<ePixmap pixmap="skin_default/buttons/red.png" position="25,0" size="140,40" alphatest="on" />
-		<ePixmap pixmap="skin_default/buttons/green.png" position="175,0" size="140,40" alphatest="on" />
-		<ePixmap pixmap="skin_default/buttons/yellow.png" position="325,0" size="140,40" alphatest="on" />
-		<ePixmap pixmap="skin_default/buttons/blue.png" position="475,0" size="140,40" alphatest="on" />
-		<widget name="key_red" position="25,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#9f1313" transparent="1" />
-		<widget name="key_green" position="175,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#1f771f" transparent="1" />
-		<widget name="key_yellow" position="325,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#a08500" transparent="1" />
-		<widget name="key_blue" position="475,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#18188b" transparent="1" />
-		<widget source="list" render="Listbox" position="10,50" size="620,450" scrollbarMode="showOnDemand" >
-			<convert type="TemplatedMultiContent">
-				{"template": [
-				 MultiContentEntryText(pos = (90, 0), size = (600, 30), font=0, text = 0),
-				 MultiContentEntryText(pos = (110, 30), size = (600, 50), font=1, flags = RT_VALIGN_TOP, text = 1),
-				 MultiContentEntryPixmapAlphaBlend(pos = (0, 0), size = (80, 80), png = 2),
-				],
-				"fonts": [gFont("Regular", 24),gFont("Regular", 20)],
-				"itemHeight": 85
-				}
-			</convert>
-		</widget>
-		<widget name="lab1" zPosition="2" position="50,90" size="600,40" font="Regular;22" halign="center" transparent="1"/>
-	</screen>"""
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Mount Manager"))
-		self['key_red'] = Label(" ")
-		self['key_green'] = Label(_("Setup Mounts"))
-		self['key_yellow'] = Label("Unmount")
-		self['key_blue'] = Label("Mount")
-		self['lab1'] = Label()
-		self.onChangedEntry = [ ]
-		self.list = []
-		self['list'] = List(self.list)
-		self["list"].onSelectionChanged.append(self.selectionChanged)
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions', "MenuActions"], {'back': self.close, 'green': self.SetupMounts, 'red': self.saveMypoints, 'yellow': self.Unmount, 'blue': self.Mount, "menu": self.close})
-		self.activityTimer = eTimer()
-		self.activityTimer.timeout.get().append(self.updateList2)
-		self.updateList()
-
-	def createSummary(self):
-		return DevicesPanelSummary
-
-	def selectionChanged(self):
-		if len(self.list) == 0:
-			return
-		self.sel = self['list'].getCurrent()
-		mountp = self.sel[3]
-		if mountp.find('/media/hdd') < 0:
-			self["key_red"].setText(_("Use as HDD"))
-		else:
-			self["key_red"].setText(" ")
-			
-		if self.sel:
-			try:
-				name = str(self.sel[0])
-				desc = str(self.sel[1].replace('\t','  '))
-			except:
-				name = ""
-				desc = ""
-		else:
-			name = ""
-			desc = ""
-		for cb in self.onChangedEntry:
-			cb(name, desc)
-
-	def updateList(self, result = None, retval = None, extra_args = None):
-		scanning = _("Wait please while scanning for devices...")
-		self['lab1'].setText(scanning)
-		self.activityTimer.start(10)
-
-	def updateList2(self):
-		self.activityTimer.stop()
-		self.list = []
-		list2 = []
-		f = open('/proc/partitions', 'r')
-		for line in f.readlines():
-			parts = line.strip().split()
-			if not parts:
-				continue
-			device = parts[3]
-			if not search('sd[a-z][1-9]',device) and not search('mmcblk[0-9]p[1-9]',device):
-				continue
-			if getMachineBuild() in ('vuzero4k','u5','sf5008','et13000','et1x000','vuuno4k','vuuno4kse', 'vuultimo4k', 'vusolo4k', 'hd51', 'hd52', 'dm820', 'dm7080', 'sf4008', 'dm900', 'dm920', 'gb7252', 'dags7252', 'vs1500','h7','8100s') and search('mmcblk0p[1-9]',device):
-				continue
-			if getMachineBuild() in ('xc7439') and search('mmcblk1p[1-9]',device):
-				continue
-			if getMachineBuild() in ('u5') and search('mmcblk1p[1]',device):
-				continue
-			if device in list2:
-				continue
-			self.buildMy_rec(device)
-			list2.append(device)
-
-		f.close()
-		self['list'].list = self.list
-		self['lab1'].hide()
-
-	def buildMy_rec(self, device):
-		device2 = ''
-		try:
-			if device.find('1') > 1:
-				device2 = device.replace('1', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('2') > 1:
-				device2 = device.replace('2', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('3') > 1:
-				device2 = device.replace('3', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('4') > 1:
-				device2 = device.replace('4', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('5') > 1:
-				device2 = device.replace('5', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('6') > 1:
-				device2 = device.replace('6', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('7') > 1:
-				device2 = device.replace('7', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('8') > 1:
-				device2 = device.replace('8', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p1') > 1:
-				device2 = device.replace('p1', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p2') > 1:
-				device2 = device.replace('p2', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p3') > 1:
-				device2 = device.replace('p3', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p4') > 1:
-				device2 = device.replace('p4', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p5') > 1:
-				device2 = device.replace('p5', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p6') > 1:
-				device2 = device.replace('p6', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p7') > 1:
-				device2 = device.replace('p7', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p8') > 1:
-				device2 = device.replace('p8', '')
-		except:
-			device2 = ''
-		devicetype = path.realpath('/sys/block/' + device2 + '/device')
-		d2 = device
-		name = 'USB: '
-		mypixmap = '/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/dev_usbstick.png'
-		if device2.startswith('mmcblk'):
-			model = file('/sys/block/' + device2 + '/device/name').read()
-			mypixmap = '/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/dev_mmc.png'
-			name = 'MMC: '
-		else:
-			model = file('/sys/block/' + device2 + '/device/model').read()
-		model = str(model).replace('\n', '')
-		des = ''
-		if devicetype.find('/devices/pci') != -1 or devicetype.find('ahci') != -1:
-			name = _("HARD DISK: ")
-			mypixmap = '/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/dev_hdd.png'
-		name = name + model
-		self.Console = Console()
-		self.Console.ePopen("sfdisk -l | grep swap | awk '{print $(NF-9)}' >/tmp/devices.tmp")
-		sleep(0.5)
-		try:
-			f = open('/tmp/devices.tmp', 'r')
-			swapdevices = f.read()
-			f.close()
-		except:
-			swapdevices = ' '
-		if path.exists('/tmp/devices.tmp'):
-			remove('/tmp/devices.tmp')
-		swapdevices = swapdevices.replace('\n','')
-		swapdevices = swapdevices.split('/')
-		f = open('/proc/mounts', 'r')
-		for line in f.readlines():
-			if line.find(device) != -1:
-				parts = line.strip().split()
-				d1 = parts[1]
-				dtype = parts[2]
-				rw = parts[3]
-				break
-				continue
-			else:
-				if device in swapdevices:
-					parts = line.strip().split()
-					d1 = _("None")
-					dtype = 'swap'
-					rw = _("None")
-					break
-					continue
-				else:
-					d1 = _("None")
-					dtype = _("unavailable")
-					rw = _("None")
-		f.close()
-		f = open('/proc/partitions', 'r')
-		for line in f.readlines():
-			if line.find(device) != -1:
-				parts = line.strip().split()
-				size = int(parts[2])
-				if (((float(size) / 1024) / 1024) / 1024) > 1:
-					des = _("Size: ") + str(round((((float(size) / 1024) / 1024) / 1024),2)) + _("TB")
-				elif ((size / 1024) / 1024) > 1:
-					des = _("Size: ") + str((size / 1024) / 1024) + _("GB")
-				else:
-					des = _("Size: ") + str(size / 1024) + _("MB")
-			else:
-				try:
-					size = file('/sys/block/' + device2 + '/' + device + '/size').read()
-					size = str(size).replace('\n', '')
-					size = int(size)
-				except:
-					size = 0
-				if ((((float(size) / 2) / 1024) / 1024) / 1024) > 1:
-					des = _("Size: ") + str(round(((((float(size) / 2) / 1024) / 1024) / 1024),2)) + _("TB")
-				elif (((size / 2) / 1024) / 1024) > 1:
-					des = _("Size: ") + str(((size / 2) / 1024) / 1024) + _("GB")
-				else:
-					des = _("Size: ") + str((size / 2) / 1024) + _("MB")
-		f.close()
-		if des != '':
-			if rw.startswith('rw'):
-				rw = ' R/W'
-			elif rw.startswith('ro'):
-				rw = ' R/O'
-			else:
-				rw = ""
-			des += '\t' + _("Mount: ") + d1 + '\n' + _("Device: ") + '/dev/' + device + '\t' + _("Type: ") + dtype + rw
-			png = LoadPixmap(mypixmap)
-			mountP = d1
-			deviceP = '/dev/' + device
-			res = (name, des, png, mountP, deviceP)
-			self.list.append(res)
-
-	def SetupMounts(self):
-		self.session.openWithCallback(self.updateList, DevicePanelConf)
-
-	def Mount(self):
-		sel = self['list'].getCurrent()
-		if sel:
-			mountp = sel[3]
-			device = sel[4]
-			system ('mount ' + device)
-			mountok = False
-			f = open('/proc/mounts', 'r')
-			for line in f.readlines():
-				if line.find(device) != -1:
-					mountok = True
-			if not mountok:
-				self.session.open(MessageBox, _("Mount failed"), MessageBox.TYPE_INFO, timeout=5)
-			self.updateList()
-
-	def Unmount(self):
-		sel = self['list'].getCurrent()
-		if sel:
-			mountp = sel[3]
-			device = sel[4]
-			system ('umount ' + mountp)
-			try:
-				mounts = open("/proc/mounts")
-			except IOError:
-				return -1
-			mountcheck = mounts.readlines()
-			mounts.close()
-			for line in mountcheck:
-				parts = line.strip().split(" ")
-				if path.realpath(parts[0]).startswith(device):
-					self.session.open(MessageBox, _("Can't unmount partiton, make sure it is not being used for swap or record/timeshift paths"), MessageBox.TYPE_INFO)
-			self.updateList()
-
-	def saveMypoints(self):
-		sel = self['list'].getCurrent()
-		if sel:
-			self.mountp = sel[3]
-			self.device = sel[4]
-			if self.mountp.find('/media/hdd') < 0:
-				self.Console.ePopen('umount ' + self.device)
-				if not path.exists('/media/hdd'):
-					mkdir('/media/hdd', 0755)
-				else:
-					self.Console.ePopen('umount /media/hdd')
-				self.Console.ePopen('mount ' + self.device + ' /media/hdd')
-				self.Console.ePopen("/sbin/blkid | grep " + self.device, self.add_fstab, [self.device, self.mountp])
-			else:
-				self.session.open(MessageBox, _("This Device is already mounted as HDD."), MessageBox.TYPE_INFO, timeout = 10, close_on_any_key = True)
-			
-	def add_fstab(self, result = None, retval = None, extra_args = None):
-		self.device = extra_args[0]
-		self.mountp = extra_args[1]
-		self.device_uuid_tmp = result.split('UUID=')
-		self.device_uuid_tmp = self.device_uuid_tmp[1].replace('"',"")
-		self.device_uuid_tmp = self.device_uuid_tmp.replace('\n',"")
-		self.device_uuid_tmp = self.device_uuid_tmp.split()[0]
-		self.device_uuid = 'UUID=' + self.device_uuid_tmp
-		if not path.exists(self.mountp):
-			mkdir(self.mountp, 0755)
-		file('/etc/fstab.tmp', 'w').writelines([l for l in file('/etc/fstab').readlines() if '/media/hdd' not in l])
-		rename('/etc/fstab.tmp','/etc/fstab')
-		file('/etc/fstab.tmp', 'w').writelines([l for l in file('/etc/fstab').readlines() if self.device not in l])
-		rename('/etc/fstab.tmp','/etc/fstab')
-		file('/etc/fstab.tmp', 'w').writelines([l for l in file('/etc/fstab').readlines() if self.device_uuid not in l])
-		rename('/etc/fstab.tmp','/etc/fstab')
-		out = open('/etc/fstab', 'a')
-		line = self.device_uuid + '\t/media/hdd\tauto\tdefaults\t0 0\n'
-		out.write(line)
-		out.close()
-		self.Console.ePopen('mount /media/hdd', self.updateList)
-
-	def restBo(self, answer):
-		if answer is True:
-			self.session.open(TryQuitMainloop, 2)
-		else:
-			self.updateList()
-			self.selectionChanged()
-
-class DevicePanelConf(Screen, ConfigListScreen):
-	skin = """
-	<screen position="center,center" size="640,460" title="Choose where to mount your devices to:">
-		<ePixmap pixmap="skin_default/buttons/red.png" position="25,0" size="140,40" alphatest="on" />
-		<ePixmap pixmap="skin_default/buttons/green.png" position="175,0" size="140,40" alphatest="on" />
-		<widget name="key_red" position="25,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#9f1313" transparent="1" />
-		<widget name="key_green" position="175,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#1f771f" transparent="1" />
-		<widget name="config" position="30,60" size="580,275" scrollbarMode="showOnDemand"/>
-		<widget name="Linconn" position="30,375" size="580,20" font="Regular;18" halign="center" valign="center" backgroundColor="#9f1313"/>
-	</screen>"""
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		self.list = []
-		self.device_type = 'auto'
-		self.device_uuid = ""
-		ConfigListScreen.__init__(self, self.list)
-		Screen.setTitle(self, _("Choose where to mount your devices to:"))
-		self['key_green'] = Label(_("Save"))
-		self['key_red'] = Label(_("Cancel"))
-		self['Linconn'] = Label(_("Wait please while scanning your %s %s devices...") % (getMachineBrand(), getMachineName()))
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions'], {'green': self.saveMypoints, 'red': self.close, 'back': self.close})
-		self.updateList()
-
-	def updateList(self):
-		self.list = []
-		list2 = []
-		self.Console = Console()
-		self.Console.ePopen("sfdisk -l | grep swap | awk '{print $(NF-9)}' >/tmp/devices.tmp")
-		sleep(0.5)
-		f = open('/tmp/devices.tmp', 'r')
-		swapdevices = f.read()
-		f.close()
-		if path.exists('/tmp/devices.tmp'):
-			remove('/tmp/devices.tmp')
-		swapdevices = swapdevices.replace('\n','')
-		swapdevices = swapdevices.split('/')
-		f = open('/proc/partitions', 'r')
-		for line in f.readlines():
-			parts = line.strip().split()
-			if not parts:
-				continue
-			device = parts[3]
-			if not search('sd[a-z][1-9]',device) and not search('mmcblk[0-9]p[1-9]',device):
-				continue
-			if getMachineBuild() in ('vuzero4k','u5','sf5008','et13000','et1x000','vuuno4k','vuuno4kse', 'vuultimo4k', 'vusolo4k', 'hd51', 'hd52', 'dm820', 'dm7080', 'sf4008', 'dm900', 'dm920', 'gb7252', 'dags7252', 'vs1500','h7','8100s') and search('mmcblk0p[1-9]',device):
-				continue
-			if getMachineBuild() in ('xc7439') and search('mmcblk1p[1-9]',device):
-				continue
-			if getMachineBuild() in ('u5') and search('mmcblk1p[1]',device):
-				continue
-			if device in list2:
-				continue
-			if device in swapdevices:
-				continue
-			self.buildMy_rec(device)
-			list2.append(device)
-		f.close()
-		self['config'].list = self.list
-		self['config'].l.setList(self.list)
-		self['Linconn'].hide()
-
-	def buildMy_rec(self, device):
-		try:
-			if device.find('1') > 1:
-				device2 = device.replace('1', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('2') > 1:
-				device2 = device.replace('2', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('3') > 1:
-				device2 = device.replace('3', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('4') > 1:
-				device2 = device.replace('4', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('5') > 1:
-				device2 = device.replace('5', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('6') > 1:
-				device2 = device.replace('6', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('7') > 1:
-				device2 = device.replace('7', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('8') > 1:
-				device2 = device.replace('8', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p1') > 1:
-				device2 = device.replace('p1', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p2') > 1:
-				device2 = device.replace('p2', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p3') > 1:
-				device2 = device.replace('p3', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p4') > 1:
-				device2 = device.replace('p4', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p5') > 1:
-				device2 = device.replace('p5', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p6') > 1:
-				device2 = device.replace('p6', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p7') > 1:
-				device2 = device.replace('p7', '')
-		except:
-			device2 = ''
-		try:
-			if device.find('p8') > 1:
-				device2 = device.replace('p8', '')
-		except:
-			device2 = ''
-		devicetype = path.realpath('/sys/block/' + device2 + '/device')
-		d2 = device
-		name = 'USB: '
-		mypixmap = '/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/dev_usbstick.png'
-		if device2.startswith('mmcblk'):
-			model = file('/sys/block/' + device2 + '/device/name').read()
-			mypixmap = '/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/dev_mmc.png'
-			name = 'MMC: '
-		else:
-			model = file('/sys/block/' + device2 + '/device/model').read()
-		model = str(model).replace('\n', '')
-		des = ''
-		print "test:" 
-		if devicetype.find('/devices/pci') != -1 or devicetype.find('ahci') != -1:
-			name = _("HARD DISK: ")
-			mypixmap = '/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/dev_hdd.png'
-		name = name + model
-		f = open('/proc/mounts', 'r')
-		for line in f.readlines():
-			if line.find(device) != -1:
-				parts = line.strip().split()
-				d1 = parts[1]
-				dtype = parts[2]
-				break
-				continue
-			else:
-				d1 = _("None")
-				dtype = _("unavailable")
-		f.close()
-		f = open('/proc/partitions', 'r')
-		for line in f.readlines():
-			if line.find(device) != -1:
-				parts = line.strip().split()
-				size = int(parts[2])
-				if (((float(size) / 1024) / 1024) / 1024) > 1:
-					des = _("Size: ") + str(round((((float(size) / 1024) / 1024) / 1024),2)) + _("TB")
-				elif ((size / 1024) / 1024) > 1:
-					des = _("Size: ") + str((size / 1024) / 1024) + _("GB")
-				else:
-					des = _("Size: ") + str(size / 1024) + _("MB")
-			else:
-				try:
-					size = file('/sys/block/' + device2 + '/' + device + '/size').read()
-					size = str(size).replace('\n', '')
-					size = int(size)
-				except:
-					size = 0
-				if ((((float(size) / 2) / 1024) / 1024) / 1024) > 1:
-					des = _("Size: ") + str(round(((((float(size) / 2) / 1024) / 1024) / 1024),2)) + _("TB")
-				elif (((size / 2) / 1024) / 1024) > 1:
-					des = _("Size: ") + str(((size / 2) / 1024) / 1024) + _("GB")
-				else:
-					des = _("Size: ") + str((size / 2) / 1024) + _("MB")
-		f.close()
-		item = NoSave(ConfigSelection(default='/media/' + device, choices=[('/media/' + device, '/media/' + device),
-		('/media/hdd', '/media/hdd'),
-		('/media/hdd2', '/media/hdd2'),
-		('/media/hdd3', '/media/hdd3'),
-		('/media/usb', '/media/usb'),
-		('/media/usb2', '/media/usb2'),
-		('/media/usb3', '/media/usb3'),
-		('/media/mmc', '/media/mmc'),
-		('/media/mmc2', '/media/mmc2'),
-		('/media/mmc3', '/media/mmc3'),
-		('/usr', '/usr')]))
-		if dtype == 'Linux':
-			dtype = 'ext3'
-		else:
-			dtype = 'auto'
-		item.value = d1.strip()
-		text = name + ' ' + des + ' /dev/' + device
-		res = getConfigListEntry(text, item, device, dtype)
-
-		if des != '' and self.list.append(res):
-			pass
-
-	def saveMypoints(self):
-		self.Console = Console()
-		mycheck = False
-		for x in self['config'].list:
-			self.device = x[2]
-			self.mountp = x[1].value
-			self.type = x[3]
-			self.Console.ePopen('umount ' + self.device)
-			self.Console.ePopen("/sbin/blkid | grep " + self.device, self.add_fstab, [self.device, self.mountp] )
-		message = _("Updating mount locations.")
-		ybox = self.session.openWithCallback(self.delay, MessageBox, message, type=MessageBox.TYPE_INFO, timeout=5, enable_input = False)
-		ybox.setTitle(_("Please wait."))
-
-	def delay(self, val):
-		message = _("Changes need a system restart to take effect.\nRestart your %s %s now?") % (getMachineBrand(), getMachineName())
-		ybox = self.session.openWithCallback(self.restartBox, MessageBox, message, MessageBox.TYPE_YESNO)
-		ybox.setTitle(_("Restart %s %s.") % (getMachineBrand(), getMachineName()))
-
-	def add_fstab(self, result = None, retval = None, extra_args = None):
-		self.device = extra_args[0]
-		self.mountp = extra_args[1]
-		self.device_tmp = result.split(' ')
-		if self.device_tmp[0].startswith('UUID='):
-			self.device_uuid = self.device_tmp[0].replace('"',"")
-			self.device_uuid = self.device_uuid.replace('\n',"")
-		elif self.device_tmp[1].startswith('UUID='):
-			self.device_uuid = self.device_tmp[1].replace('"',"")
-			self.device_uuid = self.device_uuid.replace('\n',"")
-		elif self.device_tmp[2].startswith('UUID='):
-			self.device_uuid = self.device_tmp[2].replace('"',"")
-			self.device_uuid = self.device_uuid.replace('\n',"")
-		elif self.device_tmp[3].startswith('UUID='):
-			self.device_uuid = self.device_tmp[3].replace('"',"")
-			self.device_uuid = self.device_uuid.replace('\n',"")
-		try:
-			if self.device_tmp[0].startswith('TYPE='):
-				self.device_type = self.device_tmp[0].replace('TYPE=',"")
-				self.device_type = self.device_type.replace('"',"")
-				self.device_type = self.device_type.replace('\n',"")
-			elif self.device_tmp[1].startswith('TYPE='):
-				self.device_type = self.device_tmp[1].replace('TYPE=',"")
-				self.device_type = self.device_type.replace('"',"")
-				self.device_type = self.device_type.replace('\n',"")
-			elif self.device_tmp[2].startswith('TYPE='):
-				self.device_type = self.device_tmp[2].replace('TYPE=',"")
-				self.device_type = self.device_type.replace('"',"")
-				self.device_type = self.device_type.replace('\n',"")
-			elif self.device_tmp[3].startswith('TYPE='):
-				self.device_type = self.device_tmp[3].replace('TYPE=',"")
-				self.device_type = self.device_type.replace('"',"")
-				self.device_type = self.device_type.replace('\n',"")
-			elif self.device_tmp[4].startswith('TYPE='):
-				self.device_type = self.device_tmp[4].replace('TYPE=',"")
-				self.device_type = self.device_type.replace('"',"")
-				self.device_type = self.device_type.replace('\n',"")
-		except:
-			self.device_type = 'auto'
-				
-		if self.device_type.startswith('ext'):
-			self.device_type = 'auto'
-
-		if not path.exists(self.mountp):
-			mkdir(self.mountp, 0755)
-		file('/etc/fstab.tmp', 'w').writelines([l for l in file('/etc/fstab').readlines() if self.device not in l])
-		rename('/etc/fstab.tmp','/etc/fstab')
-		file('/etc/fstab.tmp', 'w').writelines([l for l in file('/etc/fstab').readlines() if self.device_uuid not in l])
-		rename('/etc/fstab.tmp','/etc/fstab')
-		out = open('/etc/fstab', 'a')
-		line = self.device_uuid + '\t' + self.mountp + '\t' + self.device_type + '\tdefaults\t0 0\n'
-		out.write(line)
-		out.close()
-
-	def restartBox(self, answer):
-		if answer is True:
-			self.session.open(TryQuitMainloop, 2)
-		else:
-			self.close()
-
-class DevicesPanelSummary(Screen):
-	def __init__(self, session, parent):
-		Screen.__init__(self, session, parent = parent)
-		self["entry"] = StaticText("")
-		self["desc"] = StaticText("")
-		self.onShow.append(self.addWatcher)
-		self.onHide.append(self.removeWatcher)
-
-	def addWatcher(self):
-		self.parent.onChangedEntry.append(self.selectionChanged)
-		self.parent.selectionChanged()
-
-	def removeWatcher(self):
-		self.parent.onChangedEntry.remove(self.selectionChanged)
-
-	def selectionChanged(self, name, desc):
-		self["entry"].text = name
-		self["desc"].text = desc
-
-
diff --git a/lib/python/Plugins/Extensions/Openpanel/QuickMenu.py b/lib/python/Plugins/Extensions/Openpanel/QuickMenu.py
deleted file mode 100644
index a1e0da6..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/QuickMenu.py
+++ /dev/null
@@ -1,858 +0,0 @@
-
-from enigma import eListboxPythonMultiContent, gFont, eEnv, getDesktop, pNavigation
-from boxbranding import getMachineBrand, getMachineName, getBoxType, getBrandOEM
-from Components.ActionMap import ActionMap
-from Components.Label import Label
-from Components.Sources.StaticText import StaticText
-from Components.Pixmap import Pixmap
-from Components.MenuList import MenuList
-from Components.MultiContent import MultiContentEntryText, MultiContentEntryPixmapAlphaBlend
-from Components.Network import iNetwork
-from Components.NimManager import nimmanager
-from Components.SystemInfo import SystemInfo
-
-from Screens.Screen import Screen
-from Screens.ParentalControlSetup import ProtectedScreen
-from Screens.NetworkSetup import *
-from Screens.About import About
-from Screens.PluginBrowser import PluginDownloadBrowser, PluginFilter, PluginBrowser
-from Screens.LanguageSelection import LanguageSelection
-from Screens.Satconfig import NimSelection
-from Screens.ScanSetup import ScanSimple, ScanSetup
-from Screens.Setup import Setup, getSetupTitle
-from Screens.HarddiskSetup import HarddiskSelection, HarddiskFsckSelection, HarddiskConvertExt4Selection
-from Screens.SkinSelector import LcdSkinSelector, SkinSelector
-from Screens.VideoMode import VideoSetup, AudioSetup
-
-from Plugins.Plugin import PluginDescriptor
-from Plugins.SystemPlugins.NetworkWizard.NetworkWizard import NetworkWizard
-from Plugins.Extensions.Openpanel.RestartNetwork import RestartNetwork
-from Plugins.Extensions.Openpanel.MountManager import HddMount
-from Plugins.Extensions.Openpanel.SoftcamPanel import *
-from Plugins.Extensions.Openpanel.SoftwarePanel import SoftwarePanel
-from Plugins.Extensions.Openpanel.plugin import ShowSoftcamPanelExtensions
-from Plugins.SystemPlugins.SoftwareManager.Flash_online import FlashOnline
-from Plugins.SystemPlugins.SoftwareManager.ImageBackup import ImageBackup
-from Plugins.SystemPlugins.SoftwareManager.plugin import SoftwareManagerSetup, Load_defaults
-from Plugins.SystemPlugins.SoftwareManager.BackupRestore import BackupScreen, RestoreScreen, BackupSelection, getBackupPath, getOldBackupPath, getBackupFilename
-
-from Tools.Directories import resolveFilename, SCOPE_PLUGINS, SCOPE_SKIN_IMAGE, SCOPE_SKIN, fileExists
-from Tools.LoadPixmap import LoadPixmap
-
-from os import path, listdir
-from time import sleep
-from re import search
-
-import NavigationInstance
-
-if path.exists("/usr/lib/enigma2/python/Plugins/SystemPlugins/NetworkBrowser"):
-	from Plugins.SystemPlugins.NetworkBrowser.MountManager import AutoMountManager
-	from Plugins.SystemPlugins.NetworkBrowser.NetworkBrowser import NetworkBrowser
-	plugin_path_networkbrowser = eEnv.resolve("${libdir}/enigma2/python/Plugins/SystemPlugins/NetworkBrowser")
-	NETWORKBROWSER = True
-else:
-	NETWORKBROWSER = False
-
-if path.exists("/usr/lib/enigma2/python/Plugins/Extensions/AudioSync"):
-	from Plugins.Extensions.AudioSync.AC3setup import AC3LipSyncSetup
-	plugin_path_audiosync = eEnv.resolve("${libdir}/enigma2/python/Plugins/Extensions/AudioSync")
-	AUDIOSYNC = True
-else:
-	AUDIOSYNC = False
-
-if path.exists("/usr/lib/enigma2/python/Plugins/SystemPlugins/VideoEnhancement/plugin.pyo"):
-	from Plugins.SystemPlugins.VideoEnhancement.plugin import VideoEnhancementSetup
-	VIDEOENH = True
-else:
-	VIDEOENH = False
-
-if path.exists("/usr/lib/enigma2/python/Plugins/Extensions/dFlash"):
-	from Plugins.Extensions.dFlash.plugin import dFlash
-	DFLASH = True
-else:
-	DFLASH = False
-
-if path.exists("/usr/lib/enigma2/python/Plugins/Extensions/dBackup"):
-	from Plugins.Extensions.dBackup.plugin import dBackup
-	DBACKUP = True
-else:
-	DBACKUP = False
-
-if path.exists("/usr/lib/enigma2/python/Plugins/SystemPlugins/PositionerSetup/plugin.pyo"):
-	from Plugins.SystemPlugins.PositionerSetup.plugin import PositionerSetup, RotorNimSelection
-	POSSETUP = True
-else:
-	POSSETUP = False
-	
-if path.exists("/usr/lib/enigma2/python/Plugins/SystemPlugins/Satfinder/plugin.pyo"):
-	from Plugins.SystemPlugins.Satfinder.plugin import Satfinder
-	SATFINDER = True
-else:
-	SATFINDER = False
-
-def isFileSystemSupported(filesystem):
-	try:
-		for fs in open('/proc/filesystems', 'r'):
-			if fs.strip().endswith(filesystem):
-				return True
-		return False
-	except Exception, ex:
-		print "[Harddisk] Failed to read /proc/filesystems:", ex
-
-def Check_Softcam():
-	found = False
-	for x in os.listdir('/usr/CamEmu'):
-		if x.find('camemu.') > -1:
-			found = True
-			break;
-
-	return found
-
-class QuickMenu(Screen, ProtectedScreen):
-	skin = """
-		<screen name="QuickMenu" position="center,center" size="1180,600" backgroundColor="black" flags="wfBorder">
-		<widget name="list" position="21,32" size="370,400" backgroundColor="black" itemHeight="50" transparent="1" />
-		<widget name="sublist" position="410,32" size="300,400" backgroundColor="black" itemHeight="50" />
-		<eLabel position="400,30" size="2,400" backgroundColor="darkgrey" zPosition="3" />
-		<widget source="session.VideoPicture" render="Pig" position="720,30" size="450,300" backgroundColor="transparent" zPosition="1" />
-		<widget name="description" position="22,445" size="1150,110" zPosition="1" font="Regular;22" halign="center" backgroundColor="black" transparent="1" />
-		<widget name="key_red" position="20,571" size="300,26" zPosition="1" font="Regular;22" halign="center" foregroundColor="white" backgroundColor="black" transparent="1" />
-		<widget name="key_green" position="325,571" size="300,26" zPosition="1" font="Regular;22" halign="center" foregroundColor="white" backgroundColor="black" transparent="1" />
-		<widget name="key_yellow" position="630,571" size="300,26" zPosition="1" font="Regular;22" halign="center" foregroundColor="white" backgroundColor="black" transparent="1" valign="center" />
-		<widget name="key_blue" position="935,571" size="234,26" zPosition="1" font="Regular;22" halign="center" foregroundColor="white" backgroundColor="black" transparent="1" />
-		<eLabel name="new eLabel" position="21,567" size="300,3" zPosition="3" backgroundColor="red" />
-		<eLabel name="new eLabel" position="325,567" size="300,3" zPosition="3" backgroundColor="green" />
-		<eLabel name="new eLabel" position="630,567" size="300,3" zPosition="3" backgroundColor="yellow" />
-		<eLabel name="new eLabel" position="935,567" size="234,3" zPosition="3" backgroundColor="blue" />
-		</screen> """
-
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		if config.ParentalControl.configured.value:
-			ProtectedScreen.__init__(self)
-		Screen.setTitle(self, _("Quick Launch Menu"))
-		ProtectedScreen.__init__(self)
-
-		self["key_red"] = Label(_("Exit"))
-		self["key_green"] = Label(_("System Info"))
-		self["key_yellow"] = Label(_("Devices"))
-		self["key_blue"] = Label()
-		self["description"] = Label()
-		self["summary_description"] = StaticText("")
-
-		self.menu = 0
-		self.list = []
-		self["list"] = QuickMenuList(self.list)
-		self.sublist = []
-		self["sublist"] = QuickMenuSubList(self.sublist)
-		self.selectedList = []
-		self.onChangedEntry = []
-		self["list"].onSelectionChanged.append(self.selectionChanged)
-		self["sublist"].onSelectionChanged.append(self.selectionSubChanged)
-
-		self["actions"] = ActionMap(["SetupActions","WizardActions","MenuActions","MoviePlayerActions"],
-		{
-			"ok": self.ok,
-			"back": self.keyred,
-			"cancel": self.keyred,
-			"left": self.goLeft,
-			"right": self.goRight,
-			"up": self.goUp,
-			"down": self.goDown,
-		}, -1)
-
-		self["ColorActions"] = HelpableActionMap(self, "ColorActions",
-			{
-			"red": self.keyred,
-			"green": self.keygreen,
-			"yellow": self.keyyellow,
-			})
-
-		Load_defaults()
-		self.MainQmenu()
-		self.selectedList = self["list"]
-		self.selectionChanged()
-		self.onLayoutFinish.append(self.layoutFinished)
-
-	def isProtected(self):
-		return config.ParentalControl.setuppinactive.value and not config.ParentalControl.config_sections.main_menu.value and config.ParentalControl.config_sections.quickmenu.value
-
-	def createSummary(self):
-		pass
-
-	def layoutFinished(self):
-		self["sublist"].selectionEnabled(0)
-
-	def selectionChanged(self):
-		if self.selectedList == self["list"]:
-			item = self["list"].getCurrent()
-			if item:
-				self["description"].text = item[4][7]
-				self["summary_description"].text = item[0]
-				self.okList()
-
-	def selectionSubChanged(self):
-		if self.selectedList == self["sublist"]:
-			item = self["sublist"].getCurrent()
-			if item:
-				self["description"].text = item[3][7]
-				self["summary_description"].text = item[0]
-
-	def goLeft(self):
-		if self.menu <> 0:
-			self.menu = 0
-			self.selectedList = self["list"]
-			self["list"].selectionEnabled(1)
-			self["sublist"].selectionEnabled(0)
-			self.selectionChanged()
-
-	def goRight(self):
-		if self.menu == 0:
-			self.menu = 1
-			self.selectedList = self["sublist"]
-			self["sublist"].moveToIndex(0)
-			self["list"].selectionEnabled(0)
-			self["sublist"].selectionEnabled(1)
-			self.selectionSubChanged()
-
-	def goUp(self):
-		self.selectedList.up()
-		
-	def goDown(self):
-		self.selectedList.down()
-		
-	def keyred(self):
-		self.close()
-
-	def keygreen(self):
-		self.session.open(About)
-
-	def keyyellow(self):
-		self.session.open(QuickMenuDevices)
-
-######## Main Menu ##############################
-	def MainQmenu(self):
-		self.menu = 0
-		self.list = []
-		self.oldlist = []
-		self.list.append(QuickMenuEntryComponent("Software Manager",_("Update/Backup/Restore your box"),_("Update/Backup your firmware, Backup/Restore settings")))
-		if Check_Softcam():
-			self.list.append(QuickMenuEntryComponent("Softcam",_("Start/stop/select cam"),_("Start/stop/select your cam, You need to install first a softcam")))
-		self.list.append(QuickMenuEntryComponent("System",_("System Setup"),_("Setup your System")))
-		self.list.append(QuickMenuEntryComponent("Mounts",_("Mount Setup"),_("Setup your mounts for network")))
-		self.list.append(QuickMenuEntryComponent("Network",_("Setup your local network"),_("Setup your local network. For Wlan you need to boot with a USB-Wlan stick")))
-		self.list.append(QuickMenuEntryComponent("AV Setup",_("Setup Video/Audio"),_("Setup your Video Mode, Video Output and other Video Settings")))
-		self.list.append(QuickMenuEntryComponent("Tuner Setup",_("Setup Tuner"),_("Setup your Tuner and search for channels")))
-		self.list.append(QuickMenuEntryComponent("Plugins",_("Setup Plugins"),_("Shows available pluigns. Here you can download and install them")))
-		self.list.append(QuickMenuEntryComponent("Harddisk",_("Harddisk Setup"),_("Setup your Harddisk")))
-		self["list"].l.setList(self.list)
-
-######## System Setup Menu ##############################
-	def Qsystem(self):
-		self.sublist = []
-		self.sublist.append(QuickSubMenuEntryComponent("Customise",_("Setup Enigma2"),_("Customise enigma2 personal settings")))
-		self.sublist.append(QuickSubMenuEntryComponent("OSD settings",_("OSD Setup"),_("Setup your OSD")))
-		self.sublist.append(QuickSubMenuEntryComponent("Button Setup",_("Button Setup"),_("Setup your remote buttons")))
-		if SystemInfo["FrontpanelDisplay"] and SystemInfo["Display"]:
-			self.sublist.append(QuickSubMenuEntryComponent("Display Settings",_("Display Setup"),_("Setup your display")))
-		if SystemInfo["LCDSKINSetup"]:
-			self.sublist.append(QuickSubMenuEntryComponent("LCD Skin Setup",_("Select LCD Skin"),_("Setup your LCD")))
-		self.sublist.append(QuickSubMenuEntryComponent("Skin Setup",_("Select Enigma2 Skin"),_("Setup your Skin")))
-		self.sublist.append(QuickSubMenuEntryComponent("Channel selection",_("Channel selection configuration"),_("Setup your Channel selection configuration")))
-		self.sublist.append(QuickSubMenuEntryComponent("Recording settings",_("Recording Setup"),_("Setup your recording config")))
-		self.sublist.append(QuickSubMenuEntryComponent("EPG settings",_("EPG Setup"),_("Setup your EPG config")))
-		self["sublist"].l.setList(self.sublist)
-
-######## Network Menu ##############################
-	def Qnetwork(self):
-		self.sublist = []
-		self.sublist.append(QuickSubMenuEntryComponent("Network Wizard",_("Configure your Network"),_("Use the Networkwizard to configure your Network. The wizard will help you to setup your network")))
-		if len(self.adapters) > 1: # show only adapter selection if more as 1 adapter is installed
-			self.sublist.append(QuickSubMenuEntryComponent("Network Adapter Selection",_("Select Lan/Wlan"),_("Setup your network interface. If no Wlan stick is used, you only can select Lan")))
-		if not self.activeInterface == None: # show only if there is already a adapter up
-			self.sublist.append(QuickSubMenuEntryComponent("Network Interface",_("Setup interface"),_("Setup network. Here you can setup DHCP, IP, DNS")))
-		self.sublist.append(QuickSubMenuEntryComponent("Network Restart",_("Restart network to with current setup"),_("Restart network and remount connections")))
-		self.sublist.append(QuickSubMenuEntryComponent("Network Services",_("Setup Network Services"),_("Setup Network Services (Samba, Ftp, NFS, ...)")))
-		self["sublist"].l.setList(self.sublist)
-
-#### Network Services Menu ##############################
-	def Qnetworkservices(self):
-		self.sublist = []
-		self.sublist.append(QuickSubMenuEntryComponent("Samba",_("Setup Samba"),_("Setup Samba")))
-		self.sublist.append(QuickSubMenuEntryComponent("NFS",_("Setup NFS"),_("Setup NFS")))
-		self.sublist.append(QuickSubMenuEntryComponent("FTP",_("Setup FTP"),_("Setup FTP")))
-		self.sublist.append(QuickSubMenuEntryComponent("AFP",_("Setup AFP"),_("Setup AFP")))
-		self.sublist.append(QuickSubMenuEntryComponent("OpenVPN",_("Setup OpenVPN"),_("Setup OpenVPN")))
-		self.sublist.append(QuickSubMenuEntryComponent("MiniDLNA",_("Setup MiniDLNA"),_("Setup MiniDLNA")))
-		self.sublist.append(QuickSubMenuEntryComponent("Inadyn",_("Setup Inadyn"),_("Setup Inadyn")))
-		self.sublist.append(QuickSubMenuEntryComponent("SABnzbd",_("Setup SABnzbd"),_("Setup SABnzbd")))
-		self.sublist.append(QuickSubMenuEntryComponent("uShare",_("Setup uShare"),_("Setup uShare")))
-		self.sublist.append(QuickSubMenuEntryComponent("Telnet",_("Setup Telnet"),_("Setup Telnet")))
-		self.sublist.append(QuickSubMenuEntryComponent("Movistar+ Iptv Server",_("Movistar+ Iptv Server Config"),_("Movistar+ Iptv Server Config")))
-		self.sublist.append(QuickSubMenuEntryComponent("RemoteTuner",_("Setup Remote Tuner Server"),_("Setup Remote Tuner Server")))
-		self["sublist"].l.setList(self.sublist)
-
-######## Mount Settings Menu ##############################
-	def Qmount(self):
-		self.sublist = []
-		if NETWORKBROWSER == True:
-			self.sublist.append(QuickSubMenuEntryComponent("Mount Manager",_("Manage network mounts"),_("Setup your network mounts")))
-			self.sublist.append(QuickSubMenuEntryComponent("Network Browser",_("Search for network shares"),_("Search for network shares")))
-		self.sublist.append(QuickSubMenuEntryComponent("Device Manager",_("Mounts Devices"),_("Setup your Device mounts (USB, HDD, others...)")))
-		self["sublist"].l.setList(self.sublist)
-
-######## Softcam Menu ##############################
-	def Qsoftcam(self):
-		self.sublist = []
-		if Check_Softcam(): # show only when there is a softcam installed
-			self.sublist.append(QuickSubMenuEntryComponent("Softcam Panel",_("Control your Softcams"),_("Use the Softcam Panel to control your Cam. This let you start/stop/select a cam")))
-			self.sublist.append(QuickSubMenuEntryComponent(_("Softcam-Panel Setup"),_("Softcam-Panel Setup"),_('Softcam-Panel Setup')))
-		self.sublist.append(QuickSubMenuEntryComponent("Download Softcams",_("Download and install cam"),_("Shows available softcams. Here you can download and install them")))
-		self["sublist"].l.setList(self.sublist)
-
-######## A/V Settings Menu ##############################
-	def Qavsetup(self):
-		self.sublist = []
-		self.sublist.append(QuickSubMenuEntryComponent("Video Settings",_("Setup Videomode"),_("Setup your Video Mode, Video Output and other Video Settings")))
-		self.sublist.append(QuickSubMenuEntryComponent("Audio Settings",_("Setup Audiomode"),_("Setup your Audio Mode")))
-		if AUDIOSYNC == True:
-			self.sublist.append(QuickSubMenuEntryComponent("Audio Sync",_("Setup Audio Sync"),_("Setup Audio Sync settings")))
-		self.sublist.append(QuickSubMenuEntryComponent("Auto Language",_("Auto Language Selection"),_("Select your Language for Audio/Subtitles")))
-		if os_path.exists("/proc/stb/vmpeg/0/pep_apply") and VIDEOENH == True:
-			self.sublist.append(QuickSubMenuEntryComponent("VideoEnhancement",_("VideoEnhancement Setup"),_("VideoEnhancement Setup")))
-
-		self["sublist"].l.setList(self.sublist)
-
-######## Tuner Menu ##############################
-	def Qtuner(self):
-		self.sublist = []
-		self.sublist.append(QuickSubMenuEntryComponent("Tuner Configuration",_("Setup tuner(s)"),_("Setup each tuner for your satellite system")))
-		if POSSETUP == True:
-			self.sublist.append(QuickSubMenuEntryComponent("Positioner Setup",_("Setup rotor"),_("Setup your positioner for your satellite system")))
-		self.sublist.append(QuickSubMenuEntryComponent("Automatic Scan",_("Automatic Service Searching"),_("Automatic scan for services")))
-		self.sublist.append(QuickSubMenuEntryComponent("Manual Scan",_("Manual Service Searching"),_("Manual scan for services")))
-		if SATFINDER == True:
-			self.sublist.append(QuickSubMenuEntryComponent("Sat Finder",_("Search Sats"),_("Search Sats, check signal and lock")))
-		self["sublist"].l.setList(self.sublist)
-
-######## Software Manager Menu ##############################
-	def Qsoftware(self):
-		self.sublist = []
-		self.sublist.append(QuickSubMenuEntryComponent("Software Update",_("Online software update"),_("Check/Install online updates (you must have a working internet connection)")))
-		if not getBoxType().startswith('az') and not getBoxType() in ('dm500hd','dm500hdv2','dm520','dm800','dm800se','dm800sev2','dm820','dm7020hd','dm7020hdv2','dm7080','dm8000') and not getBrandOEM().startswith('cube'):
-			self.sublist.append(QuickSubMenuEntryComponent("Flash Online",_("Flash Online a new image"),_("Flash on the fly your your Receiver software.")))
-		if not getBoxType().startswith('az') and not getBrandOEM().startswith('cube') and not getBrandOEM().startswith('wetek'):
-			self.sublist.append(QuickSubMenuEntryComponent("Complete Backup",_("Backup your current image"),_("Backup your current image to HDD or USB. This will make a 1:1 copy of your box")))
-		self.sublist.append(QuickSubMenuEntryComponent("Backup Settings",_("Backup your current settings"),_("Backup your current settings. This includes E2-setup, channels, network and all selected files")))
-		self.sublist.append(QuickSubMenuEntryComponent("Restore Settings",_("Restore settings from a backup"),_("Restore your settings back from a backup. After restore the box will restart to activated the new settings")))
-		self.sublist.append(QuickSubMenuEntryComponent("Show default backup files",_("Show files backed up by default"),_("Here you can browse (but not modify) the files that are added to the backupfile by default (E2-setup, channels, network).")))
-		self.sublist.append(QuickSubMenuEntryComponent("Select additional backup files",_("Select additional files to backup"),_("Here you can specify additional files that should be added to the backup file.")))
-		self.sublist.append(QuickSubMenuEntryComponent("Select excluded backup files",_("Select files to exclude from backup"),_("Here you can select which files should be excluded from the backup.")))
-		self.sublist.append(QuickSubMenuEntryComponent("Software Manager Setup",_("Manage your online update files"),_("Here you can select which files should be updated with a online update")))
-		self["sublist"].l.setList(self.sublist)
-
-######## Plugins Menu ##############################
-	def Qplugin(self):
-		self.sublist = []
-		self.sublist.append(QuickSubMenuEntryComponent("Plugin Browser",_("Open the Plugin Browser"),_("Shows Plugins Browser. Here you can setup installed Plugin")))
-		self.sublist.append(QuickSubMenuEntryComponent("Download Plugins",_("Download and install Plugins"),_("Shows available plugins. Here you can download and install them")))
-		self.sublist.append(QuickSubMenuEntryComponent("Remove Plugins",_("Delete Plugins"),_("Delete and unstall Plugins. This will remove the Plugin from your box")))
-		self.sublist.append(QuickSubMenuEntryComponent("Plugin Filter",_("Setup Plugin filter"),_("Setup Plugin filter. Here you can select which Plugins are showed in the PluginBrowser")))
-		self.sublist.append(QuickSubMenuEntryComponent("IPK Installer",_("Install local extension"),_("Scan for local extensions and install them")))
-		self["sublist"].l.setList(self.sublist)
-
-######## Harddisk Menu ##############################
-	def Qharddisk(self):
-		self.sublist = []
-		self.sublist.append(QuickSubMenuEntryComponent("Harddisk Setup",_("Harddisk Setup"),_("Setup your Harddisk")))
-		self.sublist.append(QuickSubMenuEntryComponent("Initialization",_("Format HDD"),_("Format your Harddisk")))
-		self.sublist.append(QuickSubMenuEntryComponent("Filesystem Check",_("Check HDD"),_("Filesystem check your Harddisk")))
-		if isFileSystemSupported("ext4"):
-			self.sublist.append(QuickSubMenuEntryComponent("Convert ext3 to ext4",_("Convert filesystem ext3 to ext4"),_("Convert filesystem ext3 to ext4")))
-		self["sublist"].l.setList(self.sublist)
-
-	def ok(self):
-		if self.menu > 0:
-			self.okSubList()
-		else:
-			self.goRight()
-
-
-#####################################################################
-######## Make Selection MAIN MENU LIST ##############################
-#####################################################################
-			
-	def okList(self):
-		item = self["list"].getCurrent()
-
-######## Select Network Menu ##############################
-		if item[0] == _("Network"):
-			self.GetNetworkInterfaces()
-			self.Qnetwork()
-######## Select System Setup Menu ##############################
-		elif item[0] == _("System"):
-			self.Qsystem()
-######## Select Mount Menu ##############################
-		elif item[0] == _("Mounts"):
-			self.Qmount()
-######## Select Softcam Menu ##############################
-		elif item[0] == _("Softcam"):
-			self.Qsoftcam()
-######## Select AV Setup Menu ##############################
-		elif item[0] == _("AV Setup"):
-			self.Qavsetup()
-######## Select Tuner Setup Menu ##############################
-		elif item[0] == _("Tuner Setup"):
-			self.Qtuner()
-######## Select Software Manager Menu ##############################
-		elif item[0] == _("Software Manager"):
-			self.Qsoftware()
-######## Select PluginDownloadBrowser Menu ##############################
-		elif item[0] == _("Plugins"):
-			self.Qplugin()
-######## Select Tuner Setup Menu ##############################
-		elif item[0] == _("Harddisk"):
-			self.Qharddisk()
-
-		self["sublist"].selectionEnabled(0)
-
-#####################################################################
-######## Make Selection SUB MENU LIST ##############################
-#####################################################################
-			
-	def okSubList(self):
-		item = self["sublist"].getCurrent()
-
-######## Select Network Menu ##############################
-		if item[0] == _("Network Wizard"):
-			self.session.open(NetworkWizard)
-		elif item[0] == _("Network Adapter Selection"):
-			self.session.open(NetworkAdapterSelection)
-		elif item[0] == _("Network Interface"):
-			self.session.open(AdapterSetup,self.activeInterface)
-		elif item[0] == _("Network Restart"):
-			self.session.open(RestartNetwork)
-		elif item[0] == _("Network Services"):
-			self.Qnetworkservices()
-			self["sublist"].moveToIndex(0)
-		elif item[0] == _("Samba"):
-			self.session.open(NetworkSamba)
-		elif item[0] == _("NFS"):
-			self.session.open(NetworkNfs)
-		elif item[0] == _("FTP"):
-			self.session.open(NetworkFtp)
-		elif item[0] == _("AFP"):
-			self.session.open(NetworkAfp)
-		elif item[0] == _("OpenVPN"):
-			self.session.open(NetworkOpenvpn)
-		elif item[0] == _("MiniDLNA"):
-			self.session.open(NetworkMiniDLNA)
-		elif item[0] == _("Inadyn"):
-			self.session.open(NetworkInadyn)
-		elif item[0] == _("SABnzbd"):
-			self.session.open(NetworkSABnzbd)
-		elif item[0] == _("uShare"):
-			self.session.open(NetworkuShare)
-		elif item[0] == _("Telnet"):
-			self.session.open(NetworkTelnet)
-                elif item[0] == _("RemoteTuner"):
-			self.session.open(RemoteTunerServer)
-                elif item[0] == _("Movistar+ Iptv Server"):
-			self.session.open(udpxyServer)
-######## Select System Setup Menu ##############################
-		elif item[0] == _("Customise"):
-			self.openSetup("usage")
-		elif item[0] == _("Button Setup"):
-			self.openSetup("remotesetup")
-		elif item[0] == _("Display Settings"):
-			self.openSetup("display")
-		elif item[0] == _("LCD Skin Setup"):
-			self.session.open(LcdSkinSelector)
-		elif item[0] == _("Skin Setup"):
-			self.session.open(SkinSelector)	
-		elif item[0] == _("OSD settings"):
-			self.openSetup("userinterface")
-		elif item[0] == _("Channel selection"):
-			self.openSetup("channelselection")
-		elif item[0] == _("Recording settings"):
-			self.openSetup("recording")
-		elif item[0] == _("EPG settings"):
-			self.openSetup("epgsettings")
-######## Select Mounts Menu ##############################
-		elif item[0] == _("Mount Manager"):
-			self.session.open(AutoMountManager, None, plugin_path_networkbrowser)
-		elif item[0] == _("Network Browser"):
-			self.session.open(NetworkBrowser, None, plugin_path_networkbrowser)
-		elif item[0] == _("Device Manager"):
-			self.session.open(HddMount)
-######## Select Softcam Menu ##############################
-		elif item[0] == _("Softcam Panel"):
-			self.session.open(SoftcamPanel)
-		elif item[0] == _("Softcam-Panel Setup"):
-			self.session.open(ShowSoftcamPanelExtensions)
-		elif item[0] == _("Download Softcams"):
-			self.session.open(ShowSoftcamPackages)
-######## Select AV Setup Menu ##############################
-		elif item[0] == _("Video Settings"):
-			self.session.open(VideoSetup)
-		elif item[0] == _("Audio Settings"):
-			self.session.open(AudioSetup)
-		elif item[0] == _("Auto Language"):
-			self.openSetup("autolanguagesetup")
-		elif item[0] == _("Audio Sync"):
-			self.session.open(AC3LipSyncSetup, plugin_path_audiosync)
-		elif item[0] == _("VideoEnhancement"):
-			self.session.open(VideoEnhancementSetup)
-######## Select TUNER Setup Menu ##############################
-		elif item[0] == _("Tuner Configuration"):
-			self.session.open(NimSelection)
-		elif item[0] == _("Positioner Setup"):
-			self.PositionerMain()
-		elif item[0] == _("Automatic Scan"):
-			self.session.open(ScanSimple)
-		elif item[0] == _("Manual Scan"):
-			self.session.open(ScanSetup)
-		elif item[0] == _("Sat Finder"):
-			self.SatfinderMain()
-######## Select Software Manager Menu ##############################
-		elif item[0] == _("Software Update"):
-			self.session.open(SoftwarePanel)
-		elif item[0] == _("Flash Online"):
-			self.session.open(FlashOnline)
-		elif item[0] == _("Complete Backup"):
-			if DFLASH == True:
-				self.session.open(dFlash)
-			elif DBACKUP == True:
-				self.session.open(dBackup)
-			else:
-				self.session.open(ImageBackup)
-		elif item[0] == _("Backup Settings"):
-			self.session.openWithCallback(self.backupDone,BackupScreen, runBackup = True)
-		elif item[0] == _("Restore Settings"):
-			self.backuppath = getBackupPath()
-			if not path.isdir(self.backuppath):
-				self.backuppath = getOldBackupPath()
-			self.backupfile = getBackupFilename()
-			self.fullbackupfilename = self.backuppath + "/" + self.backupfile
-			if os_path.exists(self.fullbackupfilename):
-				self.session.openWithCallback(self.startRestore, MessageBox, _("Are you sure you want to restore your %s %s backup?\nSTB will restart after the restore") % (getMachineBrand(), getMachineName()),default = False)
-			else:
-				self.session.open(MessageBox, _("Sorry no backups found!"), MessageBox.TYPE_INFO, timeout = 10)
-		elif item[0] == _("Show default backup files"):
-			self.session.open(BackupSelection,title=_("Default files/folders to backup"),configBackupDirs=config.plugins.configurationbackup.backupdirs_default,readOnly=True)
-		elif item[0] == _("Select additional backup files"):
-			self.session.open(BackupSelection,title=_("Additional files/folders to backup"),configBackupDirs=config.plugins.configurationbackup.backupdirs,readOnly=False)
-		elif item[0] == _("Select excluded backup files"):
-			self.session.open(BackupSelection,title=_("Files/folders to exclude from backup"),configBackupDirs=config.plugins.configurationbackup.backupdirs_exclude,readOnly=False)
-		elif item[0] == _("Software Manager Setup"):
-			self.session.open(SoftwareManagerSetup)
-######## Select PluginDownloadBrowser Menu ##############################
-		elif item[0] == _("Plugin Browser"):
-			self.session.open(PluginBrowser)
-		elif item[0] == _("Download Plugins"):
-			self.session.open(PluginDownloadBrowser, 0)
-		elif item[0] == _("Remove Plugins"):
-			self.session.open(PluginDownloadBrowser, 1)
-		elif item[0] == _("Plugin Filter"):
-			self.session.open(PluginFilter)
-		elif item[0] == _("IPK Installer"):
-			try:
-				from Plugins.Extensions.MediaScanner.plugin import main
-				main(self.session)
-			except:
-				self.session.open(MessageBox, _("Sorry MediaScanner is not installed!"), MessageBox.TYPE_INFO, timeout = 10)
-######## Select Harddisk Menu ############################################
-		elif item[0] == _("Harddisk Setup"):
-			self.openSetup("harddisk")
-		elif item[0] == _("Initialization"):
-			self.session.open(HarddiskSelection)
-		elif item[0] == _("Filesystem Check"):
-			self.session.open(HarddiskFsckSelection)
-		elif item[0] == _("Convert ext3 to ext4"):
-			self.session.open(HarddiskConvertExt4Selection)
-
-######## OPEN SETUP MENUS ####################
-	def openSetup(self, dialog):
-		self.session.openWithCallback(self.menuClosed, Setup, dialog)
-
-	def menuClosed(self, *res):
-		pass
-
-######## NETWORK TOOLS #######################
-	def GetNetworkInterfaces(self):
-		self.adapters = [(iNetwork.getFriendlyAdapterName(x),x) for x in iNetwork.getAdapterList()]
-
-		if not self.adapters:
-			self.adapters = [(iNetwork.getFriendlyAdapterName(x),x) for x in iNetwork.getConfiguredAdapters()]
-
-		if len(self.adapters) == 0:
-			self.adapters = [(iNetwork.getFriendlyAdapterName(x),x) for x in iNetwork.getInstalledAdapters()]
-
-		self.activeInterface = None
-	
-		for x in self.adapters:
-			if iNetwork.getAdapterAttribute(x[1], 'up') is True:
-				self.activeInterface = x[1]
-				return
-
-######## TUNER TOOLS #######################
-	def PositionerMain(self):
-		nimList = nimmanager.getNimListOfType("DVB-S")
-		if len(nimList) == 0:
-			self.session.open(MessageBox, _("No positioner capable frontend found."), MessageBox.TYPE_ERROR)
-		else:
-			if len(NavigationInstance.instance.getRecordings(False,pNavigation.isAnyRecording)) > 0:
-				self.session.open(MessageBox, _("A recording is currently running. Please stop the recording before trying to configure the positioner."), MessageBox.TYPE_ERROR)
-			else:
-				usableNims = []
-				for x in nimList:
-					configured_rotor_sats = nimmanager.getRotorSatListForNim(x)
-					if len(configured_rotor_sats) != 0:
-						usableNims.append(x)
-				if len(usableNims) == 1:
-					self.session.open(PositionerSetup, usableNims[0])
-				elif len(usableNims) > 1:
-					self.session.open(RotorNimSelection)
-				else:
-					self.session.open(MessageBox, _("No tuner is configured for use with a diseqc positioner!"), MessageBox.TYPE_ERROR)
-
-	def SatfinderMain(self):
-		nims = nimmanager.getNimListOfType("DVB-S")
-
-		nimList = []
-		for x in nims:
-			if not nimmanager.getNimConfig(x).dvbs.configMode.value in ("loopthrough", "satposdepends", "nothing"):
-				nimList.append(x)
-
-		if len(nimList) == 0:
-			self.session.open(MessageBox, _("No satellite frontend found!!"), MessageBox.TYPE_ERROR)
-		else:
-			if len(NavigationInstance.instance.getRecordings(False,pNavigation.isAnyRecording)) > 0:
-				self.session.open(MessageBox, _("A recording is currently running. Please stop the recording before trying to start the satfinder."), MessageBox.TYPE_ERROR)
-			else:
-				self.session.open(Satfinder)
-		
-######## SOFTWARE MANAGER TOOLS #######################
-	def backupDone(self,retval = None):
-		if retval is True:
-			self.session.open(MessageBox, _("Backup done."), MessageBox.TYPE_INFO, timeout = 10)
-		else:
-			self.session.open(MessageBox, _("Backup failed."), MessageBox.TYPE_INFO, timeout = 10)
-
-	def startRestore(self, ret = False):
-		if (ret == True):
-			self.exe = True
-			self.session.open(RestoreScreen, runRestore = True)
-
-
-######## Create MENULIST format #######################
-def QuickMenuEntryComponent(name, description, long_description = None, width=540):
-	pngname = name.replace(" ","_") 
-	png = LoadPixmap("/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/" + pngname + ".png")
-	if png is None:
-		png = LoadPixmap("/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/default.png")
-
-	screenwidth = getDesktop(0).size().width()
-	if screenwidth and screenwidth == 1920:
-		width *= 1.5
-		return [
-			_(name),
-			MultiContentEntryText(pos=(90, 5), size=(width-90, 40), font=0, text = _(name)),
-			MultiContentEntryText(pos=(90, 42), size=(width-90, 37), font=1, text = _(description)),
-			MultiContentEntryPixmapAlphaBlend(pos=(15, 18), size=(60, 60), png = png),
-			MultiContentEntryText(pos=(0, 0), size=(0, 0), font=0, text = _(long_description))
-		]
-	else:
-		return [
-			_(name),
-			MultiContentEntryText(pos=(60, 3), size=(width-60, 25), font=0, text = _(name)),
-			MultiContentEntryText(pos=(60, 25), size=(width-60, 20), font=1, text = _(description)),
-			MultiContentEntryPixmapAlphaBlend(pos=(10, 5), size=(40, 40), png = png),
-			MultiContentEntryText(pos=(0, 0), size=(0, 0), font=0, text = _(long_description))
-		]
-
-def QuickSubMenuEntryComponent(name, description, long_description = None, width=600):
-	screenwidth = getDesktop(0).size().width()
-	if screenwidth and screenwidth == 1920:
-		width *= 1.5
-		return [
-			_(name),
-			MultiContentEntryText(pos=(15, 5), size=(width-15, 40), font=0, text = _(name)),
-			MultiContentEntryText(pos=(15, 42), size=(width-15, 37), font=1, text = _(description)),
-			MultiContentEntryText(pos=(0, 0), size=(0, 0), font=0, text = _(long_description))
-		]
-	else:
-		return [
-			_(name),
-			MultiContentEntryText(pos=(10, 3), size=(width-10, 25), font=0, text = _(name)),
-			MultiContentEntryText(pos=(10, 25), size=(width-10, 20), font=1, text = _(description)),
-			MultiContentEntryText(pos=(0, 0), size=(0, 0), font=0, text = _(long_description))
-		]
-
-class QuickMenuList(MenuList):
-	def __init__(self, list, enableWrapAround=True):
-		MenuList.__init__(self, list, enableWrapAround, eListboxPythonMultiContent)
-		screenwidth = getDesktop(0).size().width()
-		if screenwidth and screenwidth == 1920:
-			self.l.setFont(0, gFont("Regular", 28))
-			self.l.setFont(1, gFont("Regular", 20))
-			self.l.setItemHeight(80)
-		else:
-			self.l.setFont(0, gFont("Regular", 20))
-			self.l.setFont(1, gFont("Regular", 16))
-			self.l.setItemHeight(50)
-
-class QuickMenuSubList(MenuList):
-	def __init__(self, sublist, enableWrapAround=True):
-		MenuList.__init__(self, sublist, enableWrapAround, eListboxPythonMultiContent)
-		screenwidth = getDesktop(0).size().width()
-		if screenwidth and screenwidth == 1920:
-			self.l.setFont(0, gFont("Regular", 26))
-			self.l.setFont(1, gFont("Regular", 20))
-			self.l.setItemHeight(80)
-		else:
-			self.l.setFont(0, gFont("Regular", 20))
-			self.l.setFont(1, gFont("Regular", 16))
-			self.l.setItemHeight(50)
-
-class QuickMenuDevices(Screen):
-	skin = """
-		<screen name="QuickMenuDevices" position="center,center" size="840,525" title="Devices" flags="wfBorder">
-		<widget source="devicelist" render="Listbox" position="30,46" size="780,450" font="Regular;16" scrollbarMode="showOnDemand" transparent="1" backgroundColorSelected="grey" foregroundColorSelected="black">
-		<convert type="TemplatedMultiContent">
-				{"template": [
-				 MultiContentEntryText(pos = (90, 0), size = (600, 30), font=0, text = 0),
-				 MultiContentEntryText(pos = (110, 30), size = (600, 50), font=1, flags = RT_VALIGN_TOP, text = 1),
-				 MultiContentEntryPixmapAlphaBlend(pos = (0, 0), size = (80, 80), png = 2),
-				],
-				"fonts": [gFont("Regular", 24),gFont("Regular", 20)],
-				"itemHeight": 85
-				}
-			</convert>
-	</widget>
-	<widget name="lab1" zPosition="2" position="126,92" size="600,40" font="Regular;22" halign="center" backgroundColor="black" transparent="1" />
-	</screen> """
-
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Devices"))
-		self['lab1'] = Label()
-		self.devicelist = []
-		self['devicelist'] = List(self.devicelist)
-
-		self['actions'] = ActionMap(['WizardActions'], 
-		{
-			'back': self.close,
-		})
-		self.activityTimer = eTimer()
-		self.activityTimer.timeout.get().append(self.updateList2)
-		self.updateList()
-
-	def updateList(self, result = None, retval = None, extra_args = None):
-		scanning = _("Wait please while scanning for devices...")
-		self['lab1'].setText(scanning)
-		self.activityTimer.start(10)
-
-	def updateList2(self):
-		self.activityTimer.stop()
-		self.devicelist = []
-		list2 = []
-		f = open('/proc/partitions', 'r')
-		for line in f.readlines():
-			parts = line.strip().split()
-			if not parts:
-				continue
-			device = parts[3]
-			if not search('sd[a-z][1-9]',device):
-				continue
-			if device in list2:
-				continue
-			self.buildMy_rec(device)
-			list2.append(device)
-
-		f.close()
-		self['devicelist'].list = self.devicelist
-		if len(self.devicelist) == 0:
-			self['lab1'].setText(_("No Devices Found !!"))
-		else:
-			self['lab1'].hide()
-
-	def buildMy_rec(self, device):
-		device2 = device[:-1]	#strip device number
-		devicetype = path.realpath('/sys/block/' + device2 + '/device')
-		d2 = device
-		name = 'USB: '
-		mypixmap = '/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/dev_usbstick.png'
-		model = file('/sys/block/' + device2 + '/device/model').read()
-		model = str(model).replace('\n', '')
-		des = ''
-		if devicetype.find('/devices/pci') != -1:
-			name = _("HARD DISK: ")
-			mypixmap = '/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/dev_hdd.png'
-		name = name + model
-
-		from Components.Console import Console
-		self.Console = Console()
-		self.Console.ePopen("sfdisk -l /dev/sd? | grep swap | awk '{print $(NF-9)}' >/tmp/devices.tmp")
-		sleep(0.5)
-		f = open('/tmp/devices.tmp', 'r')
-		swapdevices = f.read()
-		f.close()
-		swapdevices = swapdevices.replace('\n','')
-		swapdevices = swapdevices.split('/')
-		f = open('/proc/mounts', 'r')
-		for line in f.readlines():
-			if line.find(device) != -1:
-				parts = line.strip().split()
-				d1 = parts[1]
-				dtype = parts[2]
-				rw = parts[3]
-				break
-				continue
-			else:
-				if device in swapdevices:
-					parts = line.strip().split()
-					d1 = _("None")
-					dtype = 'swap'
-					rw = _("None")
-					break
-					continue
-				else:
-					d1 = _("None")
-					dtype = _("unavailable")
-					rw = _("None")
-		f.close()
-		f = open('/proc/partitions', 'r')
-		for line in f.readlines():
-			if line.find(device) != -1:
-				parts = line.strip().split()
-				size = int(parts[2])
-				if ((size / 1024) / 1024) > 1:
-					des = _("Size: ") + str((size / 1024) / 1024) + _("GB")
-				else:
-					des = _("Size: ") + str(size / 1024) + _("MB")
-			else:
-				try:
-					size = file('/sys/block/' + device2 + '/' + device + '/size').read()
-					size = str(size).replace('\n', '')
-					size = int(size)
-				except:
-					size = 0
-				if (((size / 2) / 1024) / 1024) > 1:
-					des = _("Size: ") + str(((size / 2) / 1024) / 1024) + _("GB")
-				else:
-					des = _("Size: ") + str((size / 2) / 1024) + _("MB")
-		f.close()
-		if des != '':
-			if rw.startswith('rw'):
-				rw = ' R/W'
-			elif rw.startswith('ro'):
-				rw = ' R/O'
-			else:
-				rw = ""
-			des += '\t' + _("Mount: ") + d1 + '\n' + _("Device: ") + ' /dev/' + device + '\t' + _("Type: ") + dtype + rw
-			png = LoadPixmap(mypixmap)
-			res = (name, des, png)
-			self.devicelist.append(res)
-
-
diff --git a/lib/python/Plugins/Extensions/Openpanel/RestartNetwork.py b/lib/python/Plugins/Extensions/Openpanel/RestartNetwork.py
deleted file mode 100644
index 713b996..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/RestartNetwork.py
+++ /dev/null
@@ -1,29 +0,0 @@
-from Components.Network import iNetwork
-from Screens.MessageBox import MessageBox
-from Screens.Screen import Screen
-from Components.Label import Label
-
-class RestartNetwork(Screen):
-    def __init__(self, session):
-        Screen.__init__(self, session)
-        skin = """
-            <screen name="RestartNetwork" position="center,center" size="600,100" title="Restart Network Adapter">
-            <widget name="label" position="10,30" size="500,50" halign="center" font="Regular;20" transparent="1" foregroundColor="white" />
-            </screen> """
-        self.skin = skin
-        self["label"] = Label(_("Please wait while your network is restarting..."))
-        self.onShown.append(self.setWindowTitle)
-        self.onLayoutFinish.append(self.restartLan)
-
-    def setWindowTitle(self):
-        self.setTitle(_("Restart Network Adapter"))
-
-    def restartLan(self):
-        iNetwork.restartNetwork(self.restartLanDataAvail)
-  
-    def restartLanDataAvail(self, data):
-        if data is True:
-            iNetwork.getInterfaces(self.getInterfacesDataAvail)
-
-    def getInterfacesDataAvail(self, data):
-        self.close()
\ No newline at end of file
diff --git a/lib/python/Plugins/Extensions/Openpanel/ScriptRunner.py b/lib/python/Plugins/Extensions/Openpanel/ScriptRunner.py
deleted file mode 100644
index 9c77852..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/ScriptRunner.py
+++ /dev/null
@@ -1,80 +0,0 @@
-from Plugins.Plugin import PluginDescriptor
-from Screens.Screen import Screen
-from Screens.Console import Console
-from Screens.ChoiceBox import ChoiceBox
-from Screens.MessageBox import MessageBox
-from Components.ActionMap import ActionMap, HelpableActionMap
-from Components.Label import Label
-from Components.Language import language
-from Components.Button import Button
-from Components.MenuList import MenuList
-from Components.Sources.List import List
-from Screens.Standby import TryQuitMainloop
-from Tools.Directories import resolveFilename, SCOPE_PLUGINS, SCOPE_CURRENT_SKIN
-from os import listdir, remove, mkdir, path, access, X_OK, chmod
-import datetime, time
-
-class ScriptRunner(Screen):
-	skin = """<screen name="ScriptRunner" position="center,center" size="560,400" title="Script Runner" flags="wfBorder" >
-		<ePixmap pixmap="skin_default/buttons/red.png" position="0,0" size="140,40" alphatest="on" />
-		<ePixmap pixmap="skin_default/buttons/green.png" position="140,0" size="140,40" alphatest="on" />
-		<widget name="key_red" position="0,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#9f1313" transparent="1" />
-		<widget name="key_green" position="140,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#1f771f" transparent="1" />
-		<widget name="lab1" position="0,50" size="560,50" font="Regular; 20" zPosition="2" transparent="0" halign="center"/>
-		<widget name="list" position="10,105" size="540,300" scrollbarMode="showOnDemand" />
-		<applet type="onLayoutFinish">
-			self["list"].instance.setItemHeight(25)
-		</applet>
-	</screen>"""
-
-
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Job Manager"))
-		self['lab1'] = Label()
-		self.list = []
-		self.populate_List()
-		self['list'] = MenuList(self.list)
-		self['myactions'] = ActionMap(['ColorActions', 'OkCancelActions', 'DirectionActions'],
-			{
-				'cancel': self.close,
-				'red': self.close,
-				'green': self.runscript,
-				'ok': self.runscript,
-			}, -1)
-
-		self["key_red"] = Button(_("Close"))
-		self["key_green"] = Button(_("Run"))
-		
-	def populate_List(self):
-		if not path.exists('/usr/script'):
-			mkdir('/usr/script', 0755)
-		self['lab1'].setText(_("Select a script to run:"))
-		del self.list[:]
-		f = listdir('/usr/script')
-		for line in f:
-			parts = line.split()
-			pkg = parts[0]
-			if pkg.find('.sh') >= 0:
-				self.list.append(pkg)
-		self.list.sort()	
-
-	def runscript(self):
-		self.sel = self['list'].getCurrent()
-		if self.sel:
-			message = _("Are you ready to run the script ?")
-			ybox = self.session.openWithCallback(self.Run, MessageBox, message, MessageBox.TYPE_YESNO)
-			ybox.setTitle(_("Run Confirmation"))
-		else:
-			self.session.open(MessageBox, _("You have no script to run."), MessageBox.TYPE_INFO, timeout = 10)
-
-	def Run(self,answer):
-		if answer is True:
-			if not access("/usr/script/" + self.sel, X_OK):
-				chmod("/usr/script/" + self.sel, 0755)
-			cmd1 = ". /usr/script/" + self.sel
-			self.session.open(Console, title=self.sel, cmdlist = [cmd1], closeOnSuccess = False)	
-					
-	def myclose(self):
-		self.close()
-		
\ No newline at end of file
diff --git a/lib/python/Plugins/Extensions/Openpanel/SoftcamPanel.py b/lib/python/Plugins/Extensions/Openpanel/SoftcamPanel.py
deleted file mode 100644
index 3e492b8..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/SoftcamPanel.py
+++ /dev/null
@@ -1,866 +0,0 @@
-from Components.config import config, ConfigSubsection, ConfigText, configfile, getConfigListEntry, ConfigSelection
-from Components.ConfigList import ConfigListScreen
-from Components.MultiContent import MultiContentEntryText, MultiContentEntryPixmapAlphaBlend
-from Components.MenuList import MenuList
-from Components.Label import Label
-from Screens.Screen import Screen
-from Components.ActionMap import ActionMap
-from Components.Sources.List import List
-from Components.Sources.StaticText import StaticText
-from Tools.LoadPixmap import LoadPixmap
-from Tools.Directories import resolveFilename, SCOPE_CURRENT_PLUGIN, SCOPE_CURRENT_SKIN, fileExists
-from Screens.MessageBox import MessageBox
-from Screens.Console import Console
-from enigma import *
-import os
-from Screens.CCcamInfo import CCcamInfoMain
-from Screens.OScamInfo import OscamInfoMenu
-
-# modificacion ruta la original es /etc y en if x.find('.emu')
-def Check_Softcam():
-	found = False
-	for x in os.listdir('/usr/CamEmu/'):
-		if x.find('camemu.') > -1:
-			found = True
-			break;
-	return found
-
-def command(comandline, strip=1):
-	comandline = comandline + " >/tmp/command.txt"
-	os.system(comandline)
-	text = ""
-	if os.path.exists("/tmp/command.txt") is True:
-		file = open("/tmp/command.txt", "r")
-		if strip == 1:
-			for line in file:
-				text = text + line.strip() + '\n'
-		else:
-			for line in file:
-				text = text + line
-				if text[-1:] != '\n': text = text + "\n"
-		file.close()
-	# if one or last line then remove linefeed
-	if text[-1:] == '\n': text = text[:-1]
-	comandline = text
-	os.system("rm /tmp/command.txt")
-	return comandline
-
-#class EMUlist(MenuList):
-#	def __init__(self, list=[], enableWrapAround = False):
-#		MenuList.__init__(self, list, enableWrapAround, eListboxPythonMultiContent)
-#		Schriftart = 22
-#		self.l.setFont(0, gFont("Regular", Schriftart))
-#		self.l.setItemHeight(24)
-
-#	def moveSelection(self,idx=0):
-#		if self.instance is not None:
-#			self.instance.moveSelectionTo(idx)
-
-SOFTCAM_SKIN = """<screen name="SoftcamPanel" position="center,center" size="500,450" title="Softcam Panel">
-	<eLabel font="Regular;22" position="10,10" size="185,25" text="Softcam Selection:" />
-	<widget font="Regular;18" name="camcount" position="420,10" size="60,25" />
-	<widget name="config" position="10,100" size="400,100" />
-	<eLabel backgroundColor="red" position="10,60" size="120,3" zPosition="0" />
-	<eLabel backgroundColor="green" position="130,60" size="120,3" zPosition="0" />
-	<eLabel backgroundColor="yellow" position="250,60" size="120,3" zPosition="0" />
-	<eLabel backgroundColor="blue" position="370,60" size="120,3" zPosition="0" />
-	<widget font="Regular;16" halign="center" name="key_red" position="10,62" size="120,35" transparent="1" valign="center" zPosition="2" />
-	<widget font="Regular;16" halign="center" name="key_green" position="130,62" size="120,35" transparent="1" valign="center" zPosition="2" />
-	<widget font="Regular;16" halign="center" name="key_yellow" position="250,62" size="120,35" transparent="1" valign="center" zPosition="2" />
-	<widget font="Regular;16" halign="center" name="key_blue" position="370,62" size="120,35" transparent="1" valign="center" zPosition="2" />
-	<eLabel backgroundColor="#56C856" position="0,199" size="500,1" zPosition="0" />
-	<widget font="Regular;16" name="actifcam" position="10,205" size="220,32" />
-	<widget font="Regular;16" name="actifcam2" position="250,205" size="220,32" />
-	<eLabel backgroundColor="#56C856" position="0,225" size="500,1" zPosition="0" />
-	<widget font="Regular;16" name="ecminfo" position="10,235" size="480,300" />
-</screen>"""
-
-
-REFRESH = 0
-CCCAMINFO = 1
-OSCAMINFO = 2
-
-# aqui cambio ruta: ruta original emuDir = "/etc/"
-class SoftcamPanel(ConfigListScreen, Screen):
-	def __init__(self, session):
-		global emuDir
-		emuDir = "/usr/CamEmu/"
-		self.service = None
-		Screen.__init__(self, session)
-
-		self.skin = SOFTCAM_SKIN
-		self.onShown.append(self.setWindowTitle)
-		self.partyfeed = None
-		self.YellowAction = REFRESH
-
-		self.mlist = []
-		self["key_green"] = Label(_("ReStart"))
-		self["key_red"] = Label(_("Stop"))
-		self["key_yellow"] = Label(_("Refresh"))
-		self.partyfeed = os.path.exists("/etc/opkg/3rdparty-feed.conf") or os.path.exists("/etc/opkg/3rd-party-feed.conf")
-		if self.partyfeed:
-			self["key_blue"]= Label(_("Install"))
-		else:
-			self["key_blue"]= Label(_("Exit"))
-		self["ecminfo"] = Label(_("No ECM info"))
-		self["actifcam"] = Label(_("no CAM 1 active"))
-		self["actifcam2"] = Label(_("no CAM 2 active"))
-
-		#// create listings
-		self.emuDirlist = []
-		self.emuList = []
-		self.emuBin = []
-		self.emuStart = []
-		self.emuStop = []
-		self.emuRgui = []
-		self.emuDirlist = os.listdir(emuDir)
-		self.ecmtel = 0
-		self.first = 0
-		global count
-		count = 0
-		#// check emu dir for config files
-		print "************ go in the emuloop ************"
-		for x in self.emuDirlist:
-			#// if file contains the string "emu" (then this is a emu config file)
-			if x.find("camemu") > -1:
-				self.emuList.append(emuDir + x)
-				em = open(emuDir + x)
-				self.emuRgui.append(0)
-				#// read the emu config file
-				for line in em.readlines():
-					line1 = line
-					#// startcam
-					line = line1
-					if line.find("startcam") > -1:
-						line = line.split("=")
-						self.emuStart.append(line[1].strip())
-
-					#// stopcam
-					line = line1
-					if line.find("stopcam") > -1:
-						line = line.split("=")
-						self.emuStop.append(line[1].strip())
-
-					#// Restart GUI
-					line = line1
-					if line.find("restartgui") > -1:
-						self.emuRgui[count] = 1
-
-					#// binname
-					line = line1
-					if line.find("binname") > -1:
-						line = line.split("=")
-						self.emuBin.append(line[1].strip())
-					
-				em.close()
-				count += 1
-
-		self.maxcount = count
-		
-		self.onChangedEntry = [ ]
-		self.list = []
-		ConfigListScreen.__init__(self, self.list, session = self.session, on_change = self.changedEntry)
-		self.ReadMenu()
-		self.createSetup()
-		self["ecminfo"].show()
-
-		self.read_shareinfo()
-		self.Timer = eTimer()
-		self.Timer.callback.append(self.layoutFinished)
-		self.Timer.start(2000, True)
-		#// get the remote buttons
-		self["actions"] = ActionMap(["OkCancelActions", "DirectionActions", "ColorActions"],
-		{
-			"cancel": self.Exit,
-			"ok": self.ok,
-			"blue": self.Blue,
-			"red": self.Red,
-			"green": self.Green,
-			"yellow": self.Yellow,
-		}, -1)
-		#// update screen
-		self.onLayoutFinish.append(self.layoutFinished)
-
-	def setWindowTitle(self):
-		self.setTitle(_("Softcam Openpanel"))
-
-	def ReadMenu(self):
-		self.whichCam()
-		
-		for x in self.emuDirlist:
-			#// if file contains the string "emu" (then this is a emu config file)#modificacion
-			if x.find("camemu") > -1:
-				self.emuList.append(emuDir + x)
-				em = open(emuDir + x)
-				self.emuRgui.append(0)
-				#// read the emu config file
-				for line in em.readlines():
-					line1 = line
-					#// emuname
-					line = line1
-					if line.find("emuname") > -1:
-						line = line.split("=")
-						self.mlist.append(line[1].strip())
-						name = line[1].strip()
-				em.close()
-
-		emusel = [_('no cam')]
-		for x in self.mlist:
-			emusel.append(x)
-		self.cam1sel = ConfigSelection(emusel)
-		self.cam2sel = ConfigSelection(emusel)
-		self.setYellowKey(self.curcam)
-
-	def whichCam(self):
-		#// check for active cam 1
-		cam = config.softcam.actCam.value
-		self.curcam = None
-		self.curcamIndex = None
-		if cam in self.mlist:
-			index = self.mlist.index(cam)
-			x = self.emuBin[index]
-			if self.isCamrunning(x):
-				self.curcam = x
-				self.curcamIndex = index
-
-		#// check for active cam 2		
-		cam = config.softcam.actCam2.value
-		self.curcam2 = None
-		self.curcam2Index = None
-		if cam in self.mlist:
-			index = self.mlist.index(cam)
-			x = self.emuBin[index]
-			if self.isCamrunning(x):
-				self.curcam2 = x
-				self.curcam2Index = index
-
-		if not self.curcam and not self.curcam2 and self.mlist:
-			print "[SOFTCAMPANEL] try to find a running cam"
-			for cam in self.emuBin:
-				index = self.emuBin.index(cam)
-				if self.isCamrunning(cam):
-					self.curcam = cam
-					self.curcamIndex = index
-					camname = self.mlist[index]
-					print"[SOFTCAMPANEL] found %s running" % camname
-					self.Save_Settings(camname)
-					break
-
-	def createSetup(self):
-		self.editListEntry = None
-		self.list = []
-		self.list.append(getConfigListEntry(_("Select Cam 1"), self.cam1sel))
-		if len(self.emuStart) > 1:
-			self["actifcam2"].show()
-			if self.cam1sel.value != _('no cam') or config.softcam.actCam.value != _("no CAM 1 active"):
-				self.list.append(getConfigListEntry(_("Select Cam 2"), self.cam2sel))
-				if self.cam2sel.value != _('no cam'):
-					self.list.append(getConfigListEntry(_("Wait time before start Cam 2"), config.softcam.waittime))
-		else:
-			self["actifcam2"].hide()
-			self.cam2sel.setValue(_('no cam'))
-
-		self["config"].list = self.list
-		self["config"].setList(self.list)
-
-	def setYellowKey(self, cam):
-		if cam == None or cam == _('no cam'):
-			self.YellowAction = REFRESH
-			self["key_yellow"].setText(_("Refresh"))
-			return
-		if cam.upper().startswith('CCCAM'):
-			self.YellowAction = CCCAMINFO
-			self["key_yellow"].setText(_("CCcamInfo"))
-		elif cam.upper().startswith('OSCAM'):
-			self.YellowAction = OSCAMINFO
-			self["key_yellow"].setText(_("OscamInfo"))
-		else:
-			self.YellowAction = REFRESH
-			self["key_yellow"].setText(_("Refresh"))
-
-	def selectionChanged(self):
-		#self["status"].setText(self["config"].getCurrent()[0])
-		pass
-
-	def changedEntry(self):
-		for x in self.onChangedEntry:
-			x()
-		self.selectionChanged()
-		self.createSetup()
-
-	def getCurrentEntry(self):
-		return self["config"].getCurrent()[0]
-
-	def getCurrentValue(self):
-		return str(self["config"].getCurrent()[1].getText())
-
-	def getCurrentDescription(self):
-		return self["config"].getCurrent() and len(self["config"].getCurrent()) > 2 and self["config"].getCurrent()[2] or ""
-
-	def layoutFinished(self):
-		self.Timer.stop()
-		if not Check_Softcam():
-			self.Exit()
-		#// check for active cam
-		try:
-			self.whichCam()
-			global oldcamIndex, oldcam2Index
-			oldcamIndex = -1
-			oldcam2Index = -1
-			tel = 0
-
-			if self.curcam:
-				oldcamIndex = self.curcamIndex
-				actcam = self.mlist[oldcamIndex]
-				if self.first == 0:
-					self.cam1sel.setValue(actcam)		
-				self["key_green"].setText(_("ReStart"))
-				self["actifcam"].setText(_("active CAM 1: ") + actcam )
-				print '[SOFTCAM] set active cam 1 to: ' + actcam
-			else:
-				actcam = _("no CAM 1 active")
-				self["actifcam"].setText(actcam)
-		
-			if self.curcam2:
-				oldcam2Index = self.curcam2Index
-				actcam = self.mlist[oldcam2Index]
-				if self.first == 0:
-					self.cam2sel.setValue(actcam)
-				self["actifcam2"].setText(_("active CAM 2: ") + actcam )
-				print '[SOFTCAM] set active cam 2 to: ' + actcam
-			else:
-				actcam2 = _("no CAM 2 active")
-				self["actifcam2"].setText(actcam2)
-
-			if self.first == 0: # Only update first time or when refresh button was pressed
-				self.createSetup()
-				self.first = 1
-
-			#// CAM IS NOT RUNNING
-			if not self.curcam and not self.curcam2:
-				self["key_green"].setText(_("Start"))
-				self.YellowAction = REFRESH
-				self["key_yellow"].setText(_("Refresh"))
-				if os.path.exists('/tmp/ecm.info') is True:
-					os.system("rm /tmp/ecm.info")
-				if os.path.exists('/tmp/ecm0.info') is True:
-					os.system("rm /tmp/ecm0.info")
-
-		except:
-			pass
-
-		if self["config"].getCurrent()[0] == _("Select Cam 1"):
-			self.setYellowKey(self.curcam)
-		else:
-			self.setYellowKey(self.curcam2)
-		
-		#// read ecm.info
-		ecmi = ""
-		if os.path.exists('/tmp/ecm.info') is True:
-			ecmi = self.read_ecm('/tmp/ecm.info')
-		elif os.path.exists('/tmp/ecm1.info') is True:
-			ecmi = self.read_ecm('/tmp/ecm1.info')
-		else:
-			ecmi = _("No ECM info")
-		ecmold = self["ecminfo"].getText()
-		if ecmold == ecmi:
-			self.ecmtel += 1
-			if self.ecmtel > 5:
-				ecmi = _("No new ECM info")
-		else:
-			self.ecmtel = 0
-		self["ecminfo"].setText(ecmi)
-		self.Timer.start(2000, True)		#reset timer
-
-	def read_shareinfo(self):
-		#// read share.info and put in list
-		self.shareinfo =[]
-		if os.path.exists('/tmp/share.info') is True:
-			s = open('/tmp/share.info')
-			for x in s.readlines():
-				self.shareinfo.append(x)
-			s.close()
-
-	def read_ecm(self, ecmpath):
-		#// read ecm.info and check for share.info
-		ecmi2 = ''
-		Caid = ''
-		Prov = ''
-		f = open(ecmpath)
-		for line in f.readlines():
-			line= line.replace('=', '')
-			line= line.replace(' ', '', 1)
-			#// search CaID
-			if line.find('ECM on CaID') > -1:
-				k = line.find('ECM on CaID') + 14
-				Caid = line[k:k+4]
-			#// search Boxid
-			if line.find('prov:') > -1:
-				tmpprov = line.split(':')
-				Prov = tmpprov[1].strip()
-				#// search peer in share.info only if share.info exists
-				if Caid <> '' and Prov <> '' and len(self.shareinfo) > 0 :
-					for x in self.shareinfo:
-						cel = x.split(' ')
-						#// search Boxid and Caid
-						if cel[5][0:4] == Caid and cel[9][3:7] == Prov:
-							line = 'Peer: ' + Prov + ' - ' + cel[3] + ' - ' + cel[8] + '\n'
-							break
-			ecmi2 = ecmi2 + line
-		f.close()
-		return ecmi2
-
-
-	def Red(self):
-		#// Stopping the CAM when pressing the RED button
-		self.Timer.stop()
-		self.Stopcam()
-		self.Timer.start(2000, True)		#reset timer
-
-	def Yellow(self):
-		if self.YellowAction == CCCAMINFO:
-			self.Timer.stop()
-			self.session.openWithCallback(self.ShowSoftcamCallback, CCcamInfoMain)
-		elif self.YellowAction == OSCAMINFO:
-			self.Timer.stop()
-			self.session.openWithCallback(self.ShowSoftcamCallback, OscamInfoMenu)
-		else:
-			self.first = 0
-			self.layoutFinished()
-
-	def Green(self):
-		#// Start the CAM when pressing the GREEN button
-		self.Timer.stop()
-		self.Startcam()
-		self.Timer.start(2000, True)		#reset timer
-
-	def Exit(self):
-		self.Timer.stop()
-		self.close()
-		
-	def Blue(self):
-		if not self.partyfeed:
-			self.Exit()
-		else:
-			self.Timer.stop()
-			self.session.openWithCallback(self.ShowSoftcamCallback, ShowSoftcamPackages)
-
-	def ShowSoftcamCallback(self):
-		self.Timer.start(2000, True)
-
-	def ok(self):
-		#// Exit Softcam when pressing the OK button
-		self.Timer.stop()
-		self.Startcam()
-		if self.YellowAction == REFRESH:
-			self.Yellow()
-		self.Timer.start(2000, True)		#reset timer
-
-	def Stopcam(self):
-		#// Stopping the CAM
-		global oldcamIndex, oldcam2Index
-		if oldcamIndex >= 0:
-			oldcam = self.emuBin[oldcamIndex]
-		else:
-			oldcam = None
-		if oldcam2Index >= 0:
-			oldcam2 = self.emuBin[oldcam2Index]
-		else:
-			oldcam2 = None
-		import time
-		self.container = eConsoleAppContainer()
-
-		if config.softcam.camstartMode.value == "0" or not fileExists('/etc/init.d/softcam'):
-			if oldcam:
-				print '[SOFTCAM] Python stop cam 1: ' + oldcam
-				self.container.execute(self.emuStop[oldcamIndex])
-
-				time.sleep(1) # was 5sec
-				t = 0
-				while t < 5:
-					p = command('pidof %s |wc -w' % oldcam )
-					if not p.isdigit(): p=0
-					if int(p) > 0:
-						self.container = eConsoleAppContainer()
-						self.container.execute('killall -9 ' + oldcam)
-						t += 1
-						time.sleep(1)
-					else:
-						t = 5
-
-			if oldcam2:
-				print '[SOFTCAM] Python stop cam 2: ' + oldcam2
-				self.container.execute(self.emuStop[oldcam2Index])
-
-				time.sleep(1) # was 5sec
-				t = 0
-				while t < 5:
-					p = command('pidof %s |wc -w' % oldcam2 )
-					if not p.isdigit(): p=0
-					if int(p) > 0:
-						self.container = eConsoleAppContainer()
-						self.container.execute('killall -9 ' + oldcam2)
-						t += 1
-						time.sleep(1)
-					else:
-						t = 5
-
-		else:
-			self.container.execute('/etc/init.d/softcam.cam1 stop')
-			self.container.execute('/etc/init.d/softcam.cam2 stop')
-
-		if os.path.exists('/tmp/ecm.info') is True:
-			os.system("rm /tmp/ecm.info")
-		actcam = _("no CAM 1 active")
-		actcam2 = _("no CAM 2 active")
-		self["actifcam"].setText(actcam)
-		self["actifcam2"].setText(actcam2)
-		self["key_green"].setText(_("Start"))
-		self["ecminfo"].setText(_("No ECM info"))
-		self.Save_Settings(actcam)
-		self.Save_Settings2(actcam2)
-
-	def Startcam(self):
-		#// Starting the CAM
-		try:
-			if count > 0:
-				if self.cam1sel.value == self.cam2sel.value:
-					self.session.openWithCallback(self.doNothing, MessageBox, _("No Cam started !!\n\nCam 1 must be different from Cam 2"), MessageBox.TYPE_ERROR, simple=True)
-					return
-				if config.softcam.camstartMode.value == "0":
-					self.Stopcam()
-
-				self.camIndex = self.cam1sel.getIndex() -1
-				self.cam2Index = self.cam2sel.getIndex() - 1
-				if self.camIndex >= 0:
-					actcam = self.cam1sel.value
-					self["actifcam"].setText(_("active CAM 1: ") + actcam)
-					self.Save_Settings(actcam)
-					start = self.emuStart[self.camIndex]
-					if self.checkBinName(self.emuBin[self.camIndex], start):
-						self.session.openWithCallback(self.startcam2, MessageBox, actcam + _(" Not Started !!\n\nCam binname must be in the start command line\nCheck your emu config file"), MessageBox.TYPE_ERROR, simple=True)
-						return
-					if config.softcam.camstartMode.value == "0":
-						print '[SOFTCAM] Python start cam 1: ' + actcam
-						self.session.openWithCallback(self.waitTime, MessageBox, _("Starting Cam 1: ") + actcam, MessageBox.TYPE_INFO, timeout=5, simple=True)
-						self.container = eConsoleAppContainer()
-						self.container.execute(start)
-					else:
-						# Create INIT.D start
-						self.session.openWithCallback(self.doNothing, MessageBox, _("Creating start scripts and starting the cam"), MessageBox.TYPE_INFO, timeout=10, simple=True)
-						self.Save_Settings2(self.cam2sel.value)
-
-						camname1 = self.emuBin[self.camIndex]
-						camname2 = self.emuBin[self.cam2Index]
-						self.deleteInit()
-						camname = "/usr/bin/" + camname1
-						startcmd = self.emuStart[self.camIndex]
-						stopcmd = self.emuStop[self.camIndex]							
-						self.createInitdscript("cam1", camname, startcmd, stopcmd)
-						if self.cam2Index >= 0:
-							camname = "/usr/bin/" + camname2
-							startcmd = self.emuStart[self.cam2Index]
-							stopcmd = self.emuStop[self.cam2Index]							
-							self.createInitdscript("cam2", camname, startcmd, stopcmd, config.softcam.waittime.value)
-
-					self["key_green"].setText(_("ReStart"))
-
-		except:
-			pass
-
-	def waitTime(self, ret):
-		if self.cam2Index >= 0:
-			if config.softcam.waittime.value == '0':
-				self.startcam2(None)
-			else:
-				self.session.openWithCallback(self.startcam2, MessageBox, _("Waiting..."), MessageBox.TYPE_INFO, timeout=int(config.softcam.waittime.value), simple=True)
-
-	def doNothing(self, ret):
-		pass
-
-	def startcam2(self, ret):
-		camIndex = self.cam2Index
-		if camIndex >= 0:
-			actcam = self.cam2sel.value
-			self["actifcam2"].setText(_("active CAM 2: ") + actcam)
-			self.Save_Settings2(actcam)
-			start = self.emuStart[camIndex]
-			if self.checkBinName(self.emuBin[self.cam2Index], start):
-					self.session.open(MessageBox, actcam + _(" Not Started !!\n\nCam binname must be in the start command line\nCheck your emu config file"), MessageBox.TYPE_ERROR, simple=True)
-					return
-			print '[SOFTCAM] Python start cam 2: ' + actcam
-			self.session.open(MessageBox, _("Starting Cam 2: ") + actcam, MessageBox.TYPE_INFO, timeout=5, simple=True)
-			self.container = eConsoleAppContainer()
-			self.container.execute(start)
-
-	def Save_Settings(self, cam_name):
-		#// Save Came Name to Settings file
-		config.softcam.actCam.setValue(cam_name)
-		config.softcam.save()
-		configfile.save()
-
-	def Save_Settings2(self, cam_name):
-		#// Save Came Name to Settings file
-		config.softcam.actCam2.setValue(cam_name)
-		config.softcam.save()
-		configfile.save()
-
-	def isCamrunning(self, cam):
-		p = command('pidof ' + cam + ' |wc -w')
-		if not p.isdigit(): p=0
-		if int(p) > 0:
-			return True
-		else:
-			return False
-
-	def checkBinName(self, binname, start):
-		print "[CHECKBINNAME] bin=%s ,start=%s" %(binname,start)
-		if start.find(binname + ' ') > -1:
-			print "[CHECKBINNAME] OK"
-			return False
-		else:
-			if start[start.rfind('/')+1:] == binname:
-				print "[CHECKBINNAME] OK"
-				return False
-			else:
-				print "[CHECKBINNAME] ERROR"
-				return True
-
-	def createInitdscript(self, camname, emubin, start, stop, wait=None):
-		Adir = "/etc/init.d/softcam." + camname
-		softcamfile = []
-		softcamfile.append('#!/bin/sh')
-		softcamfile.append('DAEMON=%s' % emubin)
-		softcamfile.append('STARTCAM="%s"' % start)
-		softcamfile.append('STOPCAM="%s"' % stop)
-		softcamfile.append('DESC="Softcam"')
-		softcamfile.append('')
-		softcamfile.append('test -f $DAEMON || exit 0')
-		softcamfile.append('set -e')
-		softcamfile.append('')
-		softcamfile.append('case "$1" in')
-		softcamfile.append('	start)')
-		softcamfile.append('		echo -n "starting $DESC: $DAEMON... "')
-		if wait:
-			softcamfile.append('		sleep ' + wait)
-		softcamfile.append('		$STARTCAM')
-		softcamfile.append('		echo "done."')
-		softcamfile.append('		;;')
-		softcamfile.append('	stop)')
-		softcamfile.append('		echo -n "stopping $DESC: $DAEMON... "')
-		softcamfile.append('		$STOPCAM')
-		softcamfile.append('		echo "done."')
-		softcamfile.append('		;;')
-		softcamfile.append('	restart)')
-		softcamfile.append('		echo "restarting $DESC: $DAEMON... "')
-		softcamfile.append('		$0 stop')
-		softcamfile.append('		echo "wait..."')
-		softcamfile.append('		sleep 5')
-		softcamfile.append('		$0 start')
-		softcamfile.append('		echo "done."')
-		softcamfile.append('		;;')
-		softcamfile.append('	*)')
-		softcamfile.append('		echo "Usage: $0 {start|stop|restart}"')
-		softcamfile.append('		exit 1')
-		softcamfile.append('		;;')
-		softcamfile.append('esac')
-		softcamfile.append('')
-		softcamfile.append('exit 0')
-
-		f = open( Adir, "w" )
-		for x in softcamfile:
-			f.writelines(x + '\n')
-		f.close()
-
-		self.container = eConsoleAppContainer()
-		# Set execute rights
-		os.chmod(Adir,0755)
-		# Create symbolic link for startup
-		if not os.path.exists("/etc/rc2.d/S20softcam." + camname):
-			self.container.execute('update-rc.d -f softcam.' + camname + ' defaults')
-		# Wait a few seconds
-		import time
-		time.sleep (3) 
-
-		# Start cam
-		if self.isCamrunning(emubin):
-			self.container.execute('/etc/init.d/softcam.' + camname + ' restart')
-		else:
-			self.container.execute('/etc/init.d/softcam.' + camname + ' start')
-
-	def deleteInit(self):
-		if os.path.exists("/etc/rc2.d/S20softcam.cam1"):
-			print "Delete Symbolink link"
-			self.container = eConsoleAppContainer()
-			self.container.execute('update-rc.d -f softcam.cam1 defaults')
-		if os.path.exists("/etc/init.d/softcam.cam1"):
-			print "Delete softcam init script cam1"
-			os.system("rm /etc/init.d/softcam.cam1")
-			
-		if os.path.exists("/etc/rc2.d/S20softcam.cam2"):
-			print "Delete Symbolink link"
-			self.container = eConsoleAppContainer()
-			self.container.execute('update-rc.d -f softcam.cam2 defaults')
-		if os.path.exists("/etc/init.d/softcam.cam2"):
-			print "Delete softcam init script cam2"
-			os.system("rm /etc/init.d/softcam.cam2")
-
-class ShowSoftcamPackages(Screen):
-	skin = """
-		<screen name="ShowSoftcamPackages" position="center,center" size="630,500" title="Install Softcams" >
-			<ePixmap pixmap="skin_default/buttons/red.png" position="0,0" size="140,40" alphatest="on" />
-			<ePixmap pixmap="skin_default/buttons/green.png" position="140,0" size="140,40" alphatest="on" />
-			<widget source="key_red" render="Label" position="0,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#9f1313" transparent="1" />
-			<widget source="key_green" render="Label" position="140,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#1f771f" transparent="1" />
-			<widget source="key_ok" render="Label" position="240,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#1f771f" transparent="1" />
-			<widget source="list" render="Listbox" position="5,50" size="620,420" scrollbarMode="showOnDemand">
-				<convert type="TemplatedMultiContent">
-					{"template": [
-							MultiContentEntryText(pos = (5, 1), size = (540, 28), font=0, flags = RT_HALIGN_LEFT, text = 0), # index 0 is the name
-							MultiContentEntryText(pos = (5, 26), size = (540, 20), font=1, flags = RT_HALIGN_LEFT, text = 2), # index 2 is the description
-							MultiContentEntryPixmapAlphaBlend(pos = (545, 2), size = (48, 48), png = 4), # index 4 is the status pixmap
-							MultiContentEntryPixmapAlphaBlend(pos = (5, 50), size = (510, 2), png = 5), # index 4 is the div pixmap
-						],
-					"fonts": [gFont("Regular", 22),gFont("Regular", 14)],
-					"itemHeight": 52
-					}
-				</convert>
-			</widget>
-		</screen>"""
-	
-	def __init__(self, session, args = None):
-		Screen.__init__(self, session)
-		self.session = session
-		
-		self["actions"] = ActionMap(["OkCancelActions", "DirectionActions", "ColorActions"],
-		{
-			"red": self.exit,
-			"ok": self.go,
-			"cancel": self.exit,
-			"green": self.startupdateList,
-		}, -1)
-		
-		self.list = []
-		self.statuslist = []
-		self["list"] = List(self.list)
-		self["key_red"] = StaticText(_("Close"))
-		self["key_green"] = StaticText(_("Reload"))
-		self["key_ok"] = StaticText(_("Install"))
-
-		self.oktext = _("\nPress OK on your remote control to continue.")
-		self.onShown.append(self.setWindowTitle)
-		self.setStatus('list')
-		self.Timer1 = eTimer()
-		self.Timer1.callback.append(self.rebuildList)
-		self.Timer1.start(1000, True)
-		self.Timer2 = eTimer()
-		self.Timer2.callback.append(self.updateList)
-
-	def go(self, returnValue = None):
-		cur = self["list"].getCurrent()
-		if cur:
-			status = cur[3]
-			self.package = cur[2]
-			if status == "installable":
-				self.session.openWithCallback(self.runInstall, MessageBox, _("Do you want to install the package:\n") + self.package + "\n" + self.oktext)
-
-	def runInstall(self, result):
-		if result:
-			self.session.openWithCallback(self.runInstallCont, Console, cmdlist = ['opkg install ' + self.package], closeOnSuccess = True)
-
-	def runInstallCont(self):
-			ret = command('opkg list-installed | grep ' + self.package + ' | cut -d " " -f1')
-
-			if ret != self.package:
-				self.session.open(MessageBox, _("Install Failed !!"), MessageBox.TYPE_ERROR, timeout = 10)
-			else:
-				self.session.open(MessageBox, _("Install Finished."), MessageBox.TYPE_INFO, timeout = 10)
-				self.setStatus('list')
-				self.Timer1.start(1000, True)
-
-	def UpgradeReboot(self, result):
-		if result is None:
-			return
-		
-	def exit(self):
-		self.close()
-			
-	def setWindowTitle(self):
-		self.setTitle(_("Install Softcams"))
-
-	def setStatus(self,status = None):
-		if status:
-			self.statuslist = []
-			divpng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "skin_default/div-h.png"))
-			if status == 'update':
-				statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "Extensions/Openpanel/icons/upgrade.png"))
-				self.statuslist.append(( _("Package list update"), '', _("Trying to download a new updatelist. Please wait..." ),'', statuspng, divpng ))
-				self['list'].setList(self.statuslist)
-			if status == 'list':
-				statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "Extensions/Openpanel/icons/upgrade.png"))
-				self.statuslist.append(( _("Package list"), '', _("Getting Softcam list. Please wait..." ),'', statuspng, divpng ))
-				self['list'].setList(self.statuslist)
-			elif status == 'error':
-				statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "Extensions/Openpanel/icons/remove.png"))
-				self.statuslist.append(( _("Error"), '', _("There was an error downloading the updatelist. Please try again." ),'', statuspng, divpng ))
-				self['list'].setList(self.statuslist)				
-
-	def startupdateList(self):
-		self.setStatus('update')
-		self.Timer2.start(1000, True)
-
-	def updateList(self):
-		self.container = eConsoleAppContainer()
-		self.container.appClosed.append(self.doneupdateList)
-		self.setStatus('list')
-		self.container.execute('opkg update')
-
-	def doneupdateList(self, answer):
-		self.container.appClosed.remove(self.doneupdateList)
-		self.Timer1.start(1000, True)
-
-	def rebuildList(self):
-		self.list = []
-		self.Flist = []
-		self.Elist = []
-		t = command('opkg list | grep "enigma2-plugin-softcams"')
-		self.Flist = t.split('\n')
-		tt = command('opkg list-installed | grep "enigma2-plugin-softcams"')
-		self.Elist = tt.split('\n')
-
-		if len(self.Flist) > 0:
-			self.buildPacketList()
-		else:
-			self.setStatus('error')
-
-	def buildEntryComponent(self, name, version, description, state):
-		divpng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "skin_default/div-h.png"))
-		if not description:
-			description = ""
-		installedpng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "Extensions/Openpanel/icons/installed.png"))
-		return((name, version, _(description), state, installedpng, divpng))
-
-	def buildPacketList(self):
-		fetchedList = self.Flist
-		excludeList = self.Elist
-
-		if len(fetchedList) > 0:
-			for x in fetchedList:
-				x_installed = False
-				Fx = x.split(' - ')
-				try:
-					if Fx[0].find('enigma2-plugin-softcams') > -1:
-						for exc in excludeList:
-							Ex = exc.split(' - ')
-							if Fx[0] == Ex[0]:
-								x_installed = True
-								break
-						if x_installed == False:
-							self.list.append(self.buildEntryComponent(Fx[2], Fx[1], Fx[0], "installable"))
-				except:
-					pass
-
-			self['list'].setList(self.list)
-	
-		else:
-			self.setStatus('error')
diff --git a/lib/python/Plugins/Extensions/Openpanel/SoftwarePanel.py b/lib/python/Plugins/Extensions/Openpanel/SoftwarePanel.py
deleted file mode 100644
index f77838c..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/SoftwarePanel.py
+++ /dev/null
@@ -1,249 +0,0 @@
-from Plugins.Plugin import PluginDescriptor
-from Screens.Screen import Screen
-from Screens.MessageBox import MessageBox
-from Components.ActionMap import ActionMap
-from Components.Label import Label
-from Components.Pixmap import Pixmap
-from Components.Sources.List import List
-from Components.Sources.StaticText import StaticText
-from Components.Ipkg import IpkgComponent
-from Components.MultiContent import MultiContentEntryText, MultiContentEntryPixmapAlphaBlend
-from Tools.LoadPixmap import LoadPixmap
-from enigma import ePixmap
-from Tools.Directories import resolveFilename, SCOPE_CURRENT_PLUGIN, SCOPE_CURRENT_SKIN, SCOPE_METADIR
-from os import path as os_path
-import os
-from boxbranding import getMachineBrand, getMachineName
-
-class SoftwarePanel(Screen):
-
-	def __init__(self, session, *args):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Software Panel"))
-		skin = """
-		<screen name="SoftwarePanel" position="center,center" size="650,605" title="Software Panel">
-			<widget name="a_off" pixmap="/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/aoff.png" position="10,10" zPosition="1" size="36,97" alphatest="on" />
-			<widget name="a_red" pixmap="/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/ared.png" position="10,10" zPosition="1" size="36,97" alphatest="on" />
-			<widget name="a_yellow" pixmap="/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/ayellow.png" position="10,10" zPosition="1" size="36,97" alphatest="on" />
-			<widget name="a_green" pixmap="/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/agreen.png" position="10,10" zPosition="1" size="36,97" alphatest="on" />
-			<widget name="feedstatusRED" position="60,14" size="200,30" zPosition="1" font="Regular;25" halign="left" transparent="1" />
-			<widget name="feedstatusYELLOW" position="60,46" size="200,30" zPosition="1" font="Regular;25" halign="left" transparent="1" />
-			<widget name="feedstatusGREEN" position="60,78" size="200,30" zPosition="1" font="Regular;25" halign="left" transparent="1" />
-			<widget name="packagetext" position="180,50" size="350,30" zPosition="1" font="Regular;25" halign="right" transparent="1" />
-			<widget name="packagenr" position="511,50" size="50,30" zPosition="1" font="Regular;25" halign="right" transparent="1" />
-			<widget source="list" render="Listbox" position="10,120" size="630,365" scrollbarMode="showOnDemand">
-				<convert type="TemplatedMultiContent">
-					{"template": [
-							MultiContentEntryText(pos = (5, 1), size = (540, 28), font=0, flags = RT_HALIGN_LEFT, text = 0), # index 0 is the name
-							MultiContentEntryText(pos = (5, 26), size = (540, 20), font=1, flags = RT_HALIGN_LEFT, text = 2), # index 2 is the description
-							MultiContentEntryPixmapAlphaBlend(pos = (545, 2), size = (48, 48), png = 4), # index 4 is the status pixmap
-							MultiContentEntryPixmapAlphaBlend(pos = (5, 50), size = (610, 2), png = 5), # index 4 is the div pixmap
-						],
-					"fonts": [gFont("Regular", 22),gFont("Regular", 14)],
-					"itemHeight": 52
-					}
-				</convert>
-			</widget>
-			<ePixmap pixmap="skin_default/buttons/red.png" position=" 30,570" size="35,27" alphatest="blend" />
-			<widget name="key_green_pic" pixmap="skin_default/buttons/green.png" position="290,570" size="35,27" alphatest="blend" />
-			<widget name="key_red" position=" 80,573" size="200,26" zPosition="1" font="Regular;22" halign="left" transparent="1" />
-			<widget name="key_green" position="340,573" size="200,26" zPosition="1" font="Regular;22" halign="left" transparent="1" />
-		</screen> """
-		self.skin = skin
-		self.list = []
-		self.statuslist = []
-		self["list"] = List(self.list)
-		self['a_off'] = Pixmap()
-		self['a_red'] = Pixmap()
-		self['a_yellow'] = Pixmap()
-		self['a_green'] = Pixmap()
-		self['key_green_pic'] = Pixmap()
-		self['key_red_pic'] = Pixmap()
-		self['key_red'] = Label(_("Cancel"))
-		self['key_green'] = Label(_("Update"))
-		self['packagetext'] = Label(_("Updates Available:"))
-		self['packagenr'] = Label("0")
-		self['feedstatusRED'] = Label("<  " + _("feed status"))
-		self['feedstatusYELLOW'] = Label("<  " + _("feed status"))
-		self['feedstatusGREEN'] = Label("<  " + _("feed status"))
-		self['key_green'].hide()
-		self['key_green_pic'].hide()
-		self.update = False
-		self.packages = 0
-		self.ipkg = IpkgComponent()
-		self.ipkg.addCallback(self.ipkgCallback)
-		self["actions"] = ActionMap(["OkCancelActions", "DirectionActions", "ColorActions", "SetupActions"],
-		{
-			"cancel": self.Exit,
-			"green": self.Green,
-			"red": self.Exit,
-		}, -2)
-
-		self.onLayoutFinish.append(self.layoutFinished)
-
-	def Exit(self):
-		self.ipkg.stop()
-		self.close()
-
-	def Green(self):
-		if self.packages > 0:
-			if self.packages <= 200:
-				from Plugins.SystemPlugins.SoftwareManager.plugin import UpdatePlugin
-				self.session.open(UpdatePlugin)
-				self.close()
-			else:
-				print "DO NOT UPDATE !!!"
-				message = _("There are to many update packages !!\n\n"
-				"There is a risk that your %s %s will not\n"
-				"boot after online-update, or will show disfunction in running Image.\n\n"
-				"You need to flash new !!\n\n"
-				"Do you want to flash-online ?") % (getMachineBrand(), getMachineName())
-				self.session.openWithCallback(self.checkPackagesCallback, MessageBox, message, default = True)
-
-	def checkPackagesCallback(self, ret):
-		print ret
-		if ret:
-			from Plugins.SystemPlugins.SoftwareManager.Flash_online import FlashOnline
-			self.session.open(FlashOnline)
-		self.close()
-
-	def layoutFinished(self):
-		self.checkTraficLight()
-		self.rebuildList()
-
-	def UpdatePackageNr(self):
-		self.packages = len(self.list)
-		print self.packages
-		print"packagenr" + str(self.packages)
-		self["packagenr"].setText(str(self.packages))
-		if self.packages == 0:
-			self['key_green'].hide()
-			self['key_green_pic'].hide()
-		else:
-			self['key_green'].show()
-			self['key_green_pic'].show()
-
-	def checkTraficLight(self):
-		print"checkTraficLight"
-		from urllib import urlopen
-		import socket
-		self['a_red'].hide()
-		self['a_yellow'].hide()
-		self['a_green'].hide()
-		self['feedstatusRED'].hide()
-		self['feedstatusYELLOW'].hide()
-		self['feedstatusGREEN'].hide()
-		currentTimeoutDefault = socket.getdefaulttimeout()
-		socket.setdefaulttimeout(3)
-		try:
-			urlOpenPlus = "http://feeds.open-plus.es/openplus"
-			d = urlopen(urlOpenPlus)
-			tmpStatus = d.read()
-			if 'rot.png' in tmpStatus:
-				self['a_off'].hide()
-				self['a_red'].show()
-				self['feedstatusRED'].show()
-			elif 'gelb.png' in tmpStatus:
-				self['a_off'].hide()
-				self['a_yellow'].show()
-				self['feedstatusYELLOW'].show()
-			elif 'gruen.png' in tmpStatus:
-				self['a_off'].hide()
-				self['a_green'].show()
-				self['feedstatusGREEN'].show()
-		except:
-			self['a_off'].show()
-		socket.setdefaulttimeout(currentTimeoutDefault)
-
-	def setStatus(self,status = None):
-		if status:
-			self.statuslist = []
-			divpng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "skin_default/div-h.png"))
-			if status == 'update':
-				if os_path.exists(resolveFilename(SCOPE_CURRENT_SKIN, "icons/upgrade.png")):
-					statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "icons/upgrade.png"))
-				else:
-					statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "SystemPlugins/SoftwareManager/upgrade.png"))
-				self.statuslist.append(( _("Package list update"), '', _("Trying to download a new updatelist. Please wait..." ),'',statuspng, divpng ))
-			elif status == 'error':
-				if os_path.exists(resolveFilename(SCOPE_CURRENT_SKIN, "icons/remove.png")):
-					statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "icons/remove.png"))
-				else:
-					statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "SystemPlugins/SoftwareManager/remove.png"))
-				self.statuslist.append(( _("Error"), '', _("There was an error downloading the updatelist. Please try again." ),'',statuspng, divpng ))
-			elif status == 'noupdate':
-				if os_path.exists(resolveFilename(SCOPE_CURRENT_SKIN, "icons/installed.png")):
-					statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "icons/installed.png"))
-				else:
-					statuspng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "SystemPlugins/SoftwareManager/installed.png"))
-				self.statuslist.append(( _("Nothing to upgrade"), '', _("There are no updates available." ),'',statuspng, divpng ))
-
-			self['list'].setList(self.statuslist)
-
-	def rebuildList(self):
-		self.setStatus('update')
-		self.ipkg.startCmd(IpkgComponent.CMD_UPDATE)
-
-	def ipkgCallback(self, event, param):
-		if event == IpkgComponent.EVENT_ERROR:
-			self.setStatus('error')
-		elif event == IpkgComponent.EVENT_DONE:
-			if self.update == False:
-				self.update = True
-				self.ipkg.startCmd(IpkgComponent.CMD_UPGRADE_LIST)
-			else:
-				self.buildPacketList()
-		pass
-	
-	def buildEntryComponent(self, name, version, description, state):
-		divpng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "skin_default/div-h.png"))
-		if not description:
-			description = "No description available."
-		if state == 'installed':
-			if os_path.exists(resolveFilename(SCOPE_CURRENT_SKIN, "icons/installed.png")):
-				installedpng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "icons/installed.png"))
-			else:
-				installedpng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "SystemPlugins/SoftwareManager/installed.png"))
-			return((name, version, _(description), state, installedpng, divpng))
-		elif state == 'upgradeable':
-			if os_path.exists(resolveFilename(SCOPE_CURRENT_SKIN, "icons/upgradeable.png")):
-				upgradeablepng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "icons/upgradeable.png"))
-			else:
-				upgradeablepng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "SystemPlugins/SoftwareManager/upgradeable.png"))
-			return((name, version, _(description), state, upgradeablepng, divpng))
-		else:
-			if os_path.exists(resolveFilename(SCOPE_CURRENT_SKIN, "icons/installable.png")):
-				installablepng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_SKIN, "icons/installable.png"))
-			else:
-				installablepng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_CURRENT_PLUGIN, "SystemPlugins/SoftwareManager/installable.png"))
-			return((name, version, _(description), state, installablepng, divpng))
-
-	def buildPacketList(self):
-		self.list = []
-		fetchedList = self.ipkg.getFetchedList()
-		excludeList = self.ipkg.getExcludeList()
-
-		if len(fetchedList) > 0:
-			for x in fetchedList:
-				try:
-					self.list.append(self.buildEntryComponent(x[0], x[1], x[2], "upgradeable"))
-				except:
-					print "[SOFTWAREPANEL] " + x[0] + " no valid architecture, ignoring !!"
-#					self.list.append(self.buildEntryComponent(x[0], '', 'no valid architecture, ignoring !!', "installable"))
-#			if len(excludeList) > 0:
-#				for x in excludeList:
-#					try:
-#						self.list.append(self.buildEntryComponent(x[0], x[1], x[2], "installable"))
-#					except:
-#						self.list.append(self.buildEntryComponent(x[0], '', 'no valid architecture, ignoring !!', "installable"))
-
-			if self.list:
-				self['list'].setList(self.list)
-			else:
-				self.setStatus('noupdate')
-		elif len(fetchedList) == 0:
-			self.setStatus('noupdate')
-		else:
-			self.setStatus('error')
-
-		self.UpdatePackageNr()
diff --git a/lib/python/Plugins/Extensions/Openpanel/SpeedTest.py b/lib/python/Plugins/Extensions/Openpanel/SpeedTest.py
deleted file mode 100644
index 2cd1c3d..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/SpeedTest.py
+++ /dev/null
@@ -1,132 +0,0 @@
-##by mfaraj57 https://www.tunisia-sat.com/
-# 2016.09.18 10:47:13 Jerusalem Daylight Time
-##MOD by openplus https://www.open-plus.es/
-# 2017.02.22 17:28 Spain
-TEST_PATH='/usr/lib/enigma2/python/Plugins/Extensions/Openpanel'
-from Screens.Screen import Screen
-from Screens.Standby import TryQuitMainloop
-from Components.ConfigList import ConfigListScreen
-from Components.Label import Label
-from Components.ActionMap import ActionMap
-from Components.ScrollLabel import ScrollLabel
-from enigma import getDesktop
-from enigma import eConsoleAppContainer
-from Tools.Directories import copyfile, fileExists
-from Plugins.Plugin import PluginDescriptor
-import os
-
-
-
-
-class SpeedTestScreen(Screen, ConfigListScreen):
-    screenWidth = getDesktop(0).size().width()
-    if screenWidth and screenWidth == 1920:
-            skin = """<screen name="SpeedTestScreen" position="center,center" size="1237,769" title="Speed Test" backgroundColor="transparent" flags="wfNoBorder">
-                <ePixmap position="0,0" size="1237,769" pixmap="/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/speed_test.png" zPosition="1" transparent="1" alphatest="blend" />
-                <widget name="data" position="208,106" zPosition="4" size="824,337" font="Regular; 20" foregroundColor="white" transparent="1" halign="left" valign="top" backgroundColor="black" />
-                <widget name="ping" position="313,36" zPosition="4" size="161,20" font="audiowide; 16" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-                <widget name="host" position="928,668" zPosition="4" size="254,80" font="audiowide; 21" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-                <widget name="ip" position="50,668" zPosition="4" size="254,80" font="audiowide; 21" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-                <widget name="download" position="543,58" zPosition="4" size="207,40" font="audiowide; 21" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-                <widget name="upload" position="821,58" zPosition="4" size="207,40" font="audiowide; 21" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-             </screen>"""
-    else:
-            skin = """<screen name="SpeedTestScreen" position="center,center" size="1237,720" title="Speed Test" backgroundColor="transparent" flags="wfNoBorder">
-                <ePixmap position="0,0" size="1237,720" pixmap="/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/speed_test720.png" zPosition="1" transparent="1" alphatest="blend" />
-                <widget name="data" position="208,106" zPosition="4" size="824,337" font="Regular; 20" foregroundColor="white" transparent="1" halign="left" valign="top" backgroundColor="black" />
-                <widget name="ping" position="308,11" zPosition="4" size="161,20" font="audiowide; 16" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-                <widget name="host" position="918,636" zPosition="4" size="254,80" font="audiowide; 21" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-                <widget name="ip" position="40,636" zPosition="4" size="254,80" font="audiowide; 21" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-                <widget name="download" position="538,28" zPosition="4" size="207,40" font="audiowide; 21" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-                <widget name="upload" position="816,28" zPosition="4" size="207,40" font="audiowide; 21" foregroundColor="white" transparent="1" halign="left" valign="center" backgroundColor="rds_text_bg" />
-             </screen>"""
-    def __init__(self, session):
-        Screen.__init__(self, session)
-        self.color = '#800080'
-        
-        self['data'] = Label(_('Testing net speed,please wait......'))
-        self['ping'] = Label(" ")
-        self['host'] = Label(" ")
-        self['ip'] = Label(" ")
-        self['download'] = Label(" ")
-
-        self['upload'] = Label(" ")
-        self['actions'] = ActionMap(['OkCancelActions','ColorActions'],{'cancel': self.exit,'green': self.testagain}, -1)
-        
-        cmd="python "+TEST_PATH+"/speedtesting.pyo"
-        self.finished=False
-        self.data=''
-        self.container = eConsoleAppContainer()
-        self.container.appClosed.append(self.action)
-        self.container.dataAvail.append(self.dataAvail)
-        
-        self.container.execute(cmd)
-    def testagain(self):
-        if  self.finished==False:
-            return
-        self['data'].setText(_("Testing net speed,please wait......"))
-        self['ping'].setText("")
-        cmd="python "+TEST_PATH+"/speedtesting.pyo"
-        self.container.execute(cmd)
-    def action(self, retval):
-        print "retval",retval
-        print _("finished test")
-        self.finished=True
-    def dataAvail(self, rstr):
-            
-            if rstr:
-               
-                self.data=self.data+rstr
-                parts=rstr.split("\n")
-                for part in parts:
-                    if 'Alojado por' in part:
-                        try:host=part.split("Alojado por")[1].split("[")[0].strip()
-                        except:host=''
-                        self['host'].setText(str(host))
-                    if 'Test desde' in part:
-                        ip=part.split("Test desde")[1].split(")")[0].replace("(","").strip()
-                        self['ip'].setText(str(ip))                        
-                if  "Ping" in rstr:
-                    
-                    try:ping =rstr.split("Ping")[1].split("\n")[0].strip()
-                    except:ping=''
-                    
-                   
-                    self['ping'].setText(str(ping))
-                    
-                if  "Descarga:" in rstr:
-                    
-                    try:download =rstr.split(":")[1].split("\n")[0].strip()
-                    except:download =''
-                    
-                    self['download'].setText(str(download))
-                    self.data=''
-                    self.data=_('Testing upload speed....')    
-                if  "Subida:" in rstr:
-                   
-                    try:upload =rstr.split(":")[1].split("\n")[0].strip()
-                    except:upload =''
-                    
-                    self['upload'].setText(str(upload))
-                    self['data'].setText(_(" Test completed,to test again press green"))
-                    return
-                       
-                    
-                self['data'].setText(self.data)
-                
-                                
-               
-                     
-                     
-                
-    def exit(self):
-        
-            self.container.appClosed.remove(self.action)
-            self.container.dataAvail.remove(self.dataAvail)
-            self.close()
-
-
-    def updateTitle(self):
-        self.newtitle='speedtest'
-        self.setTitle(self.newtitle)
-
diff --git a/lib/python/Plugins/Extensions/Openpanel/SwapManager.py b/lib/python/Plugins/Extensions/Openpanel/SwapManager.py
deleted file mode 100644
index 858d0ea..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/SwapManager.py
+++ /dev/null
@@ -1,308 +0,0 @@
-from Screens.Screen import Screen
-from Screens.MessageBox import MessageBox
-from Screens.ChoiceBox import ChoiceBox
-from Components.config import config, configfile, ConfigYesNo, ConfigSubsection
-from Components.ActionMap import ActionMap
-from Components.Label import Label
-from Components.Pixmap import Pixmap
-from Components.Harddisk import harddiskmanager, getProcMounts
-from Components.Console import Console
-from Components.Sources.StaticText import StaticText
-from os import system, stat as mystat, path, remove, rename
-from enigma import eTimer
-from glob import glob
-import stat
-
-config.plugins.openpanel = ConfigSubsection()
-config.plugins.openpanel.swapautostart = ConfigYesNo(default = False)
-
-startswap = None
-
-def SwapAutostart(reason, session=None, **kwargs):
-	global startswap
-	if reason == 0:
-		if config.plugins.openpanel.swapautostart.value:
-			print "[SwapManager] autostart"
-			startswap = StartSwap()
-			startswap.start()
-	
-class StartSwap:
-	def __init__(self):
-		self.Console = Console()
-
-	def start(self):
-	 	self.Console.ePopen("sfdisk -l /dev/sd? 2>/dev/null | grep swap", self.startSwap2)
-
-	def startSwap2(self, result = None, retval = None, extra_args = None):
-		swap_place = ""
-		if result and result.find('sd') != -1:
-			for line in result.split('\n'):
-				if line.find('sd') != -1:
-					parts = line.strip().split()
-					swap_place = parts[0]
-					file('/etc/fstab.tmp', 'w').writelines([l for l in file('/etc/fstab').readlines() if swap_place not in l])
-					rename('/etc/fstab.tmp','/etc/fstab')
-					print "[SwapManager] Found a swap partition:", swap_place
-		else:
-			devicelist = []
-			for p in harddiskmanager.getMountedPartitions():
-				d = path.normpath(p.mountpoint)
-				if path.exists(p.mountpoint) and p.mountpoint != "/" and not p.mountpoint.startswith('/media/net') and not p.mountpoint.startswith('/media/autofs'):
-					devicelist.append((p.description, d))
-			if len(devicelist):
-				for device in devicelist:
-					for filename in glob(device[1] + '/swap*'):
-						if path.exists(filename):
-							swap_place = filename
-							print "[SwapManager] Found a swapfile on ", swap_place
-
-		f = file('/proc/swaps').read()
-		if f.find(swap_place) == -1:
-			print "[SwapManager] Starting swapfile on ", swap_place
-			system('swapon ' + swap_place)
-		else:
-			print "[SwapManager] Swapfile is already active on ", swap_place
-	
-#######################################################################
-class Swap(Screen):
-	skin = """
-	<screen name="Swap" position="center,center" size="420,250" title="Swap File Manager" flags="wfBorder" >
-		<ePixmap pixmap="skin_default/buttons/red.png" position="0,0" size="140,40" alphatest="on" />
-		<ePixmap pixmap="skin_default/buttons/green.png" position="140,0" size="140,40" alphatest="on" />
-		<ePixmap pixmap="skin_default/buttons/yellow.png" position="280,0" size="140,40" alphatest="on" />
-		<widget name="key_red" position="0,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#9f1313" transparent="1" />
-		<widget name="key_green" position="140,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#1f771f" transparent="1" />
-		<widget name="key_yellow" position="280,0" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="#a08500" transparent="1" />
-		<widget name="autostart_off" position="10,50" zPosition="1" pixmap="skin_default/icons/lock_off.png" size="32,32" alphatest="on" />
-		<widget name="autostart_on" position="10,50" zPosition="2" pixmap="skin_default/icons/lock_on.png" size="32,32" alphatest="on" />
-		<widget name="lab1" position="50,50" size="360,30" font="Regular;20" valign="center" transparent="1"/>
-		<widget name="lab2" position="10,100" size="150,30" font="Regular;20" valign="center" transparent="1"/>
-		<widget name="lab3" position="10,150" size="150,30" font="Regular;20" valign="center" transparent="1"/>
-		<widget name="lab4" position="10,200" size="150,30" font="Regular;20" valign="center" transparent="1" />
-		<widget name="labplace" position="160,100" size="220,30" font="Regular;20" valign="center" backgroundColor="#4D5375"/>
-		<widget name="labsize" position="160,150" size="220,30" font="Regular;20" valign="center" backgroundColor="#4D5375"/>
-		<widget name="inactive" position="160,200" size="100,30" font="Regular;20" valign="center" halign="center" backgroundColor="red"/>
-		<widget name="active" position="160,200" size="100,30" font="Regular;20" valign="center" halign="center" backgroundColor="green"/>
-	</screen>"""
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Swap Manager"))
-		self['lab1'] = Label()
-		self['autostart_on'] = Pixmap()
-		self['autostart_off'] = Pixmap()
-		self['lab2'] = Label(_("Swap Place:"))
-		self['labplace'] = Label()
-		self['lab3'] = Label(_("Swap Size:"))
-		self['labsize'] = Label()
-		self['lab4'] = Label(_("Status:"))
-		self['inactive'] = Label(_("Inactive"))
-		self['active'] = Label(_("Active"))
-		self['key_red'] = Label(_("Activate"))
-		self['key_green'] = Label(_("Create"))
-		self['key_yellow'] = Label(_("Autostart"))
-		self['swapname_summary'] = StaticText()
-		self['swapactive_summary'] = StaticText()
-		self.Console = Console()
-		self.swap_place = ''
-		self.new_place = ''
-		self.creatingswap = False
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions', "MenuActions"], {'back': self.close, 'red': self.actDeact, 'green': self.createDel, 'yellow': self.autoSsWap, "menu": self.close})
-		self.activityTimer = eTimer()
-		self.activityTimer.timeout.get().append(self.getSwapDevice)
-		self.updateSwap()
-
-	def updateSwap(self, result = None, retval = None, extra_args = None):
-		self["actions"].setEnabled(False)
-		self.swap_active = False
-		self['autostart_on'].hide()
-		self['autostart_off'].show()
-		self['active'].hide()
-		self['inactive'].show()
-		self['labplace'].hide()
-		self['labsize'].hide()
-		self['swapactive_summary'].setText(_("Current Status:"))
-		scanning = _("Wait please while scanning...")
-		self['lab1'].setText(scanning)
-		self.activityTimer.start(10)
-
-	def getSwapDevice(self):
-		self.activityTimer.stop()
-		if path.exists('/etc/rcS.d/S98SwapManager'):
-			remove('/etc/rcS.d/S98SwapManager')
-			config.plugins.openpanel.swapautostart.value = True
-			config.plugins.openpanel.swapautostart.save()
-		if path.exists('/tmp/swapdevices.tmp'):
-			remove('/tmp/swapdevices.tmp')
-		self.Console.ePopen("sfdisk -l /dev/sd? 2>/dev/null | grep swap", self.updateSwap2)
-
-	def updateSwap2(self, result = None, retval = None, extra_args = None):
-		self.swapsize = 0
-		self.swap_place = ''
-		self.swap_active = False
-		self.device = False
-		if result.find('sd') > 0:
-			self['key_green'].setText("")
-			for line in result.split('\n'):
-				if line.find('sd') > 0:
-					parts = line.strip().split()
-					self.swap_place = parts[0]
-					if self.swap_place == 'sfdisk:':
-						self.swap_place = ''
-					self.device = True
-				f = open('/proc/swaps', 'r')
-				for line in f.readlines():
-					parts = line.strip().split()
-					if line.find('partition') != -1:
-						self.swap_active = True
-						self.swapsize = parts[2]
-						continue
-				f.close()
-		else:
-			self['key_green'].setText(_("Create"))
-			devicelist = []
-			for p in harddiskmanager.getMountedPartitions():
-				d = path.normpath(p.mountpoint)
-				if path.exists(p.mountpoint) and p.mountpoint != "/" and not p.mountpoint.startswith('/media/net') and not p.mountpoint.startswith('/media/autofs'):
-					devicelist.append((p.description, d))
-			if len(devicelist):
-				for device in devicelist:
-					for filename in glob(device[1] + '/swap*'):
-						self.swap_place = filename
-						self['key_green'].setText(_("Delete"))
-						info = mystat(self.swap_place)
-						self.swapsize = info[stat.ST_SIZE]
-						continue
-
-		if config.plugins.openpanel.swapautostart.value and self.swap_place:
-			self['autostart_off'].hide()
-			self['autostart_on'].show()
-		else:
-			config.plugins.openpanel.swapautostart.value = False
-			config.plugins.openpanel.swapautostart.save()
-			configfile.save()
-			self['autostart_on'].hide()
-			self['autostart_off'].show()
-		self['labplace'].setText(self.swap_place)
-		self['labplace'].show()
-
-		f = open('/proc/swaps', 'r')
-		for line in f.readlines():
-			parts = line.strip().split()
-			if line.find('partition') != -1:
-				self.swap_active = True
-				continue
-			elif line.find('file') != -1:
-				self.swap_active = True
-				continue
-		f.close()
-
-		if self.swapsize > 0:
-			if self.swapsize >= 1024:
-				self.swapsize = int(self.swapsize) / 1024
-				if self.swapsize >= 1024:
-					self.swapsize = int(self.swapsize) / 1024
-				self.swapsize = str(self.swapsize) + ' ' + 'MB'
-			else:
-				self.swapsize = str(self.swapsize) + ' ' + 'KB'
-		else:
-			self.swapsize = ''
-
-		self['labsize'].setText(self.swapsize)
-		self['labsize'].show()
-
-		if self.swap_active == True:
-			self['inactive'].hide()
-			self['active'].show()
-			self['key_red'].setText(_("Deactivate"))
-			self['swapactive_summary'].setText(_("Current Status:") + ' ' + _("Active"))
-		else:
-			self['inactive'].show()
-			self['active'].hide()
-			self['key_red'].setText(_("Activate"))
-			self['swapactive_summary'].setText(_("Current Status:") + ' ' + _("Inactive"))
-
-		scanning = _("Enable Swap at startup")
-		self['lab1'].setText(scanning)
-		self['lab1'].show()
-		self["actions"].setEnabled(True)
-
-		name = self['labplace'].text
-		self['swapname_summary'].setText(name)
-
-	def actDeact(self):
-		if self.swap_active == True:
-			self.Console.ePopen('swapoff ' + self.swap_place, self.updateSwap)
-		else:
-			if not self.device:
-				if self.swap_place != '':
-					self.Console.ePopen('swapon ' + self.swap_place, self.updateSwap)
-				else:
-					mybox = self.session.open(MessageBox, _("Swap File not found. You have to create the file before to activate."), MessageBox.TYPE_INFO)
-					mybox.setTitle(_("Info"))
-			else:
-				self.Console.ePopen('swapon ' + self.swap_place, self.updateSwap)
-
-	def createDel(self):
-		if not self.device:
-			if self.swap_place != '':
-				if self.swap_active == True:
-					self.Console.ePopen('swapoff ' + self.swap_place, self.createDel2)
-				else:
-					self.createDel2(None, 0)
-			else:
-				self.doCreateSwap()
-
-	def createDel2(self, result, retval, extra_args = None):
-		if retval == 0:
-			remove(self.swap_place)
-			if config.plugins.openpanel.swapautostart.value:
-				config.plugins.openpanel.swapautostart.value = False
-				config.plugins.openpanel.swapautostart.save()
-				configfile.save()
-			self.updateSwap()
-
-	def doCreateSwap(self):
-		parts = []
-		supported_filesystems = frozenset(('ext4', 'ext3', 'ext2', 'vfat'))
-		candidates = []
-		mounts = getProcMounts() 
-		for partition in harddiskmanager.getMountedPartitions(False, mounts):
-			if partition.filesystem(mounts) in supported_filesystems:
-				candidates.append((partition.description, partition.mountpoint)) 
-		if len(candidates):
-			self.session.openWithCallback(self.doCSplace, ChoiceBox, title = _("Please select device to use as swapfile location"), list = candidates)
-		else:
-			self.session.open(MessageBox, _("Sorry, no physical devices that supports SWAP attached. Can't create Swapfile on network or fat32 filesystems"), MessageBox.TYPE_INFO, timeout = 10)
-
-	def doCSplace(self, name):
-		if name:
-			self.new_place = name[1]
-			myoptions = [[_("32 Mb"), '32768'], [_("64 Mb"), '65536'], [_("128 Mb"), '131072'], [_("256 Mb"), '262144'], [_("512 Mb"), '524288'], [_("1024 Mb"), '1048576'], [_("1536 Mb"), '1572864'], [_("2048 Mb"), '2097152']]
-			self.session.openWithCallback(self.doCSsize, ChoiceBox, title=_("Select the Swap File Size:"), list=myoptions)
-
-	def doCSsize(self, swapsize):
-		if swapsize:
-			self["actions"].setEnabled(False)
-			scanning = _("Wait please while creating swapfile...")
-			self['lab1'].setText(scanning)
-			self['lab1'].show()
-			swapsize = swapsize[1]
-			myfile = self.new_place + '/swapfile'
-			self.commands = []
-			self.commands.append('dd if=/dev/zero of=' + myfile + ' bs=1024 count=' + swapsize + ' 2>/dev/null')
-			self.commands.append('mkswap ' + myfile)
-			self.Console.eBatch(self.commands, self.updateSwap, debug=True)
-		
-	def autoSsWap(self):
-		if self.swap_place:
-			if config.plugins.openpanel.swapautostart.value:
-				config.plugins.openpanel.swapautostart.value = False
-				config.plugins.openpanel.swapautostart.save()
-			else:
-				config.plugins.openpanel.swapautostart.value = True
-				config.plugins.openpanel.swapautostart.save()
-			configfile.save()
-		else:
-			mybox = self.session.open(MessageBox, _("You have to create a Swap File before to activate the autostart."), MessageBox.TYPE_INFO)
-			mybox.setTitle(_("Info"))
-		self.updateSwap()
diff --git a/lib/python/Plugins/Extensions/Openpanel/__init__.py b/lib/python/Plugins/Extensions/Openpanel/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/AV_Setup.png b/lib/python/Plugins/Extensions/Openpanel/icons/AV_Setup.png
deleted file mode 100644
index 59088b7..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/AV_Setup.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Automount.png b/lib/python/Plugins/Extensions/Openpanel/icons/Automount.png
deleted file mode 100644
index 0a71f0d..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Automount.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Autostart.png b/lib/python/Plugins/Extensions/Openpanel/icons/Autostart.png
deleted file mode 100644
index e54b5a3..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Autostart.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/BackupFiles.png b/lib/python/Plugins/Extensions/Openpanel/icons/BackupFiles.png
deleted file mode 100644
index 541d9e3..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/BackupFiles.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/BackupFilesAdditional.png b/lib/python/Plugins/Extensions/Openpanel/icons/BackupFilesAdditional.png
deleted file mode 100644
index 44477bb..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/BackupFilesAdditional.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/BackupFilesExcluded.png b/lib/python/Plugins/Extensions/Openpanel/icons/BackupFilesExcluded.png
deleted file mode 100644
index 9b09809..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/BackupFilesExcluded.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/BackupSettings.png b/lib/python/Plugins/Extensions/Openpanel/icons/BackupSettings.png
deleted file mode 100644
index 3af7632..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/BackupSettings.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Cpu.png b/lib/python/Plugins/Extensions/Openpanel/icons/Cpu.png
deleted file mode 100644
index a8bd505..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Cpu.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/CronManager.png b/lib/python/Plugins/Extensions/Openpanel/icons/CronManager.png
deleted file mode 100644
index 0bb782f..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/CronManager.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/FreeSpace.png b/lib/python/Plugins/Extensions/Openpanel/icons/FreeSpace.png
deleted file mode 100644
index 8e29d73..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/FreeSpace.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Harddisk.png b/lib/python/Plugins/Extensions/Openpanel/icons/Harddisk.png
deleted file mode 100644
index d317ce7..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Harddisk.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/ImageVersion.png b/lib/python/Plugins/Extensions/Openpanel/icons/ImageVersion.png
deleted file mode 100644
index 1bb25ec..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/ImageVersion.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Info.png b/lib/python/Plugins/Extensions/Openpanel/icons/Info.png
deleted file mode 100644
index f45f04b..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Info.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/InfoPanel.png b/lib/python/Plugins/Extensions/Openpanel/icons/InfoPanel.png
deleted file mode 100644
index 20b6447..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/InfoPanel.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Infos.png b/lib/python/Plugins/Extensions/Openpanel/icons/Infos.png
deleted file mode 100644
index 7ef43e5..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Infos.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/JobManager.png b/lib/python/Plugins/Extensions/Openpanel/icons/JobManager.png
deleted file mode 100644
index 251f6fc..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/JobManager.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Kernel.png b/lib/python/Plugins/Extensions/Openpanel/icons/Kernel.png
deleted file mode 100644
index 4ba9769..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Kernel.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/KeymapSel.png b/lib/python/Plugins/Extensions/Openpanel/icons/KeymapSel.png
deleted file mode 100644
index 1b52123..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/KeymapSel.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Makefile.am b/lib/python/Plugins/Extensions/Openpanel/icons/Makefile.am
deleted file mode 100644
index 1b08513..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/icons/Makefile.am
+++ /dev/null
@@ -1,3 +0,0 @@
-installdir = $(pkglibdir)/python/Plugins/Extensions/Openpanel/icons
-
-install_PYTHON = *.png
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/MemInfo.png b/lib/python/Plugins/Extensions/Openpanel/icons/MemInfo.png
deleted file mode 100644
index 231aee5..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/MemInfo.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Module.png b/lib/python/Plugins/Extensions/Openpanel/icons/Module.png
deleted file mode 100644
index f9ed397..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Module.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/MountManager.png b/lib/python/Plugins/Extensions/Openpanel/icons/MountManager.png
deleted file mode 100644
index 631903d..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/MountManager.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Mounts.png b/lib/python/Plugins/Extensions/Openpanel/icons/Mounts.png
deleted file mode 100644
index 3c18b59..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Mounts.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Mtd.png b/lib/python/Plugins/Extensions/Openpanel/icons/Mtd.png
deleted file mode 100644
index bf691c4..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Mtd.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/MultiQuickButton.png b/lib/python/Plugins/Extensions/Openpanel/icons/MultiQuickButton.png
deleted file mode 100644
index 3d00819..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/MultiQuickButton.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Network.png b/lib/python/Plugins/Extensions/Openpanel/icons/Network.png
deleted file mode 100644
index ed47333..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Network.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Partitions.png b/lib/python/Plugins/Extensions/Openpanel/icons/Partitions.png
deleted file mode 100644
index f75c2a5..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Partitions.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Pluginbrowser.png b/lib/python/Plugins/Extensions/Openpanel/icons/Pluginbrowser.png
deleted file mode 100644
index d08b25a..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Pluginbrowser.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Plugins.png b/lib/python/Plugins/Extensions/Openpanel/icons/Plugins.png
deleted file mode 100644
index 9a8589a..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Plugins.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Ram.png b/lib/python/Plugins/Extensions/Openpanel/icons/Ram.png
deleted file mode 100644
index 88d1d89..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Ram.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Red-Key-Action.png b/lib/python/Plugins/Extensions/Openpanel/icons/Red-Key-Action.png
deleted file mode 100644
index 16b780f..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Red-Key-Action.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/RedPanel.png b/lib/python/Plugins/Extensions/Openpanel/icons/RedPanel.png
deleted file mode 100644
index 057619b..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/RedPanel.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/ResetPass.png b/lib/python/Plugins/Extensions/Openpanel/icons/ResetPass.png
deleted file mode 100644
index 93800f9..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/ResetPass.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/RestoreSettings.png b/lib/python/Plugins/Extensions/Openpanel/icons/RestoreSettings.png
deleted file mode 100644
index 4160965..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/RestoreSettings.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Script-Verwaltung.png b/lib/python/Plugins/Extensions/Openpanel/icons/Script-Verwaltung.png
deleted file mode 100644
index d7cf108..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Script-Verwaltung.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Setup.png b/lib/python/Plugins/Extensions/Openpanel/icons/Setup.png
deleted file mode 100644
index e9769aa..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Setup.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Softcam-Panel Setup.png b/lib/python/Plugins/Extensions/Openpanel/icons/Softcam-Panel Setup.png
deleted file mode 100644
index 09dd207..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Softcam-Panel Setup.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Softcam-Panel.png b/lib/python/Plugins/Extensions/Openpanel/icons/Softcam-Panel.png
deleted file mode 100644
index faf7821..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Softcam-Panel.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Softcam.png b/lib/python/Plugins/Extensions/Openpanel/icons/Softcam.png
deleted file mode 100644
index 7b9d876..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Softcam.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/SoftcamPanel.png b/lib/python/Plugins/Extensions/Openpanel/icons/SoftcamPanel.png
deleted file mode 100644
index 96350cd..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/SoftcamPanel.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/SoftcamPanelSetup.png b/lib/python/Plugins/Extensions/Openpanel/icons/SoftcamPanelSetup.png
deleted file mode 100644
index e1b18b5..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/SoftcamPanelSetup.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/SoftwareManager.png b/lib/python/Plugins/Extensions/Openpanel/icons/SoftwareManager.png
deleted file mode 100644
index 48c31b5..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/SoftwareManager.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Software_Manager.png b/lib/python/Plugins/Extensions/Openpanel/icons/Software_Manager.png
deleted file mode 100644
index dfbd239..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Software_Manager.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/SpeedTest.png b/lib/python/Plugins/Extensions/Openpanel/icons/SpeedTest.png
deleted file mode 100644
index 12a3aac..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/SpeedTest.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/SundtekControlCenter.png b/lib/python/Plugins/Extensions/Openpanel/icons/SundtekControlCenter.png
deleted file mode 100644
index d78b890..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/SundtekControlCenter.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Swap.png b/lib/python/Plugins/Extensions/Openpanel/icons/Swap.png
deleted file mode 100644
index 0648e14..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Swap.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/SwapManager.png b/lib/python/Plugins/Extensions/Openpanel/icons/SwapManager.png
deleted file mode 100644
index f4bb396..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/SwapManager.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/System.png b/lib/python/Plugins/Extensions/Openpanel/icons/System.png
deleted file mode 100644
index c51d7ea..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/System.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/SystemInfo.png b/lib/python/Plugins/Extensions/Openpanel/icons/SystemInfo.png
deleted file mode 100644
index fe2a37b..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/SystemInfo.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/System_Info.png b/lib/python/Plugins/Extensions/Openpanel/icons/System_Info.png
deleted file mode 100644
index b8eca3a..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/System_Info.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Top.png b/lib/python/Plugins/Extensions/Openpanel/icons/Top.png
deleted file mode 100644
index 9986291..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Top.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Tuner_Setup.png b/lib/python/Plugins/Extensions/Openpanel/icons/Tuner_Setup.png
deleted file mode 100644
index 364ee89..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Tuner_Setup.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Yellow-Key-Action.png b/lib/python/Plugins/Extensions/Openpanel/icons/Yellow-Key-Action.png
deleted file mode 100644
index 0af034b..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Yellow-Key-Action.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/Zu-sichernde-Dateien.png b/lib/python/Plugins/Extensions/Openpanel/icons/Zu-sichernde-Dateien.png
deleted file mode 100644
index d5f2a7e..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/Zu-sichernde-Dateien.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/agreen.png b/lib/python/Plugins/Extensions/Openpanel/icons/agreen.png
deleted file mode 100644
index 4856f84..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/agreen.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/aoff.png b/lib/python/Plugins/Extensions/Openpanel/icons/aoff.png
deleted file mode 100644
index a031b9b..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/aoff.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/ared.png b/lib/python/Plugins/Extensions/Openpanel/icons/ared.png
deleted file mode 100644
index bdd6b4b..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/ared.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/ayellow.png b/lib/python/Plugins/Extensions/Openpanel/icons/ayellow.png
deleted file mode 100644
index caf8a9c..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/ayellow.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/crond.png b/lib/python/Plugins/Extensions/Openpanel/icons/crond.png
deleted file mode 100644
index 91afb67..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/crond.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/default.png b/lib/python/Plugins/Extensions/Openpanel/icons/default.png
deleted file mode 100644
index b9f7030..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/default.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/dev_hdd.png b/lib/python/Plugins/Extensions/Openpanel/icons/dev_hdd.png
deleted file mode 100644
index f1463a7..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/dev_hdd.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/dev_mmc.png b/lib/python/Plugins/Extensions/Openpanel/icons/dev_mmc.png
deleted file mode 100644
index 6176536..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/dev_mmc.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/dev_usbstick.png b/lib/python/Plugins/Extensions/Openpanel/icons/dev_usbstick.png
deleted file mode 100644
index 524622f..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/dev_usbstick.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/empty.png b/lib/python/Plugins/Extensions/Openpanel/icons/empty.png
deleted file mode 100644
index cb05458..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/empty.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/folder.png b/lib/python/Plugins/Extensions/Openpanel/icons/folder.png
deleted file mode 100644
index 7c9f17b..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/folder.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/fpassword.png b/lib/python/Plugins/Extensions/Openpanel/icons/fpassword.png
deleted file mode 100644
index 843ca2d..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/fpassword.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/install.png b/lib/python/Plugins/Extensions/Openpanel/icons/install.png
deleted file mode 100644
index ba8b1b9..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/install.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/installable.png b/lib/python/Plugins/Extensions/Openpanel/icons/installable.png
deleted file mode 100644
index d5935e0..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/installable.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/installed.png b/lib/python/Plugins/Extensions/Openpanel/icons/installed.png
deleted file mode 100644
index c03c104..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/installed.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/lock_on.png b/lib/python/Plugins/Extensions/Openpanel/icons/lock_on.png
deleted file mode 100644
index a65e097..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/lock_on.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/menu.png b/lib/python/Plugins/Extensions/Openpanel/icons/menu.png
deleted file mode 100644
index 0625cd0..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/menu.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/ok.png b/lib/python/Plugins/Extensions/Openpanel/icons/ok.png
deleted file mode 100644
index 0a689fb..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/ok.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/partitionmanager.png b/lib/python/Plugins/Extensions/Openpanel/icons/partitionmanager.png
deleted file mode 100644
index dac5e47..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/partitionmanager.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/plugin.png b/lib/python/Plugins/Extensions/Openpanel/icons/plugin.png
deleted file mode 100644
index 7c77679..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/plugin.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/remove.png b/lib/python/Plugins/Extensions/Openpanel/icons/remove.png
deleted file mode 100644
index b4500a0..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/remove.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/run.png b/lib/python/Plugins/Extensions/Openpanel/icons/run.png
deleted file mode 100644
index e88abf8..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/run.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/setup1.png b/lib/python/Plugins/Extensions/Openpanel/icons/setup1.png
deleted file mode 100644
index 2cb574c..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/setup1.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/shutdown.png b/lib/python/Plugins/Extensions/Openpanel/icons/shutdown.png
deleted file mode 100644
index 51e79e1..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/shutdown.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/speed_test.png b/lib/python/Plugins/Extensions/Openpanel/icons/speed_test.png
deleted file mode 100644
index cd4aefa..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/speed_test.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/speed_test720.png b/lib/python/Plugins/Extensions/Openpanel/icons/speed_test720.png
deleted file mode 100644
index 674f842..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/speed_test720.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/update.png b/lib/python/Plugins/Extensions/Openpanel/icons/update.png
deleted file mode 100644
index 8530ac1..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/update.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/icons/upgrade.png b/lib/python/Plugins/Extensions/Openpanel/icons/upgrade.png
deleted file mode 100644
index 8f166a8..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/icons/upgrade.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/meta/Makefile.am b/lib/python/Plugins/Extensions/Openpanel/meta/Makefile.am
deleted file mode 100644
index 24dfeb1..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/meta/Makefile.am
+++ /dev/null
@@ -1,5 +0,0 @@
-installdir = $(datadir)/meta
-
-dist_install_DATA = plugin_openpanel.xml
-
-EXTRA_DIST = openpanel.jpg
diff --git a/lib/python/Plugins/Extensions/Openpanel/meta/infopanel.JPG b/lib/python/Plugins/Extensions/Openpanel/meta/infopanel.JPG
deleted file mode 100644
index fb23904..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/meta/infopanel.JPG and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/meta/openpanel.jpg b/lib/python/Plugins/Extensions/Openpanel/meta/openpanel.jpg
deleted file mode 100644
index fb23904..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/meta/openpanel.jpg and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/meta/plugin_infopanel.xml b/lib/python/Plugins/Extensions/Openpanel/meta/plugin_infopanel.xml
deleted file mode 100644
index 4e5b9b1..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/meta/plugin_infopanel.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<default>
-	<prerequisites>
-		<tag type="System" />
-	</prerequisites>
-	<info>
-		<author>OpenPlus TEAM</author>
-		<name>INFOPANEL</name>
-		<packagename>enigma2-plugin-extensions-openpanel</packagename>
-		<shortdescription>Control panel</shortdescription>
-		<description>control panel, softcam panel, job panel, device panel, special features.</description>
-	</info>
-	<files type="package"> <!-- without version, without .ipk -->
-		<file type="package" name="enigma2-plugin-extensions-openpanel" />
-	</files>
-</default>
diff --git a/lib/python/Plugins/Extensions/Openpanel/meta/plugin_openpanel.xml b/lib/python/Plugins/Extensions/Openpanel/meta/plugin_openpanel.xml
deleted file mode 100644
index e3b32d8..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/meta/plugin_openpanel.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<default>
-	<prerequisites>
-		<tag type="System" />
-	</prerequisites>
-	<info>
-		<author>OpenPlus TEAM</author>
-		<name>OPENPANEL</name>
-		<packagename>enigma2-plugin-extensions-openpanel</packagename>
-		<shortdescription>Control panel</shortdescription>
-		<description>control panel, softcam panel, job panel, device panel, special features.</description>
-	</info>
-	<files type="package"> <!-- without version, without .ipk -->
-		<file type="package" name="enigma2-plugin-extensions-openpanel" />
-	</files>
-</default>
diff --git a/lib/python/Plugins/Extensions/Openpanel/open.png b/lib/python/Plugins/Extensions/Openpanel/open.png
deleted file mode 100644
index f717db8..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/open.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/openhd.png b/lib/python/Plugins/Extensions/Openpanel/openhd.png
deleted file mode 100644
index b32540d..0000000
Binary files a/lib/python/Plugins/Extensions/Openpanel/openhd.png and /dev/null differ
diff --git a/lib/python/Plugins/Extensions/Openpanel/plugin.py b/lib/python/Plugins/Extensions/Openpanel/plugin.py
deleted file mode 100644
index 5e41a94..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/plugin.py
+++ /dev/null
@@ -1,1152 +0,0 @@
-from Plugins.Plugin import PluginDescriptor
-from Screens.PluginBrowser import *
-from Screens.Ipkg import Ipkg
-from Components.SelectionList import SelectionList
-from Screens.NetworkSetup import *
-from enigma import *
-from Screens.Standby import *
-from Screens.MessageBox import MessageBox
-from Components.ActionMap import ActionMap, NumberActionMap, HelpableActionMap 
-from Screens.Screen import Screen
-from Screens.ParentalControlSetup import ProtectedScreen
-from Screens.ChoiceBox import ChoiceBox
-from Tools.BoundFunction import boundFunction
-from Tools.LoadPixmap import LoadPixmap
-from Tools.Directories import resolveFilename, SCOPE_CURRENT_SKIN, SCOPE_PLUGINS,  fileExists, pathExists
-from Components.MenuList import MenuList
-from Components.FileList import FileList
-from Components.Label import Label
-from Components.ScrollLabel import ScrollLabel
-from Components.Pixmap import Pixmap
-from Components.config import ConfigSubsection, ConfigInteger, ConfigText, getConfigListEntry, ConfigSelection,  ConfigIP, ConfigYesNo, ConfigSequence, ConfigNumber, NoSave, ConfigEnableDisable, configfile
-from Components.ConfigList import ConfigListScreen
-from Components.Sources.StaticText import StaticText 
-from Components.Sources.Progress import Progress
-from Components.Button import Button
-from Components.ActionMap import ActionMap
-from Components.SystemInfo import SystemInfo
-from Screens.VirtualKeyBoard import VirtualKeyBoard
-from Components.MultiContent import MultiContentEntryText, MultiContentEntryPixmapAlphaBlend
-from boxbranding import getBoxType, getMachineName, getMachineBrand, getBrandOEM
-
-import os
-import sys
-import re
-font = "Regular;16"
-import ServiceReference
-import time
-import datetime
-inOPENPanel = None
-
-config.softcam = ConfigSubsection()
-config.softcam.actCam = ConfigText(visible_width = 200)
-config.softcam.actCam2 = ConfigText(visible_width = 200)
-config.softcam.waittime = ConfigSelection([('0',_("dont wait")),('1',_("1 second")), ('5',_("5 seconds")),('10',_("10 seconds")),('15',_("15 seconds")),('20',_("20 seconds")),('30',_("30 seconds"))], default='15')
-config.plugins.openpanel_redpanel = ConfigSubsection()
-
-def Check_Softcam():
-	found = False
-	if not os.path.exists('/usr/CamEmu'):
-		os.makedirs('/usr/CamEmu')
-	for x in os.listdir('/usr/CamEmu'):
-		if x.find('camemu.') > -1:
-			found = True
-			break;
-	return found
-
-def Check_SysSoftcam(): 
-        if os.path.isfile('/etc/init.d/softcam'):
-                if (os.path.islink('/etc/init.d/softcam') and not os.readlink('/etc/init.d/softcam').lower().endswith('none')):
-                        try:
-                                syscam = None
-                                syscam = os.readlink('/etc/init.d/softcam').rsplit('.', 1)[1]
-                                if syscam.lower().startswith('oscam'):
-                                        return "oscam"
-                        except:
-                                pass
-                if pathExists('/usr/bin/'):
-                        softcams = os.listdir('/usr/bin/')
-                        for softcam in softcams:
-                                if softcam.lower().startswith('oscam'):
-                                        return "oscam"
-        return None
-
-if Check_Softcam():
-	redSelection = [('0',_("Default (Instant Record)")), ('1',_("Openpanel")),('2',_("Timer List")),('3',_("Show Movies")), ('4',_("Softcam Panel"))]
-else:
-	redSelection = [('0',_("Default (Instant Record)")), ('1',_("Openpanel")),('2',_("Timer List")),('3',_("Show Movies"))]
-
-def timerEvent():
-	pluginlist = plugins.getPlugins(PluginDescriptor.WHERE_PLUGINMENU)
-	for p in pluginlist:
-		redSelection.append((p.name, _(p.name)))
-	if getBoxType() == "dm800":
-		config.plugins.openpanel_redpanel.selection = ConfigSelection(redSelection, default='0')
-		config.plugins.openpanel_redpanel.selectionLong = ConfigSelection(redSelection, default='1')
-	else:
-		config.plugins.openpanel_redpanel.selection = ConfigSelection(redSelection, default='1')
-		config.plugins.openpanel_redpanel.selectionLong = ConfigSelection(redSelection, default='2')
-timer = eTimer()
-timer.timeout.get().append(timerEvent)
-timer.startLongTimer(1)
-
-choicelist = [('0',_("Audio Selection")),('1',_("Default (Timeshift)")), ('2',_("Toggle Pillarbox <> Pan&Scan")),('3',_("Teletext")),('4',_("OpenWeather"))]
-config.plugins.openpanel_yellowkey = ConfigSubsection()
-if getBoxType() == "dm800":
-	config.plugins.openpanel_yellowkey.list = ConfigSelection(default='1', choices = choicelist)
-	config.plugins.openpanel_yellowkey.listLong = ConfigSelection(default='1', choices = choicelist)
-else:
-	config.plugins.openpanel_yellowkey.list = ConfigSelection(default='0', choices = choicelist)
-	config.plugins.openpanel_yellowkey.listLong = ConfigSelection(default='4', choices = choicelist)
-config.plugins.showopenpanelextensions = ConfigYesNo(default=False)
-config.plugins.openpanel_frozencheck = ConfigSubsection()
-config.plugins.openpanel_frozencheck.list = ConfigSelection([('0',_("Off")),('1',_("1 min.")), ('5',_("5 min.")),('10',_("10 min.")),('15',_("15 min.")),('30',_("30 min."))])
-	
-if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/MultiQuickButton/plugin.pyo") is True:
-	try:
-		from Plugins.Extensions.MultiQuickButton.plugin import *
-	except:
-		pass
-
-from Plugins.Extensions.Openpanel.CronManager import *
-from Plugins.Extensions.Openpanel.ScriptRunner import *
-from Plugins.Extensions.Openpanel.MountManager import *
-from Plugins.Extensions.Openpanel.SoftcamPanel import *
-from Plugins.Extensions.Openpanel.CamStart import *
-from Plugins.Extensions.Openpanel.CamCheck import *
-from Plugins.Extensions.Openpanel.SpeedTest import *
-from Plugins.Extensions.Openpanel.resetpas import *
-from Plugins.Extensions.Openpanel.SwapManager import Swap, SwapAutostart
-from Plugins.Extensions.Openpanel.SoftwarePanel import SoftwarePanel
-from Plugins.SystemPlugins.SoftwareManager.BackupRestore import BackupScreen, RestoreScreen, BackupSelection, getBackupPath, getBackupFilename
-from Plugins.SystemPlugins.SoftwareManager.BackupRestore import InitConfig as BackupRestore_InitConfig
-
-SystemInfo["SoftCam"] = Check_Softcam()
-
-# Hide Softcam-Panel Setup when no softcams installed
-if not Check_Softcam() and config.plugins.showopenpanelextensions.value:
-	config.plugins.showopenpanelextensions.value = False
-	config.plugins.showopenpanelextensions.save()
-	config.plugins.openpanel_redpanel.save()
-
-# Hide Keymap selection when no other keymaps installed.
-if config.usage.keymap.value != eEnv.resolve("${datadir}/enigma2/keymap.xml"):
-	if not os.path.isfile(eEnv.resolve("${datadir}/enigma2/keymap.usr")) and config.usage.keymap.value == eEnv.resolve("${datadir}/enigma2/keymap.usr"):
-		setDefaultKeymap()
-	if not os.path.isfile(eEnv.resolve("${datadir}/enigma2/keymap.ntr")) and config.usage.keymap.value == eEnv.resolve("${datadir}/enigma2/keymap.ntr"):
-		setDefaultKeymap()
-	if not os.path.isfile(eEnv.resolve("${datadir}/enigma2/keymap.u80")) and config.usage.keymap.value == eEnv.resolve("${datadir}/enigma2/keymap.u80"):
-		setDefaultKeymap()
-		
-def setDefaultKeymap():
-	print "[Info-Panel] Set Keymap to Default"
-	config.usage.keymap.value = eEnv.resolve("${datadir}/enigma2/keymap.xml")
-	config.save()
-
-# edit bb , touch commands.getouput with this def #
-def command(comandline, strip=1):
-  comandline = comandline + " >/tmp/command.txt"
-  os.system(comandline)
-  text = ""
-  if os.path.exists("/tmp/command.txt") is True:
-    file = open("/tmp/command.txt", "r")
-    if strip == 1:
-      for line in file:
-        text = text + line.strip() + '\n'
-    else:
-      for line in file:
-        text = text + line
-        if text[-1:] != '\n': text = text + "\n"
-    file.close()
-  # if one or last line then remove linefeed
-  if text[-1:] == '\n': text = text[:-1]
-  comandline = text
-  os.system("rm /tmp/command.txt")
-  return comandline
-
-boxversion = getBoxType()
-machinename = getMachineName()
-machinebrand = getMachineBrand()
-OEMname = getBrandOEM()
-
-INFO_Panel_Version = 'OpenPanel V1.2'
-print "[Open-Panel] machinebrand: %s"  % (machinebrand)
-print "[Open-Panel] machinename: %s"  % (machinename)
-print "[Open-Panel] oem name: %s"  % (OEMname)
-print "[Open-Panel] boxtype: %s"  % (boxversion)
-panel = open("/tmp/openpanel.ver", "w")
-panel.write(INFO_Panel_Version + '\n')
-panel.write("Machinebrand: %s " % (machinebrand)+ '\n')
-panel.write("Machinename: %s " % (machinename)+ '\n')
-panel.write("oem name: %s " % (OEMname)+ '\n')
-panel.write("Boxtype: %s " % (boxversion)+ '\n')
-try:
-	if config.softcam.camstartMode.value == "0":
-       		global timerInstance
-       		if timerInstance is None:
-       			timerInstance = CamStart(None)
-       			timerInstance.startTimer()
-except:
-	print "[OpenPanel] failed to start Cam"
-
-try:
-	panel.write("Keymap: %s " % (config.usage.keymap.value)+ '\n')
-except:
-	panel.write("Keymap: keymap file not found !!" + '\n')
-panel.close()
-
-ExitSave = "[Exit] = " +_("Cancel") +"              [Ok] =" +_("Save")
-
-
-class ConfigPORT(ConfigSequence):
-	def __init__(self, default):
-		ConfigSequence.__init__(self, seperator = ".", limits = [(1,65535)], default = default)
-
-def main(session, **kwargs):
-		session.open(Openpanel)
-
-def Apanel(menuid, **kwargs):
-	if menuid == "mainmenu":
-		return [(_("Open Panel"), main, "Openpanel", 3)]
-	else:
-		return []
-
-def camstart(reason, **kwargs):
-	if not config.plugins.openpanel_frozencheck.list.value == '0':
-		CamCheck()
-	try:
-		f = open("/proc/stb/video/alpha", "w")
-		f.write(str(config.osd.alpha.value))
-		f.close()
-	except:
-		print "[Info-Panel] failed to write /proc/stb/video/alpha"
-
-	try:
-		if config.softcam.camstartMode.value == "0":
-			global timerInstance
-			if timerInstance is None:
-				timerInstance = CamStart(None)
-			timerInstance.startTimer()
-	except:
-		print "[Info-Panel] failed to run CamStart"
-
-def Plugins(**kwargs):
-	return [
-
-	#// show Openpanel in Main Menu
-	PluginDescriptor(name=_("OpenPanel"), description="Open panel GUI", where = PluginDescriptor.WHERE_MENU, fnc = Apanel),
-	#// autostart
-	PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART,PluginDescriptor.WHERE_AUTOSTART],fnc = camstart),
-	#// SwapAutostart
-	PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART,PluginDescriptor.WHERE_AUTOSTART],fnc = SwapAutostart),
-	#// show Openpanel in EXTENSIONS Menu
-	PluginDescriptor(name=_("OpenPanel"), description="Open panel GUI", where = PluginDescriptor.WHERE_EXTENSIONSMENU, fnc = main) ]
-
-
-
-
-#############------- SKINS --------############################
-
-MENU_SKIN = """<screen position="center,center" size="500,370" title="Open Panel">
-	<widget source="global.CurrentTime" render="Label" position="312,340" size="173,26" font="Regular;20" foregroundColor="#FFFFFF" halign="right" transparent="1" zPosition="5">
-		<convert type="ClockToText">&gt;Format%H:%M:%S</convert>
-	</widget>
-	<eLabel backgroundColor="#56C856" position="0,330" size="500,1" zPosition="0" />
-	<widget name="Mlist" position="10,10" size="480,300" zPosition="1" scrollbarMode="showOnDemand" foregroundColor="#FFFFFF" transparent="1" />
-	<widget name="label1" position="10,340" size="490,25" font="Regular;20" transparent="1" foregroundColor="#f2e000" halign="left" />
-</screen>"""
-
-CONFIG_SKIN = """<screen position="center,center" size="600,440" title="Open Panel Config" >
-	<widget name="config" position="10,10" size="580,377" enableWrapAround="1" scrollbarMode="showOnDemand" />
-	<widget name="labelExitsave" position="90,410" size="420,25" halign="center" font="Regular;20" transparent="1" foregroundColor="#f2e000" />
-</screen>"""
-
-INFO_SKIN =  """<screen name="Panel-Info"  position="center,center" size="730,400" title="Open Panel-Info" >
-	<widget name="label2" position="0,10" size="730,25" font="Regular;20" transparent="1" halign="center" foregroundColor="#f2e000" />
-	<widget name="label1" position="10,45" size="710,350" font="Console;20" zPosition="1" backgroundColor="#251e1f20" foregroundColor="#ffffff" transparent="1" />
-</screen>"""
-
-INFO_SKIN2 =  """<screen name="PANEL-Info2"  position="center,center" size="530,400" title="Open Panel-Info" backgroundColor="#251e1f20">
-	<widget name="label1" position="10,50" size="510,340" font="Regular;15" zPosition="1" backgroundColor="#251e1f20" foregroundColor="#ffffff" transparent="1" />
-</screen>"""
-
-
-###################  Max Test ###################
-class PanelList(MenuList):
-	def __init__(self, list, font0 = 17, font1 = 16, itemHeight = 50, enableWrapAround = True):
-		MenuList.__init__(self, list, enableWrapAround, eListboxPythonMultiContent)
-		screenwidth = getDesktop(0).size().width()
-		if screenwidth and screenwidth == 1920:
-			self.l.setFont(0, gFont("Regular", int(font0 * 1.5)))
-			self.l.setFont(1, gFont("Regular", int(font1 * 1.5)))
-			self.l.setItemHeight(int(itemHeight*1.5))
-		else:
-			self.l.setFont(0, gFont("Regular", font0))
-			self.l.setFont(1, gFont("Regular", font1))
-			self.l.setItemHeight(itemHeight)
-
-def MenuEntryItem(entry):
-	res = [entry]
-	screenwidth = getDesktop(0).size().width()
-	if screenwidth and screenwidth == 1920:
-		res.append(MultiContentEntryPixmapAlphaBlend(pos=(15, 12), size=(60, 60), png=entry[0]))  # png vorn
-		res.append(MultiContentEntryText(pos=(90, 10), size=(810, 60), font=0, text=entry[1]))  # menupunkt
-	else:
-		res.append(MultiContentEntryPixmapAlphaBlend(pos=(10, 5), size=(40, 40), png=entry[0]))  # png vorn
-		res.append(MultiContentEntryText(pos=(60, 10), size=(540, 40), font=0, text=entry[1]))  # menupunkt
-	return res
-###################  Max Test ###################
-
-#g
-from Screens.PiPSetup import PiPSetup
-from Screens.InfoBarGenerics import InfoBarPiP
-#g
-
-def InfoEntryComponent(file):
-	png = LoadPixmap(cached = True, path = resolveFilename(SCOPE_CURRENT_SKIN, "icons/" + file + ".png"));
-	if png == None:
-		png = LoadPixmap("/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/" + file + ".png")
-		if png == None:
-			png = LoadPixmap(cached = True, path = resolveFilename(SCOPE_CURRENT_SKIN, "icons/default1.png"));
-			if png == None:
-				png = LoadPixmap("/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/icons/default.png")
-	res = (png)
-	return res
-
-class Openpanel(Screen, InfoBarPiP, ProtectedScreen):
-	servicelist = None
-	def __init__(self, session, services = None):
-		Screen.__init__(self, session)
-		config.plugins.configurationbackup=BackupRestore_InitConfig()
-		if config.ParentalControl.configured.value:
-			ProtectedScreen.__init__(self)
-		self.session = session
-		self.skin = MENU_SKIN
-		self.onShown.append(self.setWindowTitle)
-		ProtectedScreen.__init__(self)
-		self.service = None
-		global pluginlist
-		global videomode
-		global infook
-		global INFOCONF
-		global menu
-		INFOCONF = 0
-		pluginlist="False"
-		try:
-			print '[Open-Panel] SHOW'
-			global inOPENPanel
-			inOPENPanel = self
-		except:
-			print '[Open-Panel] Error Hide'
-#		global servicelist
-		if services is not None:
-			self.servicelist = services
-		else:
-			self.servicelist = None
-		self.list = []
-		#// get the remote buttons
-		self["actions"] = ActionMap(["OkCancelActions", "DirectionActions", "ColorActions"],
-			{
-				"cancel": self.Exit,
-				"upUp": self.up,
-				"downUp": self.down,
-				"ok": self.ok,
-			}, 1)
-		
-		self["label1"] = Label(INFO_Panel_Version)
-		self["summary_description"] = StaticText("")
-
-		self.Mlist = []
-		if Check_SysSoftcam() is "oscam":
-		        self.Mlist.append(MenuEntryItem((InfoEntryComponent('OScamInfo'), _("OScamInfo"), 'OScamInfo')))
-		if Check_Softcam():
-			self.Mlist.append(MenuEntryItem((InfoEntryComponent('SoftcamPanel'), _("SoftcamPanel"), 'SoftcamPanel')))
-			self.Mlist.append(MenuEntryItem((InfoEntryComponent('SoftcamPanelSetup'), _("Softcam-Panel Setup"), 'Softcam-Panel Setup')))
-		#self.Mlist.append(MenuEntryItem((InfoEntryComponent ("SoftwareManager" ), _("Software update"), ("software-update"))))
-		self.Mlist.append(MenuEntryItem((InfoEntryComponent ("SoftwareManager" ), _("Software Manager"), ("software-manager"))))
-		self.Mlist.append(MenuEntryItem((InfoEntryComponent('KeymapSel'), _("Keymap Selection"), 'KeymapSel')))	
-		self.Mlist.append(MenuEntryItem((InfoEntryComponent('Plugins'), _("Plugins"), 'Plugins')))
-		self.Mlist.append(MenuEntryItem((InfoEntryComponent('Infos'), _("Infos"), 'Infos')))
-		self.onChangedEntry = []
-		if (getDesktop(0).size().width() == 1280):
-			self["Mlist"] = PanelList([])
-		else:
-			self["Mlist"] = PanelList([], font0=22, font1=16, itemHeight=50)
-		self["Mlist"].l.setList(self.Mlist)
-		menu = 0
-		self["Mlist"].onSelectionChanged.append(self.selectionChanged)
-
-	def isProtected(self):
-		return config.ParentalControl.setuppinactive.value and not config.ParentalControl.config_sections.main_menu.value and config.ParentalControl.config_sections.openpanel.value
-
-	def createSummary(self):
-		pass
-
-	def getCurrentEntry(self):
-		if self['Mlist'].l.getCurrentSelection():
-			selection = self['Mlist'].l.getCurrentSelection()[0]
-			self["summary_description"].text = selection[1]
-			if (selection[0] is not None):
-				return selection[0]
-
-	def selectionChanged(self):
-		item = self.getCurrentEntry()
-
-	def setWindowTitle(self):
-		self.setTitle(_("Open Panel"))
-		self.selectionChanged()
-
-	def up(self):
-		#self["Mlist"].up()
-		pass
-
-	def down(self):
-		#self["Mlist"].down()
-		pass
-
-	def left(self):
-		pass
-
-	def right(self):
-		pass
-
-	def Red(self):
-		self.showExtensionSelection1(Parameter="run")
-		pass
-
-	def Green(self):
-		#// Not used
-		pass
-
-	def yellow(self):
-		#// Not used
-		pass
-
-	def blue(self):
-		#// Not used
-		pass
-
-	def Exit(self):
-		#// Exit Openpanel when pressing the EXIT button or go back to the MainMenu
-		global menu
-		if menu == 0:
-			try:
-				self.service = self.session.nav.getCurrentlyPlayingServiceReference()
-				service = self.service.toCompareString()
-				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
-				print '[Open-Panel] HIDE'
-				global inOPENPanel
-				inOPENPanel = None
-			except:
-				print '[Open-Panel] Error Hide'
-			self.close()
-		elif menu == 1:
-			self["Mlist"].moveToIndex(0)
-			self["Mlist"].l.setList(self.oldmlist)
-			menu = 0
-			self["label1"].setText(INFO_Panel_Version)
-		elif menu == 2:
-			self["Mlist"].moveToIndex(0)
-			self["Mlist"].l.setList(self.oldmlist1)
-			menu = 1
-			self["label1"].setText("Infos")
-		else:
-			pass
-
-	def ok(self):
-		#// Menu Selection
-#		menu = self["Mlist"].getCurrent()
-		global INFOCONF
-		menu = self['Mlist'].l.getCurrentSelection()[0][2]
-		print '[Open-Panel] MenuItem: ' + menu
-		if menu == "Plugins":
-			self.Plugins()
-		elif menu == "Pluginbrowser":
-			self.session.open(PluginBrowser)
-		elif menu == "Infos":
-			self.Infos()
-		elif menu == "OpenPanel":
-			self.session.open(Info, "OpenPanel")
-		elif menu == "Info":
-			self.session.open(Info, "SystemInfo")
-		elif menu == "ImageVersion":
-			self.session.open(Info, "ImageVersion")
-		elif menu == "FreeSpace":
-			self.session.open(Info, "FreeSpace")
-		elif menu == "Network":
-			self.session.open(Info, "Network")
-		elif menu == "Mounts":
-			self.session.open(Info, "Mounts")
-		elif menu == "Kernel":
-			self.session.open(Info, "Kernel")
-		elif menu == "Ram":
-			self.session.open(Info, "Free")
-		elif menu == "Cpu":
-			self.session.open(Info, "Cpu")
-		elif menu == "Top":
-			self.session.open(Info, "Top")
-		elif menu == "MemInfo":
-			self.session.open(Info, "MemInfo")
-		elif menu == "Module":
-			self.session.open(Info, "Module")
-		elif menu == "Mtd":
-			self.session.open(Info, "Mtd")
-		elif menu == "Partitions":
-			self.session.open(Info, "Partitions")
-		elif menu == "Swap":
-			self.session.open(Info, "Swap")
-		elif menu == "SystemInfo":
-			self.System()
-		elif menu == "CronManager":
-			self.session.open(CronManager)
-		elif menu == "JobManager":
-			self.session.open(ScriptRunner)
-                elif menu == "SpeedTest":
-			self.session.open(SpeedTestScreen)
-                elif menu == "ResetPass":
-			self.session.open(resetpasScreen)
-		elif menu == "OScamInfo":
-		         from Screens.OScamInfo import OscamInfoMenu
-		         self.session.open(OscamInfoMenu)
-		elif menu == "SoftcamPanel":
-			self.session.open(SoftcamPanel)
-		elif menu == "software-manager":
-			self.Software_Manager()
-		elif menu == "software-update":
-			self.session.open(SoftwarePanel)
-		elif menu == "backup-settings":
-			self.session.openWithCallback(self.backupDone,BackupScreen, runBackup = True)
-		elif menu == "restore-settings":
-			self.backuppath = getBackupPath()
-			self.backupfile = getBackupFilename()
-			self.fullbackupfilename = self.backuppath + "/" + self.backupfile
-			if os_path.exists(self.fullbackupfilename):
-				self.session.openWithCallback(self.startRestore, MessageBox, _("Are you sure you want to restore your STB backup?\nSTB will restart after the restore"), default = False)
-			else:
-				self.session.open(MessageBox, _("Sorry no backups found!"), MessageBox.TYPE_INFO, timeout = 10)
-		elif menu == "backup-files":
-			self.session.open(BackupSelection,title=_("Default files/folders to backup"),configBackupDirs=config.plugins.configurationbackup.backupdirs_default,readOnly=True)
-		elif menu == "backup-files-additional":
-			self.session.open(BackupSelection,title=_("Additional files/folders to backup"),configBackupDirs=config.plugins.configurationbackup.backupdirs,readOnly=False)
-		elif menu == "backup-files-excluded":
-			self.session.open(BackupSelection,title=_("Files/folders to exclude from backup"),configBackupDirs=config.plugins.configurationbackup.backupdirs_exclude,readOnly=False)
-		elif menu == "MultiQuickButton":
-			self.session.open(MultiQuickButton)
-		elif menu == "MountManager":
-			self.session.open(HddMount)
-		elif menu == "SwapManager":
-			self.session.open(Swap)
-		elif menu == "Softcam-Panel Setup":
-			self.session.open(ShowSoftcamPanelExtensions)
-		elif menu == "KeymapSel":
-			self.session.open(KeymapSel)
-		else:
-			pass
-
-	def Plugins(self):
-		#// Create Plugin Menu
-		global menu
-		menu = 1
-		self["label1"].setText(_("Plugins"))
-		self.tlist = []
-		self.oldmlist = []
-		self.oldmlist = self.Mlist
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('MountManager'), _("MountManager"), 'MountManager')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('CronManager'), _("CronManager"), 'CronManager')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('JobManager'), _("JobManager"), 'JobManager')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('SwapManager'), _("SwapManager"), 'SwapManager')))
-                self.tlist.append(MenuEntryItem((InfoEntryComponent('SpeedTest'), _("SpeedTest"), 'SpeedTest')))
-                self.tlist.append(MenuEntryItem((InfoEntryComponent('ResetPass'), _("ResetPass"), 'ResetPass')))
-		if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/MultiQuickButton/plugin.pyo") is True:
-			self.tlist.append(MenuEntryItem((InfoEntryComponent('MultiQuickButton'), _("MultiQuickButton"), 'MultiQuickButton')))
-		self["Mlist"].moveToIndex(0)
-		self["Mlist"].l.setList(self.tlist)
-
-	def Infos(self):
-		#// Create Infos Menu
-		global menu
-		menu = 1
-		self["label1"].setText(_("Infos"))
-		self.tlist = []
-		self.oldmlist = []
-		self.oldmlist1 = []
-		self.oldmlist = self.Mlist
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('OpenPanel'), _("OpenPanel"), 'OpenPanel')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('ImageVersion'), _("Image-Version"), 'ImageVersion')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('FreeSpace'), _("FreeSpace"), 'FreeSpace')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Kernel'), _("Kernel"), 'Kernel')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Mounts'), _("Mounts"), 'Mounts')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Network'), _("Network"), 'Network')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Ram'), _("Ram"), 'Ram')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('SystemInfo'), _("SystemInfo"), 'SystemInfo')))
-		self["Mlist"].moveToIndex(0)
-		self["Mlist"].l.setList(self.tlist)
-		self.oldmlist1 = self.tlist
-
-	def System(self):
-		#// Create System Menu
-		global menu
-		menu = 2
-		self["label1"].setText(_("System Info"))
-		self.tlist = []
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Cpu'), _("Cpu"), 'Cpu')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('MemInfo'), _("MemInfo"), 'MemInfo')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Mtd'), _("Mtd"), 'Mtd')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Module'), _("Module"), 'Module')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Partitions'), _("Partitions"), 'Partitions')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Swap'), _("Swap"), 'Swap')))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Top'), _("Top"), 'Top')))
-		self["Mlist"].moveToIndex(0)
-		self["Mlist"].l.setList(self.tlist)
-
-	def System_main(self):
-		#// Create System Main Menu
-		global menu
-		menu = 1
-		self["label1"].setText(_("System"))
-		self.tlist = []
-		self.oldmlist = []
-		self.oldmlist = self.Mlist
-		self.tlist.append(MenuEntryItem((InfoEntryComponent('Info'), _("Info"), 'Info')))
-		self["Mlist"].moveToIndex(0)
-		self["Mlist"].l.setList(self.tlist)
-
-	def Software_Manager(self):
-		#// Create Software Manager Menu
-		global menu
-		menu = 1
-		self["label1"].setText(_("Software Manager"))
-		self.tlist = []
-		self.oldmlist = []
-		self.oldmlist = self.Mlist
-		self.tlist.append(MenuEntryItem((InfoEntryComponent ("SoftwareManager" ), _("Software update"), ("software-update"))))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent ("BackupSettings" ), _("Backup Settings"), ("backup-settings"))))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent ("RestoreSettings" ), _("Restore Settings"), ("restore-settings"))))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent ("BackupFiles" ), _("Show default backup files"), ("backup-files"))))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent ("BackupFilesAdditional" ), _("Select additional backup files"), ("backup-files-additional"))))
-		self.tlist.append(MenuEntryItem((InfoEntryComponent ("BackupFilesExcluded" ), _("Select excluded backup files"), ("backup-files-excluded"))))
-		self["Mlist"].moveToIndex(0)
-		self["Mlist"].l.setList(self.tlist)
-
-	def backupDone(self,retval = None):
-		if retval is True:
-			self.session.open(MessageBox, _("Backup done."), MessageBox.TYPE_INFO, timeout = 10)
-		else:
-			self.session.open(MessageBox, _("Backup failed."), MessageBox.TYPE_INFO, timeout = 10)
-
-	def startRestore(self, ret = False):
-		if (ret == True):
-			self.exe = True
-			self.session.open(RestoreScreen, runRestore = True)
-
-class KeymapSel(ConfigListScreen, Screen):
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		self.session = session
-		self.skinName = ["SetupInfo", "Setup" ]
-		Screen.setTitle(self, _("Keymap Selection") + "...")
-		self.setup_title =  _("Keymap Selection") + "..."
-		self["HelpWindow"] = Pixmap()
-		self["HelpWindow"].hide()
-		self["status"] = StaticText()
-		self["footnote"] = Label()
-		self["description"] = Label("")
-
-		usrkey = eEnv.resolve("${datadir}/enigma2/keymap.usr")
-		ntrkey = eEnv.resolve("${datadir}/enigma2/keymap.ntr")
-		u80key = eEnv.resolve("${datadir}/enigma2/keymap.u80")
-		self.actkeymap = self.getKeymap(config.usage.keymap.value)
-		keySel = [ ('keymap.xml',_("Default  (keymap.xml)"))]
-		if os.path.isfile(usrkey):
-			keySel.append(('keymap.usr',_("User  (keymap.usr)")))
-		if os.path.isfile(ntrkey):
-			keySel.append(('keymap.ntr',_("Neutrino  (keymap.ntr)")))
-		if os.path.isfile(u80key):
-			keySel.append(('keymap.u80',_("UP80  (keymap.u80)")))
-		if self.actkeymap == usrkey and not os.path.isfile(usrkey):
-			setDefaultKeymap()
-		if self.actkeymap == ntrkey and not os.path.isfile(ntrkey):
-			setDefaultKeymap()
-		if self.actkeymap == u80key and not os.path.isfile(u80key):
-			setDefaultKeymap()
-		self.keyshow = ConfigSelection(keySel)
-		self.keyshow.value = self.actkeymap
-
-		self.onChangedEntry = [ ]
-		self.list = []
-		ConfigListScreen.__init__(self, self.list, session = self.session, on_change = self.changedEntry)
-		self.createSetup()
-
-		self["actions"] = ActionMap(["SetupActions", 'ColorActions'],
-		{
-			"ok": self.keySave,
-			"cancel": self.keyCancel,
-			"red": self.keyCancel,
-			"green": self.keySave,
-			"menu": self.keyCancel,
-		}, -2)
-
-		self["key_red"] = StaticText(_("Cancel"))
-		self["key_green"] = StaticText(_("OK"))
-		if not self.selectionChanged in self["config"].onSelectionChanged:
-			self["config"].onSelectionChanged.append(self.selectionChanged)
-		self.selectionChanged()
-
-	def createSetup(self):
-		self.editListEntry = None
-		self.list = []
-		self.list.append(getConfigListEntry(_("Use Keymap"), self.keyshow))
-		
-		self["config"].list = self.list
-		self["config"].setList(self.list)
-		if config.usage.sort_settings.value:
-			self["config"].list.sort()
-
-	def selectionChanged(self):
-		self["status"].setText(self["config"].getCurrent()[0])
-
-	def changedEntry(self):
-		for x in self.onChangedEntry:
-			x()
-		self.selectionChanged()
-
-	def getCurrentEntry(self):
-		return self["config"].getCurrent()[0]
-
-	def getCurrentValue(self):
-		return str(self["config"].getCurrent()[1].getText())
-
-	def getCurrentDescription(self):
-		return self["config"].getCurrent() and len(self["config"].getCurrent()) > 2 and self["config"].getCurrent()[2] or ""
-
-	def createSummary(self):
-		from Screens.Setup import SetupSummary
-		return SetupSummary
-
-	def saveAll(self):
-		config.usage.keymap.value = eEnv.resolve("${datadir}/enigma2/" + self.keyshow.value)
-		config.usage.keymap.save()
-		configfile.save()
-		if self.actkeymap != self.keyshow.value:
-			self.changedFinished()
-
-	def keySave(self):
-		self.saveAll()
-		self.close()
-
-	def cancelConfirm(self, result):
-		if not result:
-			return
-		for x in self["config"].list:
-			x[1].cancel()
-		self.close()
-
-	def keyCancel(self):
-		if self["config"].isChanged():
-			self.session.openWithCallback(self.cancelConfirm, MessageBox, _("Really close without saving settings?"))
-		else:
-			self.close()
-
-	def getKeymap(self, file):
-		return file[file.rfind('/') +1:]
-
-	def changedFinished(self):
-		self.session.openWithCallback(self.ExecuteRestart, MessageBox, _("Keymap changed, you need to restart the GUI") +"\n"+_("Do you want to restart now?"), MessageBox.TYPE_YESNO)
-		self.close()
-
-	def ExecuteRestart(self, result):
-		if result:
-			quitMainloop(3)
-		else:
-			self.close()
-
-class ShowSoftcamPanelExtensions(ConfigListScreen, Screen):
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		self.session = session
-		self.skinName = "Setup"
-		Screen.setTitle(self, _("Softcam-Panel Setup") + "...")
-		self.setup_title = _("Softcam-Panel Setup") + "..."
-		self["HelpWindow"] = Pixmap()
-		self["HelpWindow"].hide()
-		self["status"] = StaticText()
-		self["footnote"] = Label()
-		self["description"] = Label("")
-		self["labelExitsave"] = Label("[Exit] = " +_("Cancel") +"              [Ok] =" +_("Save"))
-		CamCheckStop()
-
-		self.onChangedEntry = [ ]
-		self.list = []
-		ConfigListScreen.__init__(self, self.list, session = self.session, on_change = self.changedEntry)
-		self.createSetup()
-
-		self["actions"] = ActionMap(["SetupActions", 'ColorActions'],
-		{
-			"ok": self.keySave,
-			"cancel": self.keyCancel,
-			"red": self.keyCancel,
-			"green": self.keySave,
-			"menu": self.keyCancel,
-		}, -2)
-
-		self["key_red"] = StaticText(_("Cancel"))
-		self["key_green"] = StaticText(_("OK"))
-		if not self.selectionChanged in self["config"].onSelectionChanged:
-			self["config"].onSelectionChanged.append(self.selectionChanged)
-		self.selectionChanged()
-
-	def createSetup(self):
-		self.editListEntry = None
-		self.list = []
-		self.list.append(getConfigListEntry(_("Show Softcam-Panel in Extensions Menu"), config.plugins.showopenpanelextensions))
-		self.list.append(getConfigListEntry(_("Start Mode"), config.softcam.camstartMode))
-		if config.softcam.camstartMode.value == "0":
-			self.list.append(getConfigListEntry(_("Start attempts"), config.softcam.restartAttempts))
-			self.list.append(getConfigListEntry(_("Time between start attempts (sec.)"), config.softcam.restartTime))
-			self.list.append(getConfigListEntry(_("Stop check when cam is running"), config.softcam.restartRunning))
-		self.list.append(getConfigListEntry(_("Show CCcamInfo in Extensions Menu"), config.cccaminfo.showInExtensions))
-		self.list.append(getConfigListEntry(_("Show OscamInfo in Extensions Menu"), config.oscaminfo.showInExtensions))
-		self.list.append(getConfigListEntry(_("Frozen Cam Check"), config.plugins.openpanel_frozencheck.list))
-		self.list.append(getConfigListEntry(_("Wait time before start Cam 2"), config.softcam.waittime))
-		
-		self["config"].list = self.list
-		self["config"].setList(self.list)
-		if config.usage.sort_settings.value:
-			self["config"].list.sort()
-
-	def selectionChanged(self):
-		self["status"].setText(self["config"].getCurrent()[0])
-
-	def changedEntry(self):
-		for x in self.onChangedEntry:
-			x()
-		self.selectionChanged()
-		self.createSetup()
-
-	def getCurrentEntry(self):
-		return self["config"].getCurrent()[0]
-
-	def getCurrentValue(self):
-		return str(self["config"].getCurrent()[1].getText())
-
-	def getCurrentDescription(self):
-		return self["config"].getCurrent() and len(self["config"].getCurrent()) > 2 and self["config"].getCurrent()[2] or ""
-
-	def createSummary(self):
-		from Screens.Setup import SetupSummary
-		return SetupSummary
-	
-	def saveAll(self):
-		if config.softcam.camstartMode.value == "0":
-			if os.path.exists("/etc/rc2.d/S20softcam.cam1"):
-				print"Delete Symbolink link"
-				self.container = eConsoleAppContainer()
-				self.container.execute('update-rc.d -f softcam.cam1 defaults')
-			if os.path.exists("/etc/init.d/softcam.cam1"):
-				print"Delete softcam init script cam1"
-				os.system("rm /etc/init.d/softcam.cam1")
-				
-			if os.path.exists("/etc/rc2.d/S20softcam.cam2"):
-				print"Delete Symbolink link"
-				self.container = eConsoleAppContainer()
-				self.container.execute('update-rc.d -f softcam.cam2 defaults')
-			if os.path.exists("/etc/init.d/softcam.cam2"):
-				print"Delete softcam init script cam2"
-				os.system("rm /etc/init.d/softcam.cam2")
-			
-		for x in self["config"].list:
-			x[1].save()
-		configfile.save()
-
-	def keySave(self):
-		self.saveAll()
-		self.doClose()
-
-	def cancelConfirm(self, result):
-		if not result:
-			return
-		for x in self["config"].list:
-			x[1].cancel()
-		self.doClose()
-
-	def keyCancel(self):
-		if self["config"].isChanged():
-			self.session.openWithCallback(self.cancelConfirm, MessageBox, _("Really close without saving settings?"))
-		else:
-			self.doClose()
-
-	def doClose(self):
-		if not config.plugins.openpanel_frozencheck.list.value == '0':
-			CamCheck()
-		self.close()
-
-class Info(Screen):
-	def __init__(self, session, info):
-		self.service = None
-		Screen.__init__(self, session)
-
-		self.skin = INFO_SKIN
-
-		self["label2"] = Label("INFO")
-		self["label1"] =  ScrollLabel()
-		if info == "OpenPanel":
-			self.OpenPanel()
-		if info == "SystemInfo":
-			self.SystemInfo()
-		elif info == "ImageVersion":
-			self.ImageVersion()
-		elif info == "FreeSpace":
-			self.FreeSpace()
-		elif info == "Mounts":
-			self.Mounts()
-		elif info == "Network":
-			self.Network()
-		elif info == "Kernel":
-			self.Kernel()
-		elif info == "Free":
-			self.Free()
-		elif info == "Cpu":
-			self.Cpu()
-		elif info == "Top":
-			self.Top()
-		elif info == "MemInfo":
-			self.MemInfo()
-		elif info == "Module":
-			self.Module()
-		elif info == "Mtd":
-			self.Mtd()
-		elif info == "Partitions":
-			self.Partitions()
-		elif info == "Swap":
-			self.Swap()
-
-		self["actions"] = ActionMap(["OkCancelActions", "DirectionActions"],
-		{
-			"cancel": self.Exit,
-			"ok": self.ok,
-			"up": self.Up,
-			"down": self.Down,
-		}, -1)
-
-	def Exit(self):
-		self.close()
-
-	def ok(self):
-		self.close()
-
-	def Down(self):
-		self["label1"].pageDown()
-
-	def Up(self):
-		self["label1"].pageUp()
-
-	def OpenPanel(self):
-		try:
-			self["label2"].setText("INFO")
-			info1 = self.Do_cmd("cat", "/etc/motd", None)
-			if info1.find('wElc0me') > -1:
-				info1 = info1[info1.find('wElc0me'):len(info1)] + "\n"
-				info1 = info1.replace('|','')
-			else:
-				info1 = info1[info1.find('INFO'):len(info1)] + "\n"
-			info2 = self.Do_cmd("cat", "/etc/image-version", None)
-			info3 = self.Do_cut(info1 + info2)
-			self["label1"].setText(info3)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def SystemInfo(self):
-		try:
-			self["label2"].setText(_("Image Info"))
-			info1 = self.Do_cmd("cat", "/etc/version", None)
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def ImageVersion(self):
-		try:
-			self["label2"].setText(_("Image Version"))
-			now = datetime.now()
-			info1 = 'Date = ' + now.strftime("%d-%B-%Y") + "\n"
-			info2 = 'Time = ' + now.strftime("%H:%M:%S") + "\n"
-			info3 = self.Do_cmd("uptime", None, None)
-			tmp = info3.split(",")
-			info3 = 'Uptime = ' + tmp[0].lstrip() + "\n"
-			info4 = self.Do_cmd("cat", "/etc/image-version", " | head -n 1")
-			info4 = info4[9:]
-			info4 = 'Imagetype = ' + info4 + "\n"
-			info5 = 'Load = ' + self.Do_cmd("cat", "/proc/loadavg", None)
-			info6 = self.Do_cut(info1 + info2 + info3 + info4 + info5)
-			self["label1"].setText(info6)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def FreeSpace(self):
-		try:
-			self["label2"].setText(_("FreeSpace"))
-			info1 = self.Do_cmd("df", None, "-h")
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Mounts(self):
-		try:
-			self["label2"].setText(_("Mounts"))
-			info1 = self.Do_cmd("mount", None, None)
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Network(self):
-		try:
-			self["label2"].setText(_("Network"))
-			info1 = self.Do_cmd("ifconfig", None, None) + '\n'
-			info2 = self.Do_cmd("route", None, "-n")
-			info3 = self.Do_cut(info1 + info2)
-			self["label1"].setText(info3)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Kernel(self):
-		try:
-			self["label2"].setText(_("Kernel"))
-			info0 = self.Do_cmd("cat", "/proc/version", None)
-			info = info0.split('(')
-			info1 = "Name = " + info[0] + "\n"
-			info2 =  "Owner = " + info[1].replace(')','') + "\n"
-			info3 =  "Mainimage = " + info[2][0:info[2].find(')')] + "\n"
-			info4 = "Date = " + info[3][info[3].find('SMP')+4:len(info[3])]
-			info5 = self.Do_cut(info1 + info2 + info3 + info4)
-			self["label1"].setText(info5)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Free(self):
-		try:
-			self["label2"].setText(_("Ram"))
-			info1 = self.Do_cmd("free", None, None)
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Cpu(self):
-		try:
-			self["label2"].setText(_("Cpu"))
-			info1 = self.Do_cmd("cat", "/proc/cpuinfo", None, " | sed 's/\t\t/\t/'")
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Top(self):
-		try:
-			self["label2"].setText(_("Top"))
-			info1 = self.Do_cmd("top", None, "-b -n1")
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def MemInfo(self):
-		try:
-			self["label2"].setText(_("MemInfo"))
-			info1 = self.Do_cmd("cat", "/proc/meminfo", None)
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Module(self):
-		try:
-			self["label2"].setText(_("Module"))
-			info1 = self.Do_cmd("cat", "/proc/modules", None)
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Mtd(self):
-		try:
-			self["label2"].setText(_("Mtd"))
-			info1 = self.Do_cmd("cat", "/proc/mtd", None)
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Partitions(self):
-		try:
-			self["label2"].setText(_("Partitions"))
-			info1 = self.Do_cmd("cat", "/proc/partitions", None)
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-	def Swap(self):
-		try:
-			self["label2"].setText(_("Swap"))
-			info0 = self.Do_cmd("cat", "/proc/swaps", None, " | sed 's/\t/ /g; s/[ ]* / /g'")
-			info0 = info0.split("\n");
-			info1 = ""
-			for l in info0[1:]:
-				l1 = l.split(" ")
-				info1 = info1 + "Name: " + l1[0] + '\n'
-				info1 = info1 + "Type: " + l1[1] + '\n'
-				info1 = info1 + "Size: " + l1[2] + '\n'
-				info1 = info1 + "Used: " + l1[3] + '\n'
-				info1 = info1 + "Prio: " + l1[4] + '\n\n'
-			if info1[-1:] == '\n': info1 = info1[:-1]
-			if info1[-1:] == '\n': info1 = info1[:-1]
-			info1 = self.Do_cut(info1)
-			self["label1"].setText(info1)
-		except:
-			self["label1"].setText(_("an internal error has occur"))
-
-
-	def Do_find(self, text, search):
-		text = text + ' '
-		ret = ""
-		pos = text.find(search)
-		pos1 = text.find(" ", pos)
-		if pos > -1:
-			ret = text[pos + len(search):pos1]
-		return ret
-
-	def Do_cut(self, text):
-		text1 = text.split("\n")
-		text = ""
-		for line in text1:
-			text = text + line[:95] + "\n"
-		if text[-1:] == '\n': text = text[:-1]
-		return text
-
-	def Do_cmd(self, cmd , file, arg , pipe = ""):
-		try:
-			if file != None:
-				if os.path.exists(file) is True:
-					o = command(cmd + ' ' + file + pipe, 0)
-				else:
-					o = "File not found: \n" + file
-			else:
-				if arg == None:
-					o = command(cmd, 0)
-				else:
-					o = command(cmd + ' ' + arg, 0)
-			return o
-		except:
-			o = ''
-			return o
-
-#// show Openpanel in EXTENSIONS plugins	
-#def Plugins(**kwargs):
-#	screenwidth = getDesktop(0).size().width()
-#	if screenwidth and screenwidth == 1920:
-#		return [PluginDescriptor(name=_("OpenPanel"), description=_("OpenPanel GUI"), where = PluginDescriptor.WHERE_PLUGINMENU, icon="openhd.png", fnc=main)]
-##	else:
-#		return [PluginDescriptor(name=_("OpenPanel"), description=_("OpenPanel GUI"), where = PluginDescriptor.WHERE_PLUGINMENU, icon="open.png", fnc=main)]
-
diff --git a/lib/python/Plugins/Extensions/Openpanel/resetpas.py b/lib/python/Plugins/Extensions/Openpanel/resetpas.py
deleted file mode 100644
index 6fded5d..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/resetpas.py
+++ /dev/null
@@ -1,87 +0,0 @@
-import sys
-import os
-from Components.ActionMap import ActionMap
-from Components.Pixmap import Pixmap
-from Components.ConfigList import ConfigListScreen
-from Components.Label import Label
-from datetime import datetime
-from time import strftime
-from Screens.Screen import Screen
-from Screens.MessageBox import MessageBox
-from enigma import getDesktop
-
-class resetpasScreen(Screen, ConfigListScreen):
-    screenWidth = getDesktop(0).size().width()
-    if screenWidth and screenWidth == 1920:
-            skin = """<screen name="resetpasScreen" position="center,center" size="1920,1080" backgroundColor="transparent" flags="wfNoBorder">
-  <ePixmap pixmap="Openpanel/icons/fpassword.png" position="363,447" size="250,250" alphatest="blend" zPosition="-11" />
-  <widget name="data" position="645,318" zPosition="4" size="890,501" font="Regular; 22" foregroundColor="white" transparent="1" halign="left" valign="top" backgroundColor="background" />
-  <widget source="Title" transparent="1" render="Label" zPosition="2" valign="center" halign="left" position="365,235" size="1125,50" font="Regular; 32" backgroundColor="background" foregroundColor="white" noWrap="1" />
-  <eLabel position="center,center" size="1288,808" transparent="0" zPosition="-15" backgroundColor="background" />
-  <eLabel position="640,312" size="901,514" transparent="0" foregroundColor="white" backgroundColor="black" zPosition="-10" />
-  <eLabel position="887,847" size="36,36" transparent="0" foregroundColor="white" backgroundColor="green" zPosition="1" />
-  <eLabel position="647,847" size="36,36" transparent="0" foregroundColor="white" backgroundColor="red" zPosition="1" />
-  <widget name="key_red" render="Label" position="689,847" size="195,35" zPosition="1" font="Regular; 25" backgroundColor="background" transparent="1" foregroundColor="white" />
-  <widget name="key_green" render="Label" position="929,847" size="195,35" zPosition="1" font="Regular; 25" backgroundColor="background" transparent="1" foregroundColor="white" />
-</screen>"""
-    else:
-            skin = """<screen name="resetpasScreen" position="center,center" size="1280,720" backgroundColor="transparent" flags="wfNoBorder">
-  <ePixmap alphatest="blend" pixmap="Openpanel/icons/setup1.png" position="920,230" size="256,256" transparent="1" zPosition="2" />
-  <widget name="data" position="70,108" zPosition="4" size="800,415" font="Regular; 20" foregroundColor="white" transparent="1" halign="left" valign="top" backgroundColor="black" />
-  <eLabel position="341,620" size="36,36" transparent="0" backgroundColor="green" zPosition="1" />
-  <eLabel position="67,620" size="36,36" transparent="0" backgroundColor="red" zPosition="1" />
-  <widget name="key_red" render="Label" position="109,620" size="195,35" zPosition="1" font="Regular; 25" transparent="1" />
-  <widget name="key_green" render="Label" position="383,620" size="195,35" zPosition="1" font="Regular; 25" transparent="1" />
-  <eLabel backgroundColor="background" position="40,25" size="1205,650" zPosition="-10" />
-  <widget source="Title" transparent="1" render="Label" font="Regular; 28" zPosition="2" valign="center" halign="left" position="70,47" size="800,43" noWrap="1" />
-</screen>"""
-                
-    def __init__(self, session):
-        Screen.__init__(self, session)
-        self['data'] = Label(_('To reset your password, press green button and please wait... or Exit'))
-        self["key_red"] = Label(_("Exit"))
-        self["key_green"] = Label(_("Reset"))
-        self.setTitle(_("OpenPlus Reset Pass"))
-        self['actions'] = ActionMap(['OkCancelActions','ColorActions'],{'cancel': self.exit, 'red': self.exit, 'green': self.reset,})
-        
-    def reset(self):
-        numeros = datetime.now().strftime('%Y%m%d%H%M%S%f')
-        otro = open('/var/volatile/tmp/systemop'+str(numeros),'w+')
-        otro.write ( "reset_root_passwd ")
-        otro.close()
-        self.session.open(MessageBox, _("Password was reset to blank"), MessageBox.TYPE_INFO, timeout=4)
-    
-    def exit(self):
-        self.close()
-    
-    def skintrad(self):
-        self['data1'] = Label(_('PHOTO'))
-        self['data2'] = Label(_('YouTube search'))
-        self['data3'] = Label(_('MY MOVIE'))
-        self['data4'] = Label(_(' Translation Plugins:'))
-        self['data5'] = Label(_(' Translation of Enigma:'))
-        self['data6'] = Label(_('CHOOSE THE CHANNEL TO RECORD , AND THEN PRESS BLUE BUTTON'))
-        self['data7'] = Label(_('                                      RECORD PROGRAM'))
-        self['data8'] = Label(_('       +MORE INFO '))
-        self['data9'] = Label(_('MUSIC'))
-        self['data11'] = Label(_('CHANNELS'))
-        self['data12'] = Label(_('LIST'))
-        self['data13'] = Label(_('MULTIGUID'))
-        self['data14'] = Label(_('GUIDE'))
-        self['data15'] = Label(_('DESCRIPTION'))
-        self['data16'] = Label(_('PROGRAMS TV'))
-        self['data17'] = Label(_('SEARCH'))
-        self['data18'] = Label(_('CLICK      TO RECORD SELECTED PROGRAM'))
-        self['data19'] = Label(_("You're watching..."))
-        self['data20'] = Label(_('Program Duration:'))
-        self['data21'] = Label(_('Playback Time:'))
-        self['data22'] = Label(_('SYS-Temp: %s'))
-        self['data23'] = Label(_('CPU-Speed: %s MHz'))
-        self['data24'] = Label(_('CPU-Temp: %s'))
-        self['data25'] = Label(_('CPU-Load: %s'))
-        self['data26'] = Label(_('Flash Memory free: %s MByte'))
-        self['data27'] = Label(_('Active video downloads'))
-        self['data28'] = Label(_('First configure IP and port of the server and click save... Then Press the yellow button to configure channel list and sent to another receiver in your network. Press blue button to download the list m3u media/hdd.'))
-        self['data29'] = Label(_('First configure Ip user and password of your receiver client and then press the green button to send channel list to another receiver of your network.'))
-        self['data30'] = Label(_('Building server and clients in the background... \nOnce finished, you will see a message on the screen, and the configurations will already be created. \n\nYou can transfer the settings from: \netc/openvpn/client1-android \netc/openvpn/client2-ipad \netc/openvpn/client3-pc_lin \n\nYou should now configure your IP range in the server.conf eg: push route 192.168.1.0 255.255.255.0 in /etc/openvpn. Then on each generated client.ovpn remember to put the public ip or Dyndns where the server is hosted and the port if you want to change it, (remember to open it on the router for the IP of the server) eg: remote my.dyndns.org 1194. \n\nNote: Be sure to restart the OpenVPN Server after you make the changes. And to automatically start OpenVPN, choose the option in the OpenPlus graphical user interface!'))
-        
\ No newline at end of file
diff --git a/lib/python/Plugins/Extensions/Openpanel/speedtesting.py b/lib/python/Plugins/Extensions/Openpanel/speedtesting.py
deleted file mode 100644
index d201885..0000000
--- a/lib/python/Plugins/Extensions/Openpanel/speedtesting.py
+++ /dev/null
@@ -1,800 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-# Copyright 2012-2015 Matt Martz
-# All Rights Reserved.
-#
-#    Licensed under the Apache License, Version 2.0 (the "License"); you may
-#    not use this file except in compliance with the License. You may obtain
-#    a copy of the License at
-#
-#         http://www.apache.org/licenses/LICENSE-2.0
-#
-#    Unless required by applicable law or agreed to in writing, software
-#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
-#    License for the specific language governing permissions and limitations
-#    under the License.
-
-import os
-import re
-import sys
-import math
-import signal
-import socket
-import timeit
-import platform
-import threading
-
-
-__version__ = '0.3.4'
-
-# Some global variables we use
-user_agent = None
-source = None
-shutdown_event = None
-scheme = 'http'
-
-
-# Used for bound_interface
-socket_socket = socket.socket
-
-try:
-    import xml.etree.cElementTree as ET
-except ImportError:
-    try:
-        import xml.etree.ElementTree as ET
-    except ImportError:
-        from xml.dom import minidom as DOM
-        ET = None
-
-# Begin import game to handle Python 2 and Python 3
-try:
-    from urllib2 import urlopen, Request, HTTPError, URLError
-except ImportError:
-    from urllib.request import urlopen, Request, HTTPError, URLError
-
-try:
-    from httplib import HTTPConnection, HTTPSConnection
-except ImportError:
-    e_http_py2 = sys.exc_info()
-    try:
-        from http.client import HTTPConnection, HTTPSConnection
-    except ImportError:
-        e_http_py3 = sys.exc_info()
-        raise SystemExit('Your python installation is missing required HTTP '
-                         'client classes:\n\n'
-                         'Python 2: %s\n'
-                         'Python 3: %s' % (e_http_py2[1], e_http_py3[1]))
-
-try:
-    from Queue import Queue
-except ImportError:
-    from queue import Queue
-
-try:
-    from urlparse import urlparse
-except ImportError:
-    from urllib.parse import urlparse
-
-try:
-    from urlparse import parse_qs
-except ImportError:
-    try:
-        from urllib.parse import parse_qs
-    except ImportError:
-        from cgi import parse_qs
-
-try:
-    from hashlib import md5
-except ImportError:
-    from md5 import md5
-
-try:
-    from argparse import ArgumentParser as ArgParser
-except ImportError:
-    from optparse import OptionParser as ArgParser
-
-try:
-    import builtins
-except ImportError:
-    def print_(*args, **kwargs):
-        """The new-style print function taken from
-        https://pypi.python.org/pypi/six/
-
-        """
-        fp = kwargs.pop("file", sys.stdout)
-        if fp is None:
-            return
-
-        def write(data):
-            if not isinstance(data, basestring):
-                data = str(data)
-            fp.write(data)
-
-        want_unicode = False
-        sep = kwargs.pop("sep", None)
-        if sep is not None:
-            if isinstance(sep, unicode):
-                want_unicode = True
-            elif not isinstance(sep, str):
-                raise TypeError("sep must be None or a string")
-        end = kwargs.pop("end", None)
-        if end is not None:
-            if isinstance(end, unicode):
-                want_unicode = True
-            elif not isinstance(end, str):
-                raise TypeError("end must be None or a string")
-        if kwargs:
-            raise TypeError("invalid keyword arguments to print()")
-        if not want_unicode:
-            for arg in args:
-                if isinstance(arg, unicode):
-                    want_unicode = True
-                    break
-        if want_unicode:
-            newline = unicode("\n")
-            space = unicode(" ")
-        else:
-            newline = "\n"
-            space = " "
-        if sep is None:
-            sep = space
-        if end is None:
-            end = newline
-        for i, arg in enumerate(args):
-            if i:
-                write(sep)
-            write(arg)
-        write(end)
-else:
-    print_ = getattr(builtins, 'print')
-    del builtins
-
-
-class SpeedtestCliServerListError(Exception):
-    """Internal Exception class used to indicate to move on to the next
-    URL for retrieving speedtest.net server details
-
-    """
-
-
-def bound_socket(*args, **kwargs):
-    """Bind socket to a specified source IP address"""
-
-    global source
-    sock = socket_socket(*args, **kwargs)
-    sock.bind((source, 0))
-    return sock
-
-
-def distance(origin, destination):
-    """Determine distance between 2 sets of [lat,lon] in km"""
-
-    lat1, lon1 = origin
-    lat2, lon2 = destination
-    radius = 6371  # km
-
-    dlat = math.radians(lat2 - lat1)
-    dlon = math.radians(lon2 - lon1)
-    a = (math.sin(dlat / 2) * math.sin(dlat / 2) +
-         math.cos(math.radians(lat1)) *
-         math.cos(math.radians(lat2)) * math.sin(dlon / 2) *
-         math.sin(dlon / 2))
-    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
-    d = radius * c
-
-    return d
-
-
-def build_user_agent():
-    """Build a Mozilla/5.0 compatible User-Agent string"""
-
-    global user_agent
-    if user_agent:
-        return user_agent
-
-    ua_tuple = (
-        'Mozilla/5.0',
-        '(%s; U; %s; en-us)' % (platform.system(), platform.architecture()[0]),
-        'Python/%s' % platform.python_version(),
-        '(KHTML, like Gecko)',
-        'speedtest-cli/%s' % __version__
-    )
-    user_agent = ' '.join(ua_tuple)
-    return user_agent
-
-
-def build_request(url, data=None, headers={}):
-    """Build a urllib2 request object
-
-    This function automatically adds a User-Agent header to all requests
-
-    """
-
-    if url[0] == ':':
-        schemed_url = '%s%s' % (scheme, url)
-    else:
-        schemed_url = url
-
-    headers['User-Agent'] = user_agent
-    return Request(schemed_url, data=data, headers=headers)
-
-
-def catch_request(request):
-    """Helper function to catch common exceptions encountered when
-    establishing a connection with a HTTP/HTTPS request
-
-    """
-
-    try:
-        uh = urlopen(request)
-        return uh, False
-    except (HTTPError, URLError, socket.error):
-        e = sys.exc_info()[1]
-        return None, e
-
-
-class FileGetter(threading.Thread):
-    """Thread class for retrieving a URL"""
-
-    def __init__(self, url, start):
-        self.url = url
-        self.result = None
-        self.starttime = start
-        threading.Thread.__init__(self)
-
-    def run(self):
-        self.result = [0]
-        try:
-            if (timeit.default_timer() - self.starttime) <= 10:
-                request = build_request(self.url)
-                f = urlopen(request)
-                while 1 and not shutdown_event.isSet():
-                    self.result.append(len(f.read(10240)))
-                    if self.result[-1] == 0:
-                        break
-                f.close()
-        except IOError:
-            pass
-
-
-def downloadSpeed(files, quiet=False):
-    """Function to launch FileGetter threads and calculate download speeds"""
-
-    start = timeit.default_timer()
-
-    def producer(q, files):
-        for file in files:
-            thread = FileGetter(file, start)
-            thread.start()
-            q.put(thread, True)
-            if not quiet and not shutdown_event.isSet():
-                sys.stdout.write('.')
-                sys.stdout.flush()
-
-    finished = []
-
-    def consumer(q, total_files):
-        while len(finished) < total_files:
-            thread = q.get(True)
-            while thread.isAlive():
-                thread.join(timeout=0.1)
-            finished.append(sum(thread.result))
-            del thread
-
-    q = Queue(6)
-    prod_thread = threading.Thread(target=producer, args=(q, files))
-    cons_thread = threading.Thread(target=consumer, args=(q, len(files)))
-    start = timeit.default_timer()
-    prod_thread.start()
-    cons_thread.start()
-    while prod_thread.isAlive():
-        prod_thread.join(timeout=0.1)
-    while cons_thread.isAlive():
-        cons_thread.join(timeout=0.1)
-    return (sum(finished) / (timeit.default_timer() - start))
-
-
-class FilePutter(threading.Thread):
-    """Thread class for putting a URL"""
-
-    def __init__(self, url, start, size):
-        self.url = url
-        chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-        data = chars * (int(round(int(size) / 36.0)))
-        self.data = ('content1=%s' % data[0:int(size) - 9]).encode()
-        del data
-        self.result = None
-        self.starttime = start
-        threading.Thread.__init__(self)
-
-    def run(self):
-        try:
-            if ((timeit.default_timer() - self.starttime) <= 10 and
-                    not shutdown_event.isSet()):
-                request = build_request(self.url, data=self.data)
-                f = urlopen(request)
-                f.read(11)
-                f.close()
-                self.result = len(self.data)
-            else:
-                self.result = 0
-        except IOError:
-            self.result = 0
-
-
-def uploadSpeed(url, sizes, quiet=False):
-    """Function to launch FilePutter threads and calculate upload speeds"""
-
-    start = timeit.default_timer()
-
-    def producer(q, sizes):
-        for size in sizes:
-            thread = FilePutter(url, start, size)
-            thread.start()
-            q.put(thread, True)
-            if not quiet and not shutdown_event.isSet():
-                sys.stdout.write('.')
-                sys.stdout.flush()
-
-    finished = []
-
-    def consumer(q, total_sizes):
-        while len(finished) < total_sizes:
-            thread = q.get(True)
-            while thread.isAlive():
-                thread.join(timeout=0.1)
-            finished.append(thread.result)
-            del thread
-
-    q = Queue(6)
-    prod_thread = threading.Thread(target=producer, args=(q, sizes))
-    cons_thread = threading.Thread(target=consumer, args=(q, len(sizes)))
-    start = timeit.default_timer()
-    prod_thread.start()
-    cons_thread.start()
-    while prod_thread.isAlive():
-        prod_thread.join(timeout=0.1)
-    while cons_thread.isAlive():
-        cons_thread.join(timeout=0.1)
-    return (sum(finished) / (timeit.default_timer() - start))
-
-
-def getAttributesByTagName(dom, tagName):
-    """Retrieve an attribute from an XML document and return it in a
-    consistent format
-
-    Only used with xml.dom.minidom, which is likely only to be used
-    with python versions older than 2.5
-    """
-    elem = dom.getElementsByTagName(tagName)[0]
-    return dict(list(elem.attributes.items()))
-
-
-def getConfig():
-    """Download the speedtest.net configuration and return only the data
-    we are interested in
-    """
-
-    request = build_request('://www.speedtest.net/speedtest-config.php')
-    uh, e = catch_request(request)
-    if e:
-        _('Could not retrieve speedtest.net configuration: %s' % e)
-        sys.exit(1)
-    configxml = []
-    while 1:
-        configxml.append(uh.read(10240))
-        if len(configxml[-1]) == 0:
-            break
-    if int(uh.code) != 200:
-        return None
-    uh.close()
-    try:
-        try:
-            root = ET.fromstring(''.encode().join(configxml))
-            config = {
-                'client': root.find('client').attrib,
-                'times': root.find('times').attrib,
-                'download': root.find('download').attrib,
-                'upload': root.find('upload').attrib}
-        except AttributeError:  # Python3 branch
-            root = DOM.parseString(''.join(configxml))
-            config = {
-                'client': getAttributesByTagName(root, 'client'),
-                'times': getAttributesByTagName(root, 'times'),
-                'download': getAttributesByTagName(root, 'download'),
-                'upload': getAttributesByTagName(root, 'upload')}
-    except SyntaxError:
-        print_('Failed to parse speedtest.net configuration')
-        sys.exit(1)
-    del root
-    del configxml
-    return config
-
-
-def closestServers(client, all=False):
-    """Determine the 5 closest speedtest.net servers based on geographic
-    distance
-    """
-
-    urls = [
-        '://www.speedtest.net/speedtest-servers-static.php',
-        '://c.speedtest.net/speedtest-servers-static.php',
-        '://www.speedtest.net/speedtest-servers.php',
-        '://c.speedtest.net/speedtest-servers.php',
-    ]
-    errors = []
-    servers = {}
-    for url in urls:
-        try:
-            request = build_request(url)
-            uh, e = catch_request(request)
-            if e:
-                errors.append('%s' % e)
-                raise SpeedtestCliServerListError
-            serversxml = []
-            while 1:
-                serversxml.append(uh.read(10240))
-                if len(serversxml[-1]) == 0:
-                    break
-            if int(uh.code) != 200:
-                uh.close()
-                raise SpeedtestCliServerListError
-            uh.close()
-            try:
-                try:
-                    root = ET.fromstring(''.encode().join(serversxml))
-                    elements = root.getiterator('server')
-                except AttributeError:  # Python3 branch
-                    root = DOM.parseString(''.join(serversxml))
-                    elements = root.getElementsByTagName('server')
-            except SyntaxError:
-                raise SpeedtestCliServerListError
-            for server in elements:
-                try:
-                    attrib = server.attrib
-                except AttributeError:
-                    attrib = dict(list(server.attributes.items()))
-                d = distance([float(client['lat']),
-                              float(client['lon'])],
-                             [float(attrib.get('lat')),
-                              float(attrib.get('lon'))])
-                attrib['d'] = d
-                if d not in servers:
-                    servers[d] = [attrib]
-                else:
-                    servers[d].append(attrib)
-            del root
-            del serversxml
-            del elements
-        except SpeedtestCliServerListError:
-            continue
-
-        # We were able to fetch and parse the list of speedtest.net servers
-        if servers:
-            break
-
-    if not servers:
-        print_('Failed to retrieve list of speedtest.net servers:\n\n %s' %
-               '\n'.join(errors))
-        sys.exit(1)
-
-    closest = []
-    for d in sorted(servers.keys()):
-        for s in servers[d]:
-            closest.append(s)
-            if len(closest) == 5 and not all:
-                break
-        else:
-            continue
-        break
-
-    del servers
-    return closest
-
-
-def getBestServer(servers):
-    """Perform a speedtest.net latency request to determine which
-    speedtest.net server has the lowest latency
-    """
-
-    results = {}
-    for server in servers:
-        cum = []
-        url = '%s/latency.txt' % os.path.dirname(server['url'])
-        urlparts = urlparse(url)
-        for i in range(0, 3):
-            try:
-                if urlparts[0] == 'https':
-                    h = HTTPSConnection(urlparts[1])
-                else:
-                    h = HTTPConnection(urlparts[1])
-                headers = {'User-Agent': user_agent}
-                start = timeit.default_timer()
-                h.request("GET", urlparts[2], headers=headers)
-                r = h.getresponse()
-                total = (timeit.default_timer() - start)
-            except (HTTPError, URLError, socket.error):
-                cum.append(3600)
-                continue
-            text = r.read(9)
-            if int(r.status) == 200 and text == 'test=test'.encode():
-                cum.append(total)
-            else:
-                cum.append(3600)
-            h.close()
-        avg = round((sum(cum) / 6) * 1000, 3)
-        results[avg] = server
-    fastest = sorted(results.keys())[0]
-    best = results[fastest]
-    best['latency'] = fastest
-
-    return best
-
-
-def ctrl_c(signum, frame):
-    """Catch Ctrl-C key sequence and set a shutdown_event for our threaded
-    operations
-    """
-
-    global shutdown_event
-    shutdown_event.set()
-    raise SystemExit('\nCancelling...')
-
-
-def version():
-    """Print the version"""
-
-    raise SystemExit(__version__)
-
-
-def speedtest():
-    """Run the full speedtest.net test"""
-
-    global shutdown_event, source, scheme
-    shutdown_event = threading.Event()
-
-    signal.signal(signal.SIGINT, ctrl_c)
-
-    description = (
-        'Command line interface for testing internet bandwidth using '
-        'speedtest.net.\n'
-        '------------------------------------------------------------'
-        '--------------\n'
-        'https://github.com/sivel/speedtest-cli')
-
-    parser = ArgParser(description=description)
-    # Give optparse.OptionParser an `add_argument` method for
-    # compatibility with argparse.ArgumentParser
-    try:
-        parser.add_argument = parser.add_option
-    except AttributeError:
-        pass
-    parser.add_argument('--bytes', dest='units', action='store_const',
-                        const=('byte', 1), default=('bit', 8),
-                        help='Display values in bytes instead of bits. Does '
-                             'not affect the image generated by --share')
-    parser.add_argument('--share', action='store_true',
-                        help='Generate and provide a URL to the speedtest.net '
-                             'share results image')
-    parser.add_argument('--simple', action='store_true',
-                        help='Suppress verbose output, only show basic '
-                             'information')
-    parser.add_argument('--list', action='store_true',
-                        help='Display a list of speedtest.net servers '
-                             'sorted by distance')
-    parser.add_argument('--server', help='Specify a server ID to test against')
-    parser.add_argument('--mini', help='URL of the Speedtest Mini server')
-    parser.add_argument('--source', help='Source IP address to bind to')
-    parser.add_argument('--timeout', default=10, type=int,
-                        help='HTTP timeout in seconds. Default 10')
-    parser.add_argument('--secure', action='store_true',
-                        help='Use HTTPS instead of HTTP when communicating '
-                             'with speedtest.net operated servers')
-    parser.add_argument('--version', action='store_true',
-                        help='Show the version number and exit')
-
-    options = parser.parse_args()
-    if isinstance(options, tuple):
-        args = options[0]
-    else:
-        args = options
-    del options
-
-    # Print the version and exit
-    if args.version:
-        version()
-
-    socket.setdefaulttimeout(args.timeout)
-
-    # Pre-cache the user agent string
-    build_user_agent()
-
-    # If specified bind to a specific IP address
-    if args.source:
-        source = args.source
-        socket.socket = bound_socket
-
-    if args.secure:
-        scheme = 'https'
-
-    if not args.simple:
-        print_('Leyendo la configuracin de speedtest.net ...')
-    try:
-        config = getConfig()
-    except URLError:
-        print_('Cannot retrieve speedtest configuration')
-        sys.exit(1)
-
-    if not args.simple:
-        print_('Leyendo la lista de servidores speedtest.net...')
-    if args.list or args.server:
-        servers = closestServers(config['client'], True)
-        if args.list:
-            serverList = []
-            for server in servers:
-                line = ('%(id)4s) %(sponsor)s (%(name)s, %(country)s) '
-                        '[%(d)0.2f km]' % server)
-                serverList.append(line)
-            print_('\n'.join(serverList).encode('utf-8', 'ignore'))
-            sys.exit(0)
-    else:
-        servers = closestServers(config['client'])
-
-    if not args.simple:
-        print_('Test desde %(isp)s (%(ip)s)...' % config['client'])
-
-    if args.server:
-        try:
-            best = getBestServer(filter(lambda x: x['id'] == args.server,
-                                        servers))
-        except IndexError:
-            print_('Invalid server ID')
-            sys.exit(1)
-    elif args.mini:
-        name, ext = os.path.splitext(args.mini)
-        if ext:
-            url = os.path.dirname(args.mini)
-        else:
-            url = args.mini
-        urlparts = urlparse(url)
-        try:
-            request = build_request(args.mini)
-            f = urlopen(request)
-        except:
-            print_('Invalid Speedtest Mini URL')
-            sys.exit(1)
-        else:
-            text = f.read()
-            f.close()
-        extension = re.findall('upload_extension: "([^"]+)"', text.decode())
-        if not extension:
-            for ext in ['php', 'asp', 'aspx', 'jsp']:
-                try:
-                    request = build_request('%s/speedtest/upload.%s' %
-                                            (args.mini, ext))
-                    f = urlopen(request)
-                except:
-                    pass
-                else:
-                    data = f.read().strip()
-                    if (f.code == 200 and
-                            len(data.splitlines()) == 1 and
-                            re.match('size=[0-9]', data)):
-                        extension = [ext]
-                        break
-        if not urlparts or not extension:
-            print_('Please provide the full URL of your Speedtest Mini server')
-            sys.exit(1)
-        servers = [{
-            'sponsor': 'Speedtest Mini',
-            'name': urlparts[1],
-            'd': 0,
-            'url': '%s/speedtest/upload.%s' % (url.rstrip('/'), extension[0]),
-            'latency': 0,
-            'id': 0
-        }]
-        try:
-            best = getBestServer(servers)
-        except:
-            best = servers[0]
-    else:
-        if not args.simple:
-            print_('Seleccionando Servidor en funcion a la latencia...')
-        best = getBestServer(servers)
-
-    if not args.simple:
-        print_(('Alojado por %(sponsor)s (%(name)s) [%(d)0.2f km]: '
-               '%(latency)s ms' % best).encode('utf-8', 'ignore'))
-        print_('Ping: %(latency)s ms' % best)
-    else:
-        print_('Ping: %(latency)s ms' % best)
-
-    sizes = [350, 500, 750, 1000, 1500, 2000, 2500, 3000, 3500, 4000]
-    urls = []
-    for size in sizes:
-        for i in range(0, 4):
-            urls.append('%s/random%sx%s.jpg' %
-                        (os.path.dirname(best['url']), size, size))
-    if not args.simple:
-        print_('Realizando Test de descarga', end='')
-    dlspeed = downloadSpeed(urls, args.simple)
-    if not args.simple:
-        print_()
-    print_('Descarga: %0.2f M%s/s' %
-           ((dlspeed / 1000 / 1000) * args.units[1], args.units[0]))
-
-    sizesizes = [int(.25 * 1000 * 1000), int(.5 * 1000 * 1000)]
-    sizes = []
-    for size in sizesizes:
-        for i in range(0, 25):
-            sizes.append(size)
-    if not args.simple:
-        print_('Realizando Test de subida', end='')
-    ulspeed = uploadSpeed(best['url'], sizes, args.simple)
-    if not args.simple:
-        print_()
-    print_('Subida: %0.2f M%s/s' %
-           ((ulspeed / 1000 / 1000) * args.units[1], args.units[0]))
-
-    if args.share and args.mini:
-        print_('Cannot generate a speedtest.net share results image while '
-               'testing against a Speedtest Mini server')
-    elif args.share:
-        dlspeedk = int(round((dlspeed / 1000) * 8, 0))
-        ping = int(round(best['latency'], 0))
-        ulspeedk = int(round((ulspeed / 1000) * 8, 0))
-
-        # Build the request to send results back to speedtest.net
-        # We use a list instead of a dict because the API expects parameters
-        # in a certain order
-        apiData = [
-            'download=%s' % dlspeedk,
-            'ping=%s' % ping,
-            'upload=%s' % ulspeedk,
-            'promo=',
-            'startmode=%s' % 'pingselect',
-            'recommendedserverid=%s' % best['id'],
-            'accuracy=%s' % 1,
-            'serverid=%s' % best['id'],
-            'hash=%s' % md5(('%s-%s-%s-%s' %
-                             (ping, ulspeedk, dlspeedk, '297aae72'))
-                            .encode()).hexdigest()]
-
-        headers = {'Referer': 'http://c.speedtest.net/flash/speedtest.swf'}
-        request = build_request('://www.speedtest.net/api/api.php',
-                                data='&'.join(apiData).encode(),
-                                headers=headers)
-        f, e = catch_request(request)
-        if e:
-            print_('Could not submit results to speedtest.net: %s' % e)
-            sys.exit(1)
-        response = f.read()
-        code = f.code
-        f.close()
-
-        if int(code) != 200:
-            print_('Could not submit results to speedtest.net')
-            sys.exit(1)
-
-        qsargs = parse_qs(response.decode())
-        resultid = qsargs.get('resultid')
-        if not resultid or len(resultid) != 1:
-            print_('Could not submit results to speedtest.net')
-            sys.exit(1)
-
-        print_('Share results: %s://www.speedtest.net/result/%s.png' %
-               (scheme, resultid[0]))
-
-
-def main():
-    try:
-        speedtest()
-    except KeyboardInterrupt:
-        print_('\nCancelling...')
-
-
-
-main()
-
-# vim:ts=4:sw=4:expandtab
diff --git a/lib/python/Plugins/Extensions/QuadPip/qpip.py b/lib/python/Plugins/Extensions/QuadPip/qpip.py
index 72a4819..effaf38 100644
--- a/lib/python/Plugins/Extensions/QuadPip/qpip.py
+++ b/lib/python/Plugins/Extensions/QuadPip/qpip.py
@@ -42,16 +42,8 @@ ENABLE_QPIP_PROCPATH = "/proc/stb/video/decodermode"
 
 def setDecoderMode(value):
 	if os.access(ENABLE_QPIP_PROCPATH, os.F_OK):
-		fd = open(ENABLE_QPIP_PROCPATH,"w")
-		fd.write(value)
-		fd.close()
-
-		# read to check
-		fd = open(ENABLE_QPIP_PROCPATH,"r")
-		data = fd.read()
-		fd.close()
-
-		return data.strip() == value
+		open(ENABLE_QPIP_PROCPATH,"w").write(value)
+		return open(ENABLE_QPIP_PROCPATH,"r").read().strip() == value
 
 class QuadPipChannelEntry:
 	def __init__(self, name, idx, ch1, ch2, ch3, ch4):
@@ -96,7 +88,7 @@ class QuadPipChannelEntry:
 			chName = ch[0]
 
 		if chName is None:
-			chName = " <No Channel>"
+			chName = _(" <No Channel>")
 
 		return chName
 
@@ -144,7 +136,7 @@ class QuadPipChannelList(QuadPipChannelData):
 	def __init__(self):
 		QuadPipChannelData.__init__(self)
 		self._curIdx = config.plugins.quadpip.lastchannel.value # starting from 1
-		self.defaultEntryPreName = "Quad PiP channel "
+		self.defaultEntryPreName = _("Quad PiP channel ")
 
 	def saveAll(self):
 		self.dataSave()
@@ -266,8 +258,8 @@ class CreateQuadPipChannelEntry(ChannelSelectionBase):
 						576:CreateQuadPipChannelEntry.skin_default_576p}.get(dh, CreateQuadPipChannelEntry.skin_default_1080p)
 
 		self.defaultEntryName = defaultEntryName
-		self["textChannels"] = Label(_(" "))
-		self["description"] = Label(_(" "))
+		self["textChannels"] = Label(" ")
+		self["description"] = Label(" ")
 
 		self.currList = None
 
@@ -294,7 +286,7 @@ class CreateQuadPipChannelEntry(ChannelSelectionBase):
 	def editEntryNameCB(self, newName):
 		if newName:
 			self.newChannel.setName(newName)
-			self.updateEntryName()		
+			self.updateEntryName()
 
 	def updateDescription(self):
 		if self.currList == "channelList":
@@ -317,7 +309,7 @@ class CreateQuadPipChannelEntry(ChannelSelectionBase):
 			_isEmpty = False
 			chName = self.newChannel.getChannelName(sIdx)
 			if chName is None:
-				chName = " <empty>"
+				chName = _(" <empty>")
 				_isEmpty = True
 			self.descChannels.append(("%d)  %s" % (idx, chName), sIdx, _isEmpty))	
 
@@ -520,8 +512,14 @@ class QuadPiPChannelSelection(Screen, HelpableScreen):
 	def keyYellow(self):
 		curChannel = self.getSelectedChannel()
 		if curChannel:
+			self.session.openWithCallback(self.removeCallback, MessageBox, _("Really delete this entry?"))
+
+	def removeCallback(self, answer):
+		curChannel = self.getSelectedChannel()
+		if answer and curChannel:
 			self.oldPosition = self["ChannelList"].getIndex()
 			self.qpipChannelList.removeChannel(curChannel)
+			self.force_exit = True
 			self.updateChannelList()
 
 	def keyBlue(self):
@@ -568,7 +566,7 @@ class QuadPiPChannelSelection(Screen, HelpableScreen):
 				entryName = "%s%d" % (self.qpipChannelList.getDefaultPreName(), ch.getIndex())
 
 			if self.qpipChannelList.getIdx() == ch.getIndex():
-				entryName += " (current channel)"
+				entryName += _(" (current channel)")
 
 			entry.append(entryName)
 			entry.append("1) " + ch.getChannelName("1"))
@@ -633,14 +631,14 @@ class FocusShowHide:
 class QuadPipScreen(Screen, FocusShowHide, HelpableScreen):
 	skin = """
 		<screen position="0,0" size="%d,%d" backgroundColor="transparent" flags="wfNoBorder">
-		    <widget name="ch1" position="240,240" zPosition="1" size="480,60" font="Regular; %d" halign="center" valign="center" foregroundColor="white" backgroundColor="#ffffffff" alphatest="on" />
-		    <widget name="ch2" position="1200,240" zPosition="1" size="480,60" font="Regular; %d" halign="center" valign="center" foregroundColor="white" backgroundColor="#ffffffff" alphatest="on" />
-		    <widget name="ch3" position="240,780" zPosition="1" size="480,60" font="Regular; %d" halign="center" valign="center" foregroundColor="white" backgroundColor="#ffffffff" alphatest="on" />
-		    <widget name="ch4" position="1200,780" zPosition="1" size="480,60" font="Regular; %d" halign="center" valign="center" foregroundColor="white" backgroundColor="#ffffffff" alphatest="on" />
-			<widget name="text1" position="%d,%d" zPosition="2" size="%d,%d" font="Regular; %d" halign="left" valign="center" alphatest="on" />
-			<widget name="text2" position="%d,%d" zPosition="2" size="%d,%d" font="Regular; %d" halign="left" valign="center" alphatest="on" />
+			<widget name="ch1" position="240,240" zPosition="1" size="480,60" font="Regular; %d" halign="center" valign="center" foregroundColor="white" backgroundColor="#ffffffff" alphatest="on" borderWidth="2"/>
+			<widget name="ch2" position="1200,240" zPosition="1" size="480,60" font="Regular; %d" halign="center" valign="center" foregroundColor="white" backgroundColor="#ffffffff" alphatest="on" borderWidth="2"/>
+			<widget name="ch3" position="240,780" zPosition="1" size="480,60" font="Regular; %d" halign="center" valign="center" foregroundColor="white" backgroundColor="#ffffffff" alphatest="on" borderWidth="2"/>
+			<widget name="ch4" position="1200,780" zPosition="1" size="480,60" font="Regular; %d" halign="center" valign="center" foregroundColor="white" backgroundColor="#ffffffff" alphatest="on" borderWidth="2"/>
+			<widget name="text1" position="%d,%d" zPosition="2" size="%d,%d" font="Regular; %d" halign="left" valign="center" alphatest="on" borderWidth="2"/>
+			<widget name="text2" position="%d,%d" zPosition="2" size="%d,%d" font="Regular; %d" halign="left" valign="center" alphatest="on" borderWidth="2"/>
 			<widget name="focus" position="0,0" zPosition="-1" size="960,540" backgroundColor="#ffffffff" borderWidth="5" borderColor="#e61616" alphatest="on" />
-		  </screen>
+		</screen>
 		"""
 	def __init__(self, session):
 		self.session = session
@@ -970,7 +968,7 @@ class QuadPipScreen(Screen, FocusShowHide, HelpableScreen):
 
 	def updateChannelName(self, channel):
 		for idx in range(1,5):
-			self["ch%d" % idx].setText((channel and channel.getChannelName(str(idx))) or "No channel")
+			self["ch%d" % idx].setText((channel and channel.getChannelName(str(idx))) or _("No channel"))
 
 	def disableFCC(self):
 		try:
diff --git a/lib/python/Plugins/Extensions/StartKodi/plugin.py b/lib/python/Plugins/Extensions/StartKodi/plugin.py
index e7a0cb7..6bb7cd9 100644
--- a/lib/python/Plugins/Extensions/StartKodi/plugin.py
+++ b/lib/python/Plugins/Extensions/StartKodi/plugin.py
@@ -179,7 +179,7 @@ def menu(menuid, **kwargs):
 
 def Plugins(**kwargs):
 	return [
-	PluginDescriptor(name = _("Start Kodi"), description = _("WeTek media player"), 	where = PluginDescriptor.WHERE_PLUGINMENU, icon = "kodi.png", needsRestart = False, fnc = main),
+	PluginDescriptor(name = _("Start Kodi"), description = _("Kodi media player"), 	where = PluginDescriptor.WHERE_PLUGINMENU, icon = "kodi.png", needsRestart = False, fnc = main),
 	PluginDescriptor(name = _("Start Kodi"), description = _("Play back media files"), where = PluginDescriptor.WHERE_MENU, needsRestart = False, fnc = menu)
 ]
 #	PluginDescriptor(name = _("StartKodi"), description = _("Play back media files"), where = PluginDescriptor.WHERE_EXTENSIONSMENU, needsRestart = False, fnc = menu)
diff --git a/lib/python/Plugins/SystemPlugins/CableScan/plugin.py b/lib/python/Plugins/SystemPlugins/CableScan/plugin.py
index 7eedfab..3979aec 100644
--- a/lib/python/Plugins/SystemPlugins/CableScan/plugin.py
+++ b/lib/python/Plugins/SystemPlugins/CableScan/plugin.py
@@ -106,8 +106,8 @@ class CableScanStatus(Screen):
 config.plugins.CableScan = ConfigSubsection()
 config.plugins.CableScan.keepnumbering = ConfigYesNo(default = False)
 config.plugins.CableScan.hdlist = ConfigYesNo(default = False)
-config.plugins.CableScan.frequency = ConfigInteger(default = 323, limits = (1, 999))
-config.plugins.CableScan.symbolrate = ConfigInteger(default = 6875, limits = (1, 9999))
+config.plugins.CableScan.frequency = ConfigInteger(default = 330, limits = (1, 999))
+config.plugins.CableScan.symbolrate = ConfigInteger(default = 6900, limits = (1, 9999))
 config.plugins.CableScan.networkid = ConfigInteger(default = 0, limits = (0, 99999))
 config.plugins.CableScan.modulation = ConfigSelection(
 	choices =
@@ -117,7 +117,7 @@ config.plugins.CableScan.modulation = ConfigSelection(
 		(str(eDVBFrontendParametersCable.Modulation_QAM128), "QAM128"),
 		(str(eDVBFrontendParametersCable.Modulation_QAM256), "QAM256")],
 	default = str(eDVBFrontendParametersCable.Modulation_QAM64))
-config.plugins.CableScan.auto = ConfigYesNo(default = True)
+config.plugins.CableScan.auto = ConfigYesNo(default = False)
 
 class CableScanScreen(ConfigListScreen, Screen):
 	skin = """
diff --git a/lib/python/Plugins/SystemPlugins/FastScan/plugin.py b/lib/python/Plugins/SystemPlugins/FastScan/plugin.py
index 6a2f52e..af3d56d 100644
--- a/lib/python/Plugins/SystemPlugins/FastScan/plugin.py
+++ b/lib/python/Plugins/SystemPlugins/FastScan/plugin.py
@@ -234,9 +234,9 @@ class FastScanScreen(ConfigListScreen, Screen):
 		transponderParameters.modulation = self.transponders[number][7]
 		transponderParameters.rolloff = self.transponders[number][8]
 		transponderParameters.pilot = self.transponders[number][9]
-		transponderParameters.is_id = 0 #-1
-		transponderParameters.pls_mode = eDVBFrontendParametersSatellite.PLS_Root
-		transponderParameters.pls_code = 1
+		transponderParameters.is_id = eDVBFrontendParametersSatellite.No_Stream_Id_Filter
+		transponderParameters.pls_mode = eDVBFrontendParametersSatellite.PLS_Gold
+		transponderParameters.pls_code = 0
 		return transponderParameters
 
 	def startScan(self):
diff --git a/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py b/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
index efa336e..6a1076b 100644
--- a/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
+++ b/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
@@ -5,6 +5,7 @@ from Screens.Screen import Screen
 from Components.ConfigList import ConfigListScreen
 from Components.config import config, configfile, getConfigListEntry
 from Components.Sources.StaticText import StaticText
+from Components.Label import Label
 
 from Tools.Directories import fileExists
 
@@ -14,9 +15,10 @@ if path.exists("/dev/hdmi_cec") or path.exists("/dev/misc/hdmi_cec0"):
 class HdmiCECSetupScreen(Screen, ConfigListScreen):
 	skin = """
 	<screen position="c-300,c-250" size="600,500" title="HDMI CEC setup">
-		<widget name="config" position="25,25" size="550,350" />
-		<widget source="current_address" render="Label" position="25,375" size="550,30" zPosition="10" font="Regular;21" halign="left" valign="center" />
-		<widget source="fixed_address" render="Label" position="25,405" size="550,30" zPosition="10" font="Regular;21" halign="left" valign="center" />
+		<widget name="config" position="15,15" size="720,350" scrollbarMode="showOnDemand"/>
+		<widget name="description" position="15,375" size="720,90" font="Regular;19" halign="center" valign="center" />
+		<widget source="current_address" render="Label" position="15,475" size="550,30" zPosition="10" font="Regular;21" halign="left" valign="center" />
+		<widget source="fixed_address" render="Label" position="15,505" size="550,30" zPosition="10" font="Regular;21" halign="left" valign="center" />
 		<ePixmap pixmap="buttons/red.png" position="20,e-45" size="140,40" alphatest="on" />
 		<ePixmap pixmap="buttons/green.png" position="160,e-45" size="140,40" alphatest="on" />
 		<ePixmap pixmap="buttons/yellow.png" position="300,e-45" size="140,40" alphatest="on" />
@@ -39,17 +41,22 @@ class HdmiCECSetupScreen(Screen, ConfigListScreen):
 		self["key_blue"] = StaticText(_("Clear fixed"))
 		self["current_address"] = StaticText()
 		self["fixed_address"] = StaticText()
+		self["description"] = Label()
 
 		self["actions"] = ActionMap(["SetupActions", "ColorActions", "MenuActions"],
 		{
 			"ok": self.keyGo,
 			"save": self.keyGo,
-			"cancel": self.keyCancel,
+			#"cancel": self.keyCancel,
+			"cancel": self.closeRecursive,
 			"green": self.keyGo,
-			"red": self.keyCancel,
+			#"red": self.keyCancel,
+			"red": self.closeRecursive,
 			"yellow": self.setFixedAddress,
 			"blue": self.clearFixedAddress,
 			"menu": self.closeRecursive,
+			"up": self.keyUp,
+			"down": self.keyDown,
 		}, -2)
 
 		self.onChangedEntry = [ ]
@@ -59,30 +66,51 @@ class HdmiCECSetupScreen(Screen, ConfigListScreen):
 
 	def createSetup(self):
 		self.list = []
-		self.list.append(getConfigListEntry(_("Enabled"), config.hdmicec.enabled))
+		self.list.append(getConfigListEntry(_("Enabled"), config.hdmicec.enabled, _('helptext'), 'refreshlist'))
 		if config.hdmicec.enabled.value:
-			self.list.append(getConfigListEntry(_("Put TV in standby"), config.hdmicec.control_tv_standby))
-			self.list.append(getConfigListEntry(_("Wakeup TV from standby"), config.hdmicec.control_tv_wakeup))
-			self.list.append(getConfigListEntry(_("Regard deep standby as standby"), config.hdmicec.handle_deepstandby_events))
-			self.list.append(getConfigListEntry(_("Switch TV to correct input"), config.hdmicec.report_active_source))
-			self.list.append(getConfigListEntry(_("Use TV remote control"), config.hdmicec.report_active_menu))
-			self.list.append(getConfigListEntry(_("Handle standby from TV"), config.hdmicec.handle_tv_standby))
-			self.list.append(getConfigListEntry(_("Handle wakeup from TV"), config.hdmicec.handle_tv_wakeup))
-			self.list.append(getConfigListEntry(_("Wakeup signal from TV"), config.hdmicec.tv_wakeup_detection))
-			self.list.append(getConfigListEntry(_("Forward volume keys"), config.hdmicec.volume_forwarding))
-			self.list.append(getConfigListEntry(_("Put your AV Receiver in standby"), config.hdmicec.control_receiver_standby))
-			self.list.append(getConfigListEntry(_("Wakeup your AV Receiver from standby") , config.hdmicec.control_receiver_wakeup))
-			self.list.append(getConfigListEntry(_("Minimum send interval"), config.hdmicec.minimum_send_interval))
+			tab = ' ' * 10
+			self.list.append(getConfigListEntry(_("Regard deep standby as standby"), config.hdmicec.handle_deepstandby_events, _('helptext'),'refreshlist'))
+			if config.hdmicec.handle_deepstandby_events.value and config.workaround.deeprecord.value:
+				self.list.append(getConfigListEntry(tab + _("Wait for timesync at startup"), config.hdmicec.deepstandby_waitfortimesync, _("If the 'deep standby workaround' is enabled, it waits until the system time is syncronised. Depending on the requirement, the devices wake up will continuing after a maximum of 2 minutes."), ))
+			self.list.append(getConfigListEntry(_("Put TV in standby"), config.hdmicec.control_tv_standby, _('helptext'),'refreshlist'))
+			if config.hdmicec.control_tv_standby.value:
+				self.list.append(getConfigListEntry(tab + _("Even if TV has another input active?"), config.hdmicec.tv_standby_notinputactive, _('You can skip this function and turn off the TV when you wake the receiver from standby and immediately switch back to standby.'), ))
+			self.list.append(getConfigListEntry(_("Wakeup TV from standby"), config.hdmicec.control_tv_wakeup, _('helptext') ,'refreshlist'))
+			if config.hdmicec.control_tv_wakeup.value:
+				self.list.append(getConfigListEntry(tab + _("Even if a 'zap' recording timer starting?"), config.hdmicec.tv_wakeup_zaptimer, _('helptext'), ))
+				self.list.append(getConfigListEntry(tab + _("Even if a 'zap and record' recording timer starting?"), config.hdmicec.tv_wakeup_zapandrecordtimer, _('helptext'), ))
+				self.list.append(getConfigListEntry(tab + _("Even if a 'wakeup' power timer starting?"), config.hdmicec.tv_wakeup_wakeuppowertimer, _('helptext'), ))
+			self.list.append(getConfigListEntry(_("Switch TV to correct input"), config.hdmicec.report_active_source, _('helptext'),'refreshlist'))
+			if config.hdmicec.report_active_source.value:
+				self.list.append(getConfigListEntry(tab + _("Switch off the TV to correct input"), config.hdmicec.workaround_activesource, _("Some TV devices can't swich to correct input if a another hdmi port active. This setting set the TV to standby before.\n(If the TV does not turn back on, may require a slower transmission interval or the repetition of wake-up commands.)"),))
+			self.list.append(getConfigListEntry(_("Use TV remote control"), config.hdmicec.report_active_menu, _('Activation takes place immediately. If it does feature not work, then try again with a slower send interval.'),))
+			self.list.append(getConfigListEntry(_("Handle wakeup from TV"), config.hdmicec.handle_tv_wakeup, _('Choose a setting where your receiver wakes up from standby.'),))
+			self.list.append(getConfigListEntry(_("Handle standby from TV"), config.hdmicec.handle_tv_standby, _('helptext'),'refreshlist'))
+			self.list.append(getConfigListEntry(_("Handle input from TV"), config.hdmicec.handle_tv_input, _('helptext'),'refreshlist'))
+			if config.hdmicec.handle_tv_standby.value != 'disabled' or config.hdmicec.handle_tv_input.value != 'disabled':
+				self.list.append(getConfigListEntry(tab + _("Time delay until standby or deep standby"), config.hdmicec.handle_tv_delaytime, _("'Handle standby from TV' has a higher priority as 'Handle input from TV'"),))
+			self.list.append(getConfigListEntry(_("Forward volume keys"), config.hdmicec.volume_forwarding, _('Activation takes place immediately. If this feature is not supported, the volume keys has no function!'),))
+			self.list.append(getConfigListEntry(_("Put your AV Receiver in standby"), config.hdmicec.control_receiver_standby, _('helptext'),))
+			self.list.append(getConfigListEntry(_("Wakeup your AV Receiver from standby"), config.hdmicec.control_receiver_wakeup, _('helptext'),))
+			self.list.append(getConfigListEntry(_("Minimum send interval"), config.hdmicec.minimum_send_interval, _('Try to slow down the send interval if not all commands are executed.\n') + _('(e.g. TV wakeup, but not switched to correct input)'), ))
+			self.list.append(getConfigListEntry(_("Repeat the sent standby and wakeup commands"), config.hdmicec.messages_repeat, _('Try to send repeated commands if not all commands are executed. This is done at a slower send interval.'),'refreshlist'))
+			if int(config.hdmicec.messages_repeat.value):
+				self.list.append(getConfigListEntry(tab + _("Repeat the standby commands?"), config.hdmicec.messages_repeat_standby, _('Is not necessary in most cases.'), ))
+				self.list.append(getConfigListEntry(tab + _("Slowing down for the send interval"), config.hdmicec.messages_repeat_slowdown, _('The time is multiplied by the repeat counter and added to the minimum send interval.'), ))
+			self.list.append(getConfigListEntry(_("Check power and input state from TV"), config.hdmicec.check_tv_state, _('An attempt is made to capture the current TV status. If this is not possible due to incorrect or missing status messages, it may cause the receiver to respond unexpectedly.\nOn the other hand, tries to respond better to different operating conditions.'), ))
 			if fileExists("/proc/stb/hdmi/preemphasis"):
-				self.list.append(getConfigListEntry(_("Use HDMI-preemphasis"), config.hdmicec.preemphasis))
+				self.list.append(getConfigListEntry(_("Use HDMI-preemphasis"), config.hdmicec.preemphasis, _('With this setting, you can probably improve the signal quality or eliminate problems that can occur with longer HDMI cables.'),))
+
 		self["config"].list = self.list
 		self["config"].l.setList(self.list)
 
 		self.updateAddress()
+		self.showHelpText()
 
 	# for summary:
 	def changedEntry(self):
-		if self["config"].getCurrent()[0] == _("Enabled"):
+		cur = self["config"].getCurrent()
+		if cur and (len(cur) > 2 and cur[2] == 'refreshlist' or len(cur) > 3 and cur[3] == 'refreshlist'):
 			self.createSetup()
 		for x in self.onChangedEntry:
 			x()
@@ -93,6 +121,14 @@ class HdmiCECSetupScreen(Screen, ConfigListScreen):
 	def keyRight(self):
 		ConfigListScreen.keyRight(self)
 
+	def keyDown(self):
+		self["config"].moveDown()
+		self.showHelpText()
+
+	def keyUp(self):
+		self["config"].moveUp()
+		self.showHelpText()
+
 	def keyGo(self):
 		for x in self["config"].list:
 			x[1].save()
@@ -120,5 +156,14 @@ class HdmiCECSetupScreen(Screen, ConfigListScreen):
 			fixedaddresslabel = _("Using fixed address") + ": " + config.hdmicec.fixed_physical_address.value
 		self["fixed_address"].setText(fixedaddresslabel)
 
+	def showHelpText(self):
+		cur = self["config"].getCurrent()
+		if cur and len(cur) > 2 and not cur[2] in ('refreshlist', _('helptext')):
+			self["description"].setText(cur[2])
+		elif cur and len(cur) > 3 and not cur[3] in ('refreshlist', _('helptext')):
+			self["description"].setText(cur[3])
+		else:
+			self["description"].setText(" ")
+
 def Plugins(**kwargs):
 	return []
diff --git a/lib/python/Plugins/SystemPlugins/PositionerSetup/plugin.py b/lib/python/Plugins/SystemPlugins/PositionerSetup/plugin.py
index 6b07856..82b5a37 100755
--- a/lib/python/Plugins/SystemPlugins/PositionerSetup/plugin.py
+++ b/lib/python/Plugins/SystemPlugins/PositionerSetup/plugin.py
@@ -119,8 +119,8 @@ class PositionerSetup(Screen):
 			cur.get("rolloff", eDVBFrontendParametersSatellite.RollOff_alpha_0_35),
 			cur.get("pilot", eDVBFrontendParametersSatellite.Pilot_Unknown),
 			cur.get("is_id", 0),
-			cur.get("pls_mode", eDVBFrontendParametersSatellite.PLS_Root),
-			cur.get("pls_code", 1))
+			cur.get("pls_mode", eDVBFrontendParametersSatellite.PLS_Gold),
+			cur.get("pls_code", 0))
 
 		self.tuner.tune(tp)
 		self.isMoving = False
@@ -1105,7 +1105,7 @@ class TunerScreen(ConfigListScreen, Screen):
 			"fec": eDVBFrontendParametersSatellite.FEC_Auto,
 			"fec_s2": eDVBFrontendParametersSatellite.FEC_9_10,
 			"modulation": eDVBFrontendParametersSatellite.Modulation_QPSK,
-			"pls_mode": eDVBFrontendParametersSatellite.PLS_Root,
+			"pls_mode": eDVBFrontendParametersSatellite.PLS_Gold,
 			"pls_code": 0 }
 		if frontendData is not None:
 			ttype = frontendData.get("tuner_type", "UNKNOWN")
@@ -1119,8 +1119,8 @@ class TunerScreen(ConfigListScreen, Screen):
 				defaultSat["rolloff"] = frontendData.get("rolloff", eDVBFrontendParametersSatellite.RollOff_alpha_0_35)
 				defaultSat["pilot"] = frontendData.get("pilot", eDVBFrontendParametersSatellite.Pilot_Unknown)
 				defaultSat["is_id"] = frontendData.get("is_id", 0)
-				defaultSat["pls_mode"] = frontendData.get("pls_mode", eDVBFrontendParametersSatellite.PLS_Root)
-				defaultSat["pls_code"] = frontendData.get("pls_code", 1)
+				defaultSat["pls_mode"] = frontendData.get("pls_mode", eDVBFrontendParametersSatellite.PLS_Gold)
+				defaultSat["pls_code"] = frontendData.get("pls_code", 0)
 			else:
 				defaultSat["fec"] = frontendData.get("fec_inner", eDVBFrontendParametersSatellite.FEC_Auto)
 			defaultSat["modulation"] = frontendData.get("modulation", eDVBFrontendParametersSatellite.Modulation_QPSK)
@@ -1178,7 +1178,7 @@ class TunerScreen(ConfigListScreen, Screen):
 			(eDVBFrontendParametersSatellite.PLS_Root, _("Root")),
 			(eDVBFrontendParametersSatellite.PLS_Gold, _("Gold")),
 			(eDVBFrontendParametersSatellite.PLS_Combo, _("Combo"))])
-		self.scan_sat.pls_code = ConfigInteger(default = defaultSat.get("pls_code",1), limits = (0, 262142))
+		self.scan_sat.pls_code = ConfigInteger(default = defaultSat.get("pls_code",0), limits = (0, 262142))
 
 	def initialSetup(self):
 		currtp = self.transponderToString([None, self.scan_sat.frequency.value, self.scan_sat.symbolrate.value, self.scan_sat.polarization.value])
diff --git a/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py b/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py
old mode 100644
new mode 100755
index dc4d293..8d097b4
--- a/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py
+++ b/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py
@@ -42,9 +42,9 @@ BLACKLISTED = ShellCompatibleFunctions.BLACKLISTED
 
 def InitConfig():
 	# BACKUPFILES contains all files and folders to back up, for wildcard entries ALWAYS use eEnv_resolve_multi!
-	BACKUPFILES = ['/etc/enigma2/', '/etc/CCcam.cfg', '/usr/keys/', '/usr/lib/enigma2/python/Plugins/Extensions/MyMetrixLite/MyMetrixLiteBackup.dat',
+	BACKUPFILES = ['/etc/enigma2/', '/etc/CCcam.cfg', '/usr/keys/',
 		'/etc/davfs2/', '/etc/tuxbox/config/', '/etc/auto.network', '/etc/feeds.xml', '/etc/machine-id', '/etc/rc.local', 
-		'/etc/openvpn/', '/etc/ipsec.conf', '/etc/ipsec.secrets', '/etc/ipsec.user', '/etc/strongswan.conf', 
+		'/etc/openvpn/', '/etc/ipsec.conf', '/etc/ipsec.secrets', '/etc/ipsec.user', '/etc/strongswan.conf', '/etc/vtuner.conf',
 		'/etc/default/crond', '/etc/dropbear/', '/etc/default/dropbear', '/home/', '/etc/samba/', '/etc/fstab', '/etc/inadyn.conf', 
 		'/etc/network/interfaces', '/etc/wpa_supplicant.conf', '/etc/wpa_supplicant.ath0.conf', '/etc/opkg/secret-feed.conf',
 		'/etc/wpa_supplicant.wlan0.conf', '/etc/wpa_supplicant.wlan1.conf', '/etc/resolv.conf', '/etc/default_gw', '/etc/hostname', '/etc/epgimport/', '/etc/exports',
@@ -53,11 +53,14 @@ def InitConfig():
 		'/usr/lib/enigma2/python/Plugins/Extensions/VMC/youtv.pwd',
 		'/usr/lib/enigma2/python/Plugins/Extensions/VMC/vod.config',
 		'/usr/share/enigma2/MetrixHD/skinparts/',
+		'/usr/share/enigma2/display/skin_display_usr.xml',
+		'/usr/share/enigma2/display/userskin.png',
 		'/usr/lib/enigma2/python/Plugins/Extensions/SpecialJump/keymap_user.xml',
 		'/usr/lib/enigma2/python/Plugins/Extensions/MP3Browser/db',
 		'/usr/lib/enigma2/python/Plugins/Extensions/MovieBrowser/db',
 		'/usr/lib/enigma2/python/Plugins/Extensions/TVSpielfilm/db', '/etc/ConfFS',
 		'/etc/rc3.d/S99tuner.sh',
+		'/usr/bin/enigma2_pre_start.sh',
 		eEnv.resolve("${datadir}/enigma2/keymap.usr"),
 		eEnv.resolve("${datadir}/enigma2/keymap_usermod.xml")]\
 		+eEnv_resolve_multi("${datadir}/enigma2/*/mySkin_off/*.xml")\
diff --git a/lib/python/Plugins/SystemPlugins/SoftwareManager/Flash_online.py b/lib/python/Plugins/SystemPlugins/SoftwareManager/Flash_online.py
index c616e17..01efeb5 100644
--- a/lib/python/Plugins/SystemPlugins/SoftwareManager/Flash_online.py
+++ b/lib/python/Plugins/SystemPlugins/SoftwareManager/Flash_online.py
@@ -29,18 +29,18 @@ MTDKERNEL = getMachineMtdKernel()
 MTDROOTFS = getMachineMtdRoot()
 
 #############################################################################################################
-image = 0 # 0=OpenPlus / 1=openMips
+image = 0 # 0=openATV / 1=openMips
 if distro.lower() == "openmips":
 	image = 1
-elif distro.lower() == "openplus":
+elif distro.lower() == "openatv":
 	image = 0
-feedurl_atv = 'http://feeds.open-plus.es/openplus/%s' %ImageVersion
+feedurl_atv = 'http://images.mynonpublic.com/openatv/%s' %ImageVersion
 
-if ImageVersion == '2.1':
-	ImageVersion2= '2.3'
+if ImageVersion == '6.2':
+	ImageVersion2= '6.3'
 else:
-	ImageVersion2= '2.0'
-feedurl_atv2= 'http://feeds.open-plus.es/openplus/%s' %ImageVersion2
+	ImageVersion2= '6.2'
+feedurl_atv2= 'http://images.mynonpublic.com/openatv/%s' %ImageVersion2
 feedurl_om = 'http://image.openmips.com/5.3'
 imagePath = '/media/hdd/images'
 flashPath = '/media/hdd/images/flash'
@@ -89,10 +89,13 @@ class FlashOnline(Screen):
 			self.devrootfs = "/dev/mmcblk1p3"
 		self.multi = 1
 		self.list = self.list_files("/boot")
+		self.MTDKERNEL = getMachineMtdKernel()
+		self.MTDROOTFS = getMachineMtdRoot()
 
 		Screen.setTitle(self, _("Flash On the Fly"))
 		if SystemInfo["HaveMultiBoot"]:
 			self["key_yellow"] = StaticText(_("STARTUP"))
+			self.read_current_multiboot()
 		else:
 			self["key_yellow"] = StaticText("")
 		self["key_green"] = StaticText(_("Online"))
@@ -151,13 +154,13 @@ class FlashOnline(Screen):
 		
 	def blue(self):
 		if self.check_hdd():
-			self.session.open(doFlashImage, online = False, list=self.list[self.selection], multi=self.multi, devrootfs=self.devrootfs)
+			self.session.open(doFlashImage, online = False, list=self.list[self.selection], multi=self.multi, devrootfs=self.devrootfs, mtdkernel=self.MTDKERNEL, mtdrootfs=self.MTDROOTFS)
 		else:
 			self.close()
 
 	def green(self):
 		if self.check_hdd():
-			self.session.open(doFlashImage, online = True, list=self.list[self.selection], multi=self.multi, devrootfs=self.devrootfs)
+			self.session.open(doFlashImage, online = True, list=self.list[self.selection], multi=self.multi, devrootfs=self.devrootfs, mtdkernel=self.MTDKERNEL, mtdrootfs=self.MTDROOTFS)
 		else:
 			self.close()
 
@@ -177,6 +180,40 @@ class FlashOnline(Screen):
 			self.devrootfs = self.find_rootfs_dev(self.list[self.selection])
 			print "[Flash Online] MULTI rootfs ", self.devrootfs
 
+			self.read_current_multiboot()
+
+	def read_current_multiboot(self):
+		if getMachineBuild() in ("hd51","vs1500","h7"):
+			if self.list[self.selection] == "Recovery":
+				cmdline = self.read_startup("/boot/STARTUP").split("=",3)[3].split(" ",1)[0]
+			else:
+				cmdline = self.read_startup("/boot/" + self.list[self.selection]).split("=",3)[3].split(" ",1)[0]
+		elif getMachineBuild() in ("8100s"):
+			if self.list[self.selection] == "Recovery":
+				cmdline = self.read_startup("/boot/STARTUP").split("=",4)[4].split(" ",1)[0]
+			else:
+				cmdline = self.read_startup("/boot/" + self.list[self.selection]).split("=",4)[4].split(" ",1)[0]
+		elif getMachineBuild() in ("cc1","sf8008","sf8008s","ustym4kpro"):
+			if self.list[self.selection] == "Recovery":
+				cmdline = self.read_startup("/boot/STARTUP").split("=",1)[1].split(" ",1)[0]
+			else:
+				cmdline = self.read_startup("/boot/" + self.list[self.selection]).split("=",1)[1].split(" ",1)[0]
+		elif getMachineBuild() in ("osmio4k"):
+			if self.list[self.selection] == "Recovery":
+				cmdline = self.read_startup("/boot/STARTUP").split("=",1)[1].split(" ",1)[0]
+			else:
+				cmdline = self.read_startup("/boot/" + self.list[self.selection]).split("=",1)[1].split(" ",1)[0]
+		else:
+			if self.list[self.selection] == "Recovery":
+				cmdline = self.read_startup("/boot/cmdline.txt").split("=",1)[1].split(" ",1)[0]
+			else:
+				cmdline = self.read_startup("/boot/" + self.list[self.selection]).split("=",1)[1].split(" ",1)[0]
+		cmdline = cmdline.lstrip("/dev/")
+		self.MTDROOTFS = cmdline
+		self.MTDKERNEL = cmdline[:-1] + str(int(cmdline[-1:]) -1)
+		print "[Flash Online] kernel device: ",self.MTDKERNEL
+		print "[Flash Online] rootfsdevice: ",self.MTDROOTFS
+
 	def read_startup(self, FILE):
 		file = FILE
 		with open(file, 'r') as myfile:
@@ -192,7 +229,7 @@ class FlashOnline(Screen):
 		files = []
 		if SystemInfo["HaveMultiBoot"]:
 			path = PATH
-			if getMachineBuild() in ("hd51","vs1500","h7","8100s","gb7252"):
+			if getMachineBuild() in ("ustym4kpro","hd51","vs1500","h7","8100s","gb7252","cc1","sf8008","sf8008s","osmio4k","ustym4kpro"):
 				for name in os.listdir(path):
 					if name != 'bootname' and os.path.isfile(os.path.join(path, name)):
 						try:
@@ -232,7 +269,7 @@ class doFlashImage(Screen):
 		<widget name="imageList" position="10,10" zPosition="1" size="450,450" font="Regular;20" scrollbarMode="showOnDemand" transparent="1" />
 	</screen>"""
 		
-	def __init__(self, session, online, list=None, multi=None, devrootfs=None ):
+	def __init__(self, session, online, list=None, multi=None, devrootfs=None, mtdkernel=None, mtdrootfs=None ):
 		Screen.__init__(self, session)
 		self.session = session
 
@@ -248,6 +285,8 @@ class doFlashImage(Screen):
 		self.List = list
 		self.multi=multi
 		self.devrootfs=devrootfs
+		self.MTDKERNEL = mtdkernel
+		self.MTDROOTFS = mtdrootfs
 		self.imagePath = imagePath
 		self.feedurl = feedurl_atv
 		if image == 0:
@@ -257,6 +296,7 @@ class doFlashImage(Screen):
 		self["imageList"] = MenuList(self.imagelist)
 		self["actions"] = ActionMap(["OkCancelActions", "ColorActions"], 
 		{
+			"ok": self.green,
 			"green": self.green,
 			"yellow": self.yellow,
 			"red": self.quit,
@@ -332,7 +372,7 @@ class doFlashImage(Screen):
 			print"Nothing to select !!"
 			return False
 		self.filename = self.imagePath + "/" + self.sel
-		return True
+		return self.checkTrafficLight()
 
 	def greenCB(self, ret = None):
 		if self.Online:
@@ -349,6 +389,26 @@ class doFlashImage(Screen):
 			self.hide()
 			self.session.openWithCallback(self.greenCB, MessageBox, _("Do you want to backup your settings now?"), default=True)
 
+	def checkTrafficLight(self):
+		import time
+		if not self.Online or not time.strftime('%Y%m%d') in self.filename:
+			return True
+
+		try:
+			urlopenATV = "http://ampel.mynonpublic.com/Ampel/index.php"
+			d = urllib2.urlopen(urlopenATV)
+			tmpStatus = d.read()
+		except:
+			tmpStatus = _("Unknown")
+
+		if 'gruen.png' in tmpStatus:
+			return True
+		else:
+			if 'rot.png' in tmpStatus: tmpStatus = _("red")
+			elif 'gelb.png' in tmpStatus: tmpStatus = _("yellow")
+			self.session.open(MessageBox, _("Traffic light state is '%s' - please use a another image.") %tmpStatus.upper(), type = MessageBox.TYPE_ERROR)
+			return False
+
 	def startInstallOnline(self, ret = None):
 		box = self.box()
 		url = self.feedurl + "/" + box + "/" + self.sel
@@ -538,9 +598,14 @@ class doFlashImage(Screen):
 			if self.simulate:
 				text += _("Simulate (no write)")
 				if SystemInfo["HaveMultiBoot"]:
-					cmdlist.append("%s -n -r -k -m%s %s > /dev/null 2>&1" % (ofgwritePath, self.multi, flashTmp))
-				elif getMachineBuild() in ("u5","u5pvr"):
+					if getMachineBuild() in ("cc1","sf8008","sf8008s","ustym4kpro"):
+						cmdlist.append("%s -r%s -k%s %s > /dev/null 2>&1" % (ofgwritePath, self.MTDROOTFS, self.MTDKERNEL, flashTmp))
+					else:
+						cmdlist.append("%s -n -r -k -m%s %s > /dev/null 2>&1" % (ofgwritePath, self.multi, flashTmp))
+				elif getMachineBuild() in ("h9combo","u51","u52","u53","u54","u5","u5pvr","cc1","sf8008","sf8008s","ustym4kpro","hd60","v8plus"):
 					cmdlist.append("%s -n -r%s -k%s %s > /dev/null 2>&1" % (ofgwritePath, MTDROOTFS, MTDKERNEL, flashTmp))
+				elif getMachineBuild() in ("h9","i55plus"):
+					cmdlist.append("%s -n -f -r -k %s > /dev/null 2>&1" % (ofgwritePath, flashTmp))
 				else:
 					cmdlist.append("%s -n -r -k %s > /dev/null 2>&1" % (ofgwritePath, flashTmp))
 				self.close()
@@ -552,12 +617,14 @@ class doFlashImage(Screen):
 				if SystemInfo["HaveMultiBoot"]:
 					if self.List not in ("STARTUP","cmdline.txt"):
 						os.system('mkfs.ext4 -F ' + self.devrootfs)
-					cmdlist.append("%s -r -k -m%s %s > /dev/null 2>&1" % (ofgwritePath, self.multi, flashTmp))
-					if self.List not in ("STARTUP","cmdline.txt"):
-						cmdlist.append("umount -fl /oldroot_bind")
-						cmdlist.append("umount -fl /newroot")
-				elif getMachineBuild() in ("u5","u5pvr"):
+					if getMachineBuild() in ("cc1","sf8008","sf8008s","ustym4kpro"):
+						cmdlist.append("%s -r%s -k%s %s > /dev/null 2>&1" % (ofgwritePath, self.MTDROOTFS, self.MTDKERNEL, flashTmp))
+					else:
+						cmdlist.append("%s -r -k -m%s %s > /dev/null 2>&1" % (ofgwritePath, self.multi, flashTmp))
+				elif getMachineBuild() in ("h9combo","u51","u52","u53","u54","u5","u5pvr","cc1","sf8008","sf8008s","ustym4kpro","hd60","v8plus"):
 					cmdlist.append("%s -r%s -k%s %s > /dev/null 2>&1" % (ofgwritePath, MTDROOTFS, MTDKERNEL, flashTmp))
+				elif getMachineBuild() in ("h9","i55plus"):
+					cmdlist.append("%s -f -r -k %s > /dev/null 2>&1" % (ofgwritePath, flashTmp))
 				else:
 					cmdlist.append("%s -r -k %s > /dev/null 2>&1" % (ofgwritePath, flashTmp))
 				message = "echo -e '\n"
@@ -596,7 +663,7 @@ class doFlashImage(Screen):
 					dest = flashTmp + '/%s' %KERNELBIN
 					shutil.copyfile(binfile, dest)
 					kernel = False
-				elif name.find('root') > -1 and (name.endswith('.bin') or name.endswith('.jffs2') or name.endswith('.bz2')) and rootfs:
+				elif name.find('root') > -1 and (name.endswith('.bin') or name.endswith('.ubi') or name.endswith('.jffs2') or name.endswith('.bz2')) and rootfs:
 					binfile = os.path.join(path, name)
 					dest = flashTmp + '/%s' %ROOTFSBIN
 					shutil.copyfile(binfile, dest)
@@ -645,7 +712,7 @@ class doFlashImage(Screen):
 			os.mkdir(flashTmp)
 			if binorzip == 0:
 				for files in os.listdir(self.imagePath):
-					if files.endswith(".bin") or files.endswith('.jffs2') or files.endswith('.img'):
+					if files.endswith(".ubi") or files.endswith(".bin") or files.endswith('.jffs2') or files.endswith('.img'):
 						self.prepair_flashtmp(strPath)
 						break
 				self.Start_Flashing()
@@ -668,14 +735,14 @@ class doFlashImage(Screen):
 					self["key_blue"].setText("openMIPS")
 				else:
 					self.feedurl = feedurl_om
-					self["key_blue"].setText("OpenPlus")
+					self["key_blue"].setText("openATV")
 			else:
 				if self.feed == "atv":
 					self.feedurl = feedurl_atv
-					self["key_blue"].setText("OP %s" %ImageVersion2)
+					self["key_blue"].setText("ATV %s" %ImageVersion2)
 				else:
 					self.feedurl = feedurl_atv2
-					self["key_blue"].setText("OP %s" %ImageVersion)
+					self["key_blue"].setText("ATV %s" %ImageVersion)
 			url = '%s/index.php?open=%s' % (self.feedurl,box)
 			try:
 				req = urllib2.Request(url)
@@ -720,7 +787,7 @@ class doFlashImage(Screen):
 			self.imagelist.sort()
 			if os.path.exists(flashTmp):
 				for file in os.listdir(flashTmp):
-					if file.find(".bin") > -1:
+					if file.find(".bin")> -1 or file.find(".ubi")> -1:
 						self.imagelist.insert( 0, str(flashTmp))
 						break
 
@@ -849,7 +916,7 @@ class DeviceBrowser(Screen, HelpableScreen):
 	def use(self):
 		print "[use]", self["filelist"].getCurrentDirectory(), self["filelist"].getFilename()
 		if self["filelist"].getFilename() is not None and self["filelist"].getCurrentDirectory() is not None:
-			if self["filelist"].getFilename().endswith(".bin") or self["filelist"].getFilename().endswith(".jffs2"):
+			if self["filelist"].getFilename().endswith(".bin") or self["filelist"].getFilename().endswith(".ubi") or self["filelist"].getFilename().endswith(".jffs2"):
 				self.close(self["filelist"].getCurrentDirectory(), self["filelist"].getFilename(), 0)
 			elif self["filelist"].getFilename().endswith(".zip"):
 				self.close(self["filelist"].getCurrentDirectory(), self["filelist"].getFilename(), 1)
diff --git a/lib/python/Plugins/SystemPlugins/SoftwareManager/ImageBackup.py b/lib/python/Plugins/SystemPlugins/SoftwareManager/ImageBackup.py
index 1e32168..c3f9a91 100644
--- a/lib/python/Plugins/SystemPlugins/SoftwareManager/ImageBackup.py
+++ b/lib/python/Plugins/SystemPlugins/SoftwareManager/ImageBackup.py
@@ -1,5 +1,5 @@
 #################################################################################
-# FULL BACKUP UYILITY FOR ENIGMA2, SUPPORTS THE MODELS OE-A 4.1     			#
+# FULL BACKUP UYILITY FOR ENIGMA2, SUPPORTS THE MODELS OE-A 4.3     			#
 #	                         						                            #
 #					MAKES A FULLBACK-UP READY FOR FLASHING.						#
 #																				#
@@ -20,10 +20,10 @@ import commands
 import datetime
 from boxbranding import getBoxType, getMachineBrand, getMachineName, getDriverDate, getImageVersion, getImageBuild, getBrandOEM, getMachineBuild, getImageFolder, getMachineUBINIZE, getMachineMKUBIFS, getMachineMtdKernel, getMachineMtdRoot, getMachineKernelFile, getMachineRootFile, getImageFileSystem
 
-VERSION = "Version 2.3 OpenPlus"
+VERSION = _("Version") + " 6.2 openATV"
 
 HaveGZkernel = True
-if getMachineBuild() in ('h9','vuzero4k','u5','u5pvr','sf5008','et13000','et1x000',"vuuno4k","vuuno4kse", "vuultimo4k", "vusolo4k", "spark", "spark7162", "hd51", "hd52", "sf4008", "dags7252", "gb7252", "vs1500","h7",'xc7439','8100s'):
+if getMachineBuild() in ('vuduo4k','v8plus','ustym4kpro','hd60','i55plus','osmio4k','sf8008','sf8008s','cc1','dags72604', 'u51','u52','u53','u54','h9','h9combo','vuzero4k','u5','u5pvr','sf5008','et13000','et1x000',"vuuno4k","vuuno4kse", "vuultimo4k", "vusolo4k", "spark", "spark7162", "hd51", "hd52", "sf4008", "dags7252", "gb7252", "vs1500","h7",'xc7439','8100s'):
 	HaveGZkernel = False
 
 def Freespace(dev):
@@ -64,14 +64,17 @@ class ImageBackup(Screen):
 		self.MTDROOTFS = getMachineMtdRoot()
 		self.ROOTFSBIN = getMachineRootFile()
 		self.KERNELBIN = getMachineKernelFile()
-		self.ROOTFSTYPE = getImageFileSystem()
+		self.ROOTFSTYPE = getImageFileSystem().strip()
 
 		if self.MACHINEBUILD in ("hd51","vs1500","h7","8100s"):
 			self.MTDBOOT = "mmcblk0p1"
 			self.EMMCIMG = "disk.img"
-		elif self.MACHINEBUILD in ("xc7439"):
+		elif self.MACHINEBUILD in ("xc7439","osmio4k"):
 			self.MTDBOOT = "mmcblk1p1"
 			self.EMMCIMG = "emmc.img"
+		elif self.MACHINEBUILD in ("cc1","sf8008","sf8008s","ustym4kpr"):
+			self.MTDBOOT = "none"
+			self.EMMCIMG = "usb_update.bin"
 		else:
 			self.MTDBOOT = "none"
 			self.EMMCIMG = "none"
@@ -87,9 +90,12 @@ class ImageBackup(Screen):
 		print "[FULL BACKUP] MTDBOOT = >%s<" %self.MTDBOOT
 		print "[FULL BACKUP] MTDKERNEL = >%s<" %self.MTDKERNEL
 		print "[FULL BACKUP] MTDROOTFS = >%s<" %self.MTDROOTFS
+		print "[FULL BACKUP] ROOTFSBIN = >%s<" %self.ROOTFSBIN
+		print "[FULL BACKUP] KERNELBIN = >%s<" %self.KERNELBIN
 		print "[FULL BACKUP] ROOTFSTYPE = >%s<" %self.ROOTFSTYPE
 		print "[FULL BACKUP] EMMCIMG = >%s<" %self.EMMCIMG
 
+		self.error_files = ''
 		self.list = self.list_files("/boot")
 		self["key_green"] = StaticText("USB")
 		self["key_red"] = StaticText("HDD")
@@ -101,8 +107,8 @@ class ImageBackup(Screen):
 		else:
 			self["key_yellow"] = StaticText("")
 			self["info-multi"] = Label(" ")
-		self["info-usb"] = Label(_("USB = Do you want to make a back-up on USB?\nThis will take between 4 and 15 minutes depending on the used filesystem and is fully automatic.\nMake sure you first insert an USB flash drive before you select USB."))
-		self["info-hdd"] = Label(_("HDD = Do you want to make an USB-back-up image on HDD? \nThis only takes 2 or 10 minutes and is fully automatic."))
+		self["info-usb"] = Label(_("USB = Do you want to make a back-up on USB?\nThis will take between 3 and 15 minutes depending on the used filesystem and is fully automatic.\nMake sure you first insert a USB flash drive before you select USB."))
+		self["info-hdd"] = Label(_("HDD = Do you want to make a USB-back-up image on HDD? \nThis only takes 1 or 10 minutes and is fully automatic."))
 		self["actions"] = ActionMap(["OkCancelActions", "ColorActions"], 
 		{
 			"blue": self.quit,
@@ -111,6 +117,12 @@ class ImageBackup(Screen):
 			"red": self.red,
 			"cancel": self.quit,
 		}, -2)
+		self.onShown.append(self.show_Errors)
+
+	def show_Errors(self):
+		if self.error_files:
+			self.session.open(MessageBox, _('Index Error in the following files: %s') %self.error_files[:-2], type = MessageBox.TYPE_ERROR)
+			self.error_files = ''
 
 	def check_hdd(self):
 		if not path.exists("/media/hdd"):
@@ -165,6 +177,16 @@ class ImageBackup(Screen):
 				cmdline = self.read_startup("/boot/STARTUP").split("=",4)[4].split(" ",1)[0]
 			else:
 				cmdline = self.read_startup("/boot/" + self.list[self.selection]).split("=",4)[4].split(" ",1)[0]
+		elif self.MACHINEBUILD in ("cc1","sf8008","sf8008s","ustym4kpro"):
+			if self.list[self.selection] == "Recovery":
+				cmdline = self.read_startup("/boot/STARTUP").split("=",1)[1].split(" ",1)[0]
+			else:
+				cmdline = self.read_startup("/boot/" + self.list[self.selection]).split("=",1)[1].split(" ",1)[0]
+		elif self.MACHINEBUILD in ("osmio4k"):
+			if self.list[self.selection] == "Recovery":
+				cmdline = self.read_startup("/boot/STARTUP").split("=",1)[1].split(" ",1)[0]
+			else:
+				cmdline = self.read_startup("/boot/" + self.list[self.selection]).split("=",1)[1].split(" ",1)[0]
 		else:
 			if self.list[self.selection] == "Recovery":
 				cmdline = self.read_startup("/boot/cmdline.txt").split("=",1)[1].split(" ",1)[0]
@@ -189,14 +211,18 @@ class ImageBackup(Screen):
 			self.path = PATH
 			for name in listdir(self.path):
 				if path.isfile(path.join(self.path, name)):
-					if self.MACHINEBUILD in ("hd51","vs1500","h7"):
-						cmdline = self.read_startup("/boot/" + name).split("=",3)[3].split(" ",1)[0]
-					elif self.MACHINEBUILD in ("8100s"):
-						cmdline = self.read_startup("/boot/" + name).split("=",4)[4].split(" ",1)[0]
-					else:
-						cmdline = self.read_startup("/boot/" + name).split("=",1)[1].split(" ",1)[0]
-					if cmdline in Harddisk.getextdevices("ext4"):
-						files.append(name)
+					try:
+						if self.MACHINEBUILD in ("hd51","vs1500","h7"):
+							cmdline = self.read_startup("/boot/" + name).split("=",3)[3].split(" ",1)[0]
+						elif self.MACHINEBUILD in ("8100s"):
+							cmdline = self.read_startup("/boot/" + name).split("=",4)[4].split(" ",1)[0]
+						else:
+							cmdline = self.read_startup("/boot/" + name).split("=",1)[1].split(" ",1)[0]
+						if cmdline in Harddisk.getextdevices("ext4"):
+							files.append(name)
+					except IndexError:
+						print '[ImageBackup] - IndexError in file: %s' %name
+						self.error_files += '/boot/' + name + ', ' 
 			if getMachineBuild() not in ("gb7252"):
 				files.append("Recovery")
 		return files
@@ -220,7 +246,7 @@ class ImageBackup(Screen):
 		self.IMAGEVERSION = self.imageInfo() #strftime("%Y%m%d", localtime(self.START))
 		if "ubi" in self.ROOTFSTYPE.split():
 			self.MKFS = "/usr/sbin/mkfs.ubifs"
-		elif "tar.bz2" in self.ROOTFSTYPE.split() or SystemInfo["HaveMultiBoot"] or self.MACHINEBUILD in ("u5","u5pvr"):
+		elif "tar.bz2" in self.ROOTFSTYPE.split() or SystemInfo["HaveMultiBoot"] or self.MACHINEBUILD in ("u51","u52","u53","u54","u5","u5pvr","cc1","sf8008","sf8008s","ustym4kpro"):
 			self.MKFS = "/bin/tar"
 			self.BZIP2 = "/usr/bin/bzip2"
 		else:
@@ -245,26 +271,24 @@ class ImageBackup(Screen):
 		self.MAINDESTOLD = "%s/%s" %(self.DIRECTORY, self.MODEL)
 		self.MAINDEST = "%s/%s" %(self.DIRECTORY,self.IMAGEFOLDER)
 		self.EXTRA = "%s/fullbackup_%s/%s/%s" % (self.DIRECTORY, self.MODEL, self.DATE, self.IMAGEFOLDER)
+		self.EXTRAROOT = "%s/fullbackup_%s/%s" % (self.DIRECTORY, self.MODEL, self.DATE)
 		self.EXTRAOLD = "%s/fullbackup_%s/%s/%s" % (self.DIRECTORY, self.MODEL, self.DATE, self.MODEL)
 
 
 		self.message = "echo -e '\n"
-		self.message += (_("Back-up Tool for a %s\n" %self.SHOWNAME)).upper()
+		if getMachineBrand().startswith('A') or getMachineBrand().startswith('E') or getMachineBrand().startswith('I') or getMachineBrand().startswith('O') or getMachineBrand().startswith('U') or getMachineBrand().startswith('Xt'):
+			self.message += (_('Back-up Tool for an %s\n') % self.SHOWNAME).upper()
+		else:
+			self.message += (_('Back-up Tool for a %s\n') % self.SHOWNAME).upper()
 		self.message += VERSION + '\n'
 		self.message += "_________________________________________________\n\n"
 		self.message += _("Please be patient, a backup will now be made,\n")
-		if self.ROOTFSTYPE == "ubi":
-			self.message += _("because of the used filesystem the back-up\n")
-			self.message += _("will take about 3-12 minutes for this system\n")
-		elif SystemInfo["HaveMultiBoot"] and self.list[self.selection] == "Recovery":
-			self.message += _("because of the used filesystem the back-up\n")
+		self.message += _("because of the used filesystem the back-up\n")
+		if SystemInfo["HaveMultiBoot"] and self.list[self.selection] == "Recovery":
 			self.message += _("will take about 30 minutes for this system\n")
-		elif "tar.bz2" in self.ROOTFSTYPE.split() or SystemInfo["HaveMultiBoot"]:
-			self.message += _("because of the used filesystem the back-up\n")
-			self.message += _("will take about 1-4 minutes for this system\n")
 		else:
-			self.message += _("this will take between 2 and 9 minutes\n")
-		self.message += "\n_________________________________________________\n\n"
+			self.message += _("will take about 1-15 minutes for this system\n")
+		self.message += "_________________________________________________\n"
 		self.message += "'"
 
 		## PREPARING THE BUILDING ENVIRONMENT
@@ -283,7 +307,7 @@ class ImageBackup(Screen):
 			cmd1 = "%s --root=/tmp/bi/root --faketime --output=%s/root.jffs2 %s" % (self.MKFS, self.WORKDIR, self.MKUBIFS_ARGS)
 			cmd2 = None
 			cmd3 = None
-		elif "tar.bz2" in self.ROOTFSTYPE.split() or SystemInfo["HaveMultiBoot"] or self.MACHINEBUILD in ("u5","u5pvr"):
+		elif "tar.bz2" in self.ROOTFSTYPE.split() or SystemInfo["HaveMultiBoot"] or self.MACHINEBUILD in ("u51","u52","u53","u54","u5","u5pvr","cc1","sf8008","sf8008s","ustym4kpro"):
 			cmd1 = "%s -cf %s/rootfs.tar -C /tmp/bi/root --exclude ./var/nmbd --exclude ./var/lib/samba/private/msg.sock ." % (self.MKFS, self.WORKDIR)
 			cmd2 = "%s %s/rootfs.tar" % (self.BZIP2, self.WORKDIR)
 			cmd3 = None
@@ -305,7 +329,7 @@ class ImageBackup(Screen):
 
 		cmdlist = []
 		cmdlist.append(self.message)
-		cmdlist.append('echo "Create: %s\n"' %self.ROOTFSBIN)
+		cmdlist.append('echo "' + _("Create:") + ' %s\n"' %self.ROOTFSBIN)
 		cmdlist.append(cmd1)
 		if cmd2:
 			cmdlist.append(cmd2)
@@ -315,29 +339,61 @@ class ImageBackup(Screen):
 
 		if self.MODEL in ("gbquad4k","gbue4k"):
 			cmdlist.append('echo " "')
-			cmdlist.append('echo "Create: boot dump"')
-			cmdlist.append('echo " "')
+			cmdlist.append('echo "' + _("Create:") + " boot dump" + '"')
 			cmdlist.append("dd if=/dev/mmcblk0p1 of=%s/boot.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " rescue dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p3 of=%s/rescue.bin" % self.WORKDIR)
+
+		if self.MACHINEBUILD  in ("h9","i55plus"):
 			cmdlist.append('echo " "')
-			cmdlist.append('echo "Create: rescue dump"')
+			cmdlist.append('echo "' + _("Create:") + " fastboot dump" + '"')
+			cmdlist.append("dd if=/dev/mtd0 of=%s/fastboot.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " bootargs dump" + '"')
+			cmdlist.append("dd if=/dev/mtd1 of=%s/bootargs.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " baseparam dump" + '"')
+			cmdlist.append("dd if=/dev/mtd2 of=%s/baseparam.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " pq_param dump" + '"')
+			cmdlist.append("dd if=/dev/mtd3 of=%s/pq_param.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " logo dump" + '"')
+			cmdlist.append("dd if=/dev/mtd4 of=%s/logo.bin" % self.WORKDIR)
+
+		if self.MACHINEBUILD  in ("cc1","sf8008","sf8008s","ustym4kpro"):
 			cmdlist.append('echo " "')
-			cmdlist.append("dd if=/dev/mmcblk0p3 of=%s/rescue.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " fastboot dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p1 of=%s/fastboot.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " bootargs dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p2 of=%s/bootargs.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " boot dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p3 of=%s/boot.img" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " baseparam dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p4 of=%s/baseparam.img" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " pq_param dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p5 of=%s/pq_param.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " logo dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p6 of=%s/logo.img" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " deviceinfo dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p7 of=%s/deviceinfo.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " apploader dump" + '"')
+			cmdlist.append("dd if=/dev/mmcblk0p8 of=%s/apploader.bin" % self.WORKDIR)
+			cmdlist.append('echo "' + _("Create:") + " rootfs dump" + '"')
+			cmdlist.append("dd if=/dev/zero of=%s/rootfs.ext4 seek=524288 count=0 bs=1024" % (self.WORKDIR))
+			cmdlist.append("mkfs.ext4 -F -i 4096 %s/rootfs.ext4 -d /tmp/bi/root" % (self.WORKDIR))
 
 		cmdlist.append('echo " "')
-		cmdlist.append('echo "Create: kerneldump"')
+		cmdlist.append('echo "' + _("Create:") + " kerneldump" + '"')
 		cmdlist.append('echo " "')
 		if SystemInfo["HaveMultiBoot"]:
 			cmdlist.append("dd if=/dev/%s of=%s/kernel.bin" % (self.MTDKERNEL ,self.WORKDIR))
-		elif self.MTDKERNEL == "mmcblk0p1" or self.MTDKERNEL == "mmcblk0p3" or self.MTDKERNEL == "mmcblk0p10" or self.MTDKERNEL == "mmcblk0p9":
+		elif self.MTDKERNEL.startswith('mmcblk0'):
 			cmdlist.append("dd if=/dev/%s of=%s/%s" % (self.MTDKERNEL ,self.WORKDIR, self.KERNELBIN))
 		else:
 			cmdlist.append("nanddump -a -f %s/vmlinux.gz /dev/%s" % (self.WORKDIR, self.MTDKERNEL))
 		cmdlist.append('echo " "')
 
 		if HaveGZkernel:
-			cmdlist.append('echo "Check: kerneldump"')
+			cmdlist.append('echo "' + _("Check:") + " kerneldump\n" + '"')
 		cmdlist.append("sync")
-		if ( SystemInfo["HaveMultiBootHD"] or SystemInfo["HaveMultiBootXC"] or SystemInfo["HaveMultiBootCY"]) and self.list[self.selection] == "Recovery":
+		if ( SystemInfo["HaveMultiBootHD"] or SystemInfo["HaveMultiBootXC"] or SystemInfo["HaveMultiBootCY"] or SystemInfo["HaveMultiBootOS"]) and self.list[self.selection] == "Recovery":
 			BLOCK_SIZE=512
 			BLOCK_SECTOR=2
 			IMAGE_ROOTFS_ALIGNMENT=1024
@@ -357,7 +413,7 @@ class ImageBackup(Screen):
 			EMMC_IMAGE_SIZE=3817472
 			EMMC_IMAGE_SEEK = int(EMMC_IMAGE_SIZE) * int(BLOCK_SECTOR)
 			cmdlist.append('echo " "')
-			cmdlist.append('echo "Create: Recovery Fullbackup %s"'% (self.EMMCIMG))
+			cmdlist.append('echo "' + _("Create: Recovery Fullbackup %s")% (self.EMMCIMG) + '"')
 			cmdlist.append('echo " "')
 			cmdlist.append('dd if=/dev/zero of=%s bs=%s count=0 seek=%s' % (EMMC_IMAGE, BLOCK_SIZE , EMMC_IMAGE_SEEK))
 			cmdlist.append('parted -s %s mklabel gpt' %EMMC_IMAGE)
@@ -386,14 +442,34 @@ class ImageBackup(Screen):
 			cmdlist.append('dd if=/dev/%s of=%s seek=%s' % (self.MTDKERNEL, EMMC_IMAGE, KERNAL_IMAGE_SEEK ))
 			ROOTFS_IMAGE_SEEK = int(ROOTFS_PARTITION_OFFSET) * int(BLOCK_SECTOR)
 			cmdlist.append('dd if=/dev/%s of=%s seek=%s ' % (self.MTDROOTFS, EMMC_IMAGE, ROOTFS_IMAGE_SEEK ))
+		elif SystemInfo["HaveMultiBootDS"] and self.list[self.selection] == "Recovery":
+			cmdlist.append('echo " "')
+			cmdlist.append('echo "' + _("Create: Recovery Fullbackup %s")% (self.EMMCIMG) + '"')
+			cmdlist.append('echo " "')
+			f = open("%s/emmc_partitions.xml" %self.WORKDIR, "w")
+			f.write('<?xml version="1.0" encoding="GB2312" ?>\n')
+			f.write('<Partition_Info>\n')
+			f.write('<Part Sel="1" PartitionName="fastboot" FlashType="emmc" FileSystem="none" Start="0" Length="1M" SelectFile="fastboot.bin"/>\n')
+			f.write('<Part Sel="1" PartitionName="bootargs" FlashType="emmc" FileSystem="none" Start="1M" Length="1M" SelectFile="bootargs.bin"/>\n')
+			f.write('<Part Sel="1" PartitionName="bootimg" FlashType="emmc" FileSystem="none" Start="2M" Length="1M" SelectFile="boot.img"/>\n')
+			f.write('<Part Sel="1" PartitionName="baseparam" FlashType="emmc" FileSystem="none" Start="3M" Length="3M" SelectFile="baseparam.img"/>\n')
+			f.write('<Part Sel="1" PartitionName="pqparam" FlashType="emmc" FileSystem="none" Start="6M" Length="4M" SelectFile="pq_param.bin"/>\n')
+			f.write('<Part Sel="1" PartitionName="logo" FlashType="emmc" FileSystem="none" Start="10M" Length="4M" SelectFile="logo.img"/>\n')
+			f.write('<Part Sel="1" PartitionName="deviceinfo" FlashType="emmc" FileSystem="none" Start="14M" Length="4M" SelectFile="deviceinfo.bin"/>\n')
+			f.write('<Part Sel="1" PartitionName="loader" FlashType="emmc" FileSystem="none" Start="26M" Length="32M" SelectFile="apploader.bin"/>\n')
+			f.write('<Part Sel="1" PartitionName="kernel" FlashType="emmc" FileSystem="none" Start="66M" Length="32M" SelectFile="kernel.bin"/>\n')
+			f.write('<Part Sel="1" PartitionName="rootfs" FlashType="emmc" FileSystem="ext3/4" Start="98M" Length="7000M" SelectFile="rootfs.ext4"/>\n')
+			f.write('</Partition_Info>\n')
+			f.close()
+			cmdlist.append('mkupdate -s 00000003-00000001-01010101 -f %s/emmc_partitions.xml -d %s/%s' % (self.WORKDIR,self.WORKDIR,self.EMMCIMG))
 		self.session.open(Console, title = self.TITLE, cmdlist = cmdlist, finishedCallback = self.doFullBackupCB, closeOnSuccess = True)
 
 	def doFullBackupCB(self):
 		if HaveGZkernel:
 			ret = commands.getoutput(' gzip -d %s/vmlinux.gz -c > /tmp/vmlinux.bin' % self.WORKDIR)
 			if ret:
-				text = "Kernel dump error\n"
-				text += "Please Flash your Kernel new and Backup again"
+				text = _("Kernel dump error\n")
+				text += _("Please Flash your Kernel new and Backup again")
 				system('rm -rf /tmp/vmlinux.bin')
 				self.session.open(MessageBox, _(text), type = MessageBox.TYPE_ERROR)
 				return
@@ -401,11 +477,11 @@ class ImageBackup(Screen):
 		cmdlist = []
 		cmdlist.append(self.message)
 		if HaveGZkernel:
-			cmdlist.append('echo "Kernel dump OK"')
+			cmdlist.append('echo "' + _("Kernel dump OK") + '"')
 			cmdlist.append("rm -rf /tmp/vmlinux.bin")
-		cmdlist.append('echo "_________________________________________________"')
-		cmdlist.append('echo "Almost there... "')
-		cmdlist.append('echo "Now building the USB-Image"')
+			cmdlist.append('echo "_________________________________________________\n"')
+		cmdlist.append('echo "' + _("Almost there... ") + '"')
+		cmdlist.append('echo "' + _("Now building the USB-Image") + '"')
 
 		system('rm -rf %s' %self.MAINDEST)
 		if not path.exists(self.MAINDEST):
@@ -423,7 +499,7 @@ class ImageBackup(Screen):
 			system('mv %s/root.%s %s/%s' %(self.WORKDIR, self.ROOTFSTYPE, self.MAINDEST, self.ROOTFSBIN))
 		if SystemInfo["HaveMultiBoot"]:
 			system('mv %s/kernel.bin %s/kernel.bin' %(self.WORKDIR, self.MAINDEST))
-		elif self.MTDKERNEL == "mmcblk0p1" or self.MTDKERNEL == "mmcblk0p3" or self.MTDKERNEL == "mmcblk0p10" or self.MTDKERNEL == "mmcblk0p9":
+		elif self.MTDKERNEL.startswith('mmcblk0'):
 			system('mv %s/%s %s/%s' %(self.WORKDIR, self.KERNELBIN, self.MAINDEST, self.KERNELBIN))
 		else:
 			system('mv %s/vmlinux.gz %s/%s' %(self.WORKDIR, self.MAINDEST, self.KERNELBIN))
@@ -434,7 +510,7 @@ class ImageBackup(Screen):
 			cmdlist.append('echo "This file forces a reboot after the update." > %s/reboot.update' %self.MAINDEST)
 		elif self.MODEL in ("vuzero" , "vusolose", "vuuno4k", "vuzero4k"):
 			cmdlist.append('echo "This file forces the update." > %s/force.update' %self.MAINDEST)
-		elif self.MODEL in ('evoslimse','evoslimt2c', "novaip" , "zgemmai55" , "sf98", "xpeedlxpro",'evoslim','vipert2c'):
+		elif self.MODEL in ('viperslim','evoslimse','evoslimt2c', "novaip" , "zgemmai55" , "sf98", "xpeedlxpro",'evoslim','vipert2c'):
 			cmdlist.append('echo "This file forces the update." > %s/force' %self.MAINDEST)
 		else:
 			cmdlist.append('echo "rename this file to "force" to force an update without confirmation" > %s/noforce' %self.MAINDEST)
@@ -444,6 +520,13 @@ class ImageBackup(Screen):
 			system('mv %s/rescue.bin %s/rescue.bin' %(self.WORKDIR, self.MAINDEST))
 			system('cp -f /usr/share/gpt.bin %s/gpt.bin' %(self.MAINDEST))
 
+		if self.MACHINEBUILD in ("h9","i55plus"):
+			system('mv %s/fastboot.bin %s/fastboot.bin' %(self.WORKDIR, self.MAINDEST))
+			system('mv %s/pq_param.bin %s/pq_param.bin' %(self.WORKDIR, self.MAINDEST))
+			system('mv %s/bootargs.bin %s/bootargs.bin' %(self.WORKDIR, self.MAINDEST))
+			system('mv %s/baseparam.bin %s/baseparam.bin' %(self.WORKDIR, self.MAINDEST))
+			system('mv %s/logo.bin %s/logo.bin' %(self.WORKDIR, self.MAINDEST))
+
 		if self.MODEL in ("gbquad", "gbquadplus", "gb800ue", "gb800ueplus", "gbultraue", "gbultraueh", "twinboxlcd", "twinboxlcdci", "singleboxlcd", "sf208", "sf228"):
 			lcdwaitkey = '/usr/share/lcdwaitkey.bin'
 			lcdwarning = '/usr/share/lcdwarning.bin'
@@ -451,7 +534,7 @@ class ImageBackup(Screen):
 				system('cp %s %s/lcdwaitkey.bin' %(lcdwaitkey, self.MAINDEST))
 			if path.exists(lcdwarning):
 				system('cp %s %s/lcdwarning.bin' %(lcdwarning, self.MAINDEST))
-		if self.MODEL in ("e4hdultra"):
+		if self.MODEL in ("e4hdultra","protek4k"):
 			lcdwarning = '/usr/share/lcdflashing.bmp'
 			if path.exists(lcdwarning):
 				system('cp %s %s/lcdflashing.bmp' %(lcdwarning, self.MAINDEST))
@@ -466,6 +549,9 @@ class ImageBackup(Screen):
 			f.close()
 
 		cmdlist.append('cp -r %s/* %s/' % (self.MAINDEST, self.EXTRA))
+		if self.MACHINEBUILD in ("h9","i55plus"):
+			cmdlist.append('cp -f /usr/share/fastboot.bin %s/fastboot.bin' %(self.EXTRAROOT))
+			cmdlist.append('cp -f /usr/share/bootargs.bin %s/bootargs.bin' %(self.EXTRAROOT))
 
 		cmdlist.append("sync")
 		file_found = True
@@ -484,34 +570,34 @@ class ImageBackup(Screen):
 
 		if SystemInfo["HaveMultiBoot"] and not self.list[self.selection] == "Recovery":
 			cmdlist.append('echo "_________________________________________________\n"')
-			cmdlist.append('echo "Multiboot Image created on:" %s' %self.MAINDEST)
-			cmdlist.append('echo "and there is made an extra copy on:"')
+			cmdlist.append('echo "' + _("Multiboot Image created on: %s") %self.MAINDEST + '"')
+			cmdlist.append('echo "' + _("and there is made an extra copy on:") + '"')
 			cmdlist.append('echo %s' %self.EXTRA)
-			cmdlist.append('echo "_________________________________________________\n"')
+			cmdlist.append('echo "_________________________________________________"')
 			cmdlist.append('echo " "')
-			cmdlist.append('echo "\nPlease wait...almost ready! "')
+			cmdlist.append('echo "' + _("Please wait...almost ready! ") + '"')
 			cmdlist.append('echo " "')
-			cmdlist.append('echo "To restore the image:"')
-			cmdlist.append('echo "Use OnlineFlash in SoftwareManager"')
+			cmdlist.append('echo "' + _("To restore the image:") + '"')
+			cmdlist.append('echo "' + _("Use OnlineFlash in SoftwareManager") + '"')
 		elif file_found:
 			cmdlist.append('echo "_________________________________________________\n"')
-			cmdlist.append('echo "USB Image created on:" %s' %self.MAINDEST)
-			cmdlist.append('echo "and there is made an extra copy on:"')
+			cmdlist.append('echo "' + _("USB Image created on: %s") %self.MAINDEST + '"')
+			cmdlist.append('echo "' + _("and there is made an extra copy on:") + '"')
 			cmdlist.append('echo %s' %self.EXTRA)
-			cmdlist.append('echo "_________________________________________________\n"')
+			cmdlist.append('echo "_________________________________________________"')
 			cmdlist.append('echo " "')
-			cmdlist.append('echo "\nPlease wait...almost ready! "')
+			cmdlist.append('echo "' + _("Please wait...almost ready! ") + '"')
 			cmdlist.append('echo " "')
-			cmdlist.append('echo "To restore the image:"')
-			cmdlist.append('echo "Please check the manual of the receiver"')
-			cmdlist.append('echo "on how to restore the image"')
+			cmdlist.append('echo "' + _("To restore the image:") + '"')
+			cmdlist.append('echo "' + _("Please check the manual of the receiver") + '"')
+			cmdlist.append('echo "' + _("on how to restore the image") + '"')
 		else:
 			cmdlist.append('echo "_________________________________________________\n"')
-			cmdlist.append('echo "Image creation failed - "')
-			cmdlist.append('echo "Probable causes could be"')
-			cmdlist.append('echo "     wrong back-up destination "')
-			cmdlist.append('echo "     no space left on back-up device"')
-			cmdlist.append('echo "     no writing permission on back-up device"')
+			cmdlist.append('echo "' + _("Image creation failed - ") + '"')
+			cmdlist.append('echo "' + _("Probable causes could be") + ':"')
+			cmdlist.append('echo "' + _("     wrong back-up destination ") + '"')
+			cmdlist.append('echo "' + _("     no space left on back-up device") + '"')
+			cmdlist.append('echo "' + _("     no writing permission on back-up device") + '"')
 			cmdlist.append('echo " "')
 
 		if self.DIRECTORY == "/hdd":
@@ -522,19 +608,21 @@ class ImageBackup(Screen):
 			else:
 				cmdlist.append('echo "_________________________________________________\n"')
 				cmdlist.append('echo " "')
-				cmdlist.append('echo "There is a valid USB-flash drive detected in one "')
-				cmdlist.append('echo "of the USB-ports, therefor an extra copy of the "')
-				cmdlist.append('echo "back-up image will now be copied to that USB- "')
-				cmdlist.append('echo "flash drive. "')
-				cmdlist.append('echo "This only takes about 1 or 2 minutes"')
+				cmdlist.append('echo "' + _("There is a valid USB-flash drive detected in one ") + '"')
+				cmdlist.append('echo "' + _("of the USB-ports, therefore an extra copy of the ") + '"')
+				cmdlist.append('echo "' + _("back-up image will now be copied to that USB- ") + '"')
+				cmdlist.append('echo "' + _("flash drive. ") + '"')
+				cmdlist.append('echo "' + _("This only takes about 1 or 2 minutes") + '"')
 				cmdlist.append('echo " "')
 
 				cmdlist.append('mkdir -p %s/%s' % (self.TARGET, self.IMAGEFOLDER))
 				cmdlist.append('cp -r %s %s/' % (self.MAINDEST, self.TARGET))
-
+				if self.MACHINEBUILD in ("h9","i55plus"):
+					cmdlist.append('cp -f /usr/share/fastboot.bin %s/fastboot.bin' %(self.TARGET))
+					cmdlist.append('cp -f /usr/share/bootargs.bin %s/bootargs.bin' %(self.TARGET))
 
 				cmdlist.append("sync")
-				cmdlist.append('echo "Backup finished and copied to your USB-flash drive"')
+				cmdlist.append('echo "' + _("Backup finished and copied to your USB-flash drive") + '"')
 			
 		cmdlist.append("umount /tmp/bi/root")
 		cmdlist.append("rmdir /tmp/bi/root")
@@ -544,14 +632,14 @@ class ImageBackup(Screen):
 		END = time()
 		DIFF = int(END - self.START)
 		TIMELAP = str(datetime.timedelta(seconds=DIFF))
-		cmdlist.append('echo "Time required for this process: %s"' %TIMELAP)
+		cmdlist.append('echo "' + _("Time required for this process: %s") %TIMELAP + '\n"')
 
 		self.session.open(Console, title = self.TITLE, cmdlist = cmdlist, closeOnSuccess = False)
 
 	def imageInfo(self):
 		AboutText = _("Full Image Backup ")
-		AboutText += _("By OpenPlus Image Team") + "\n"
-		AboutText += _("Support at") + " www.open-plus.es\n\n"
+		AboutText += _("By openATV Image Team") + "\n"
+		AboutText += _("Support at") + " www.opena.tv\n\n"
 		AboutText += _("[Image Info]\n")
 		AboutText += _("Model: %s %s\n") % (getMachineBrand(), getMachineName())
 		AboutText += _("Backup Date: %s\n") % strftime("%Y-%m-%d", localtime(self.START))
@@ -592,7 +680,7 @@ class ImageBackup(Screen):
 						AboutText += userbouqet.replace('#NAME ','')
 						f.close()
 		except:
-			AboutText += "Error reading bouquets.tv"
+			AboutText += _("Error reading bouquets.tv")
 			
 		AboutText += _("\n[User - bouquets (RADIO)]\n")
 		try:
@@ -609,7 +697,7 @@ class ImageBackup(Screen):
 						AboutText += userbouqet.replace('#NAME ','')
 						f.close()
 		except:
-			AboutText += "Error reading bouquets.radio"
+			AboutText += _("Error reading bouquets.radio")
 
 		AboutText += _("\n[Installed Plugins]\n")
 		AboutText += commands.getoutput("opkg list_installed | grep enigma2-plugin-")
diff --git a/lib/python/Plugins/SystemPlugins/SoftwareManager/ShellCompatibleFunctions.py b/lib/python/Plugins/SystemPlugins/SoftwareManager/ShellCompatibleFunctions.py
old mode 100644
new mode 100755
index 1ed7c52..6692c43
--- a/lib/python/Plugins/SystemPlugins/SoftwareManager/ShellCompatibleFunctions.py
+++ b/lib/python/Plugins/SystemPlugins/SoftwareManager/ShellCompatibleFunctions.py
@@ -9,7 +9,7 @@ MANDATORY_RIGHTS = "chown -R root:root /home/root /etc/auto.network /etc/default
 # BLACKLISTED lists all files/folders that MUST NOT be backed up or restored in order for the image to work properly
 BLACKLISTED = ['home/root/.cache', 'etc/passwd', 'etc/shadow', 'etc/group', 'etc/samba/distro', 'etc/samba/smb.conf', 'home/root/FastRestore.log']
 
-IMAGE_INSTALL = ['openplus-base', 'enigma2-plugin-settings-defaultsat', 'run-postinsts']
+IMAGE_INSTALL = ['openatv-base', 'enigma2-plugin-settings-defaultsat', 'run-postinsts']
 
 PACKAGES = '/var/lib/opkg/lists'
 INSTALLEDPACKAGES = '/var/lib/opkg/status'
diff --git a/lib/python/Plugins/SystemPlugins/SoftwareManager/imagewizard.xml b/lib/python/Plugins/SystemPlugins/SoftwareManager/imagewizard.xml
index 53a456a..c6d55ad 100644
--- a/lib/python/Plugins/SystemPlugins/SoftwareManager/imagewizard.xml
+++ b/lib/python/Plugins/SystemPlugins/SoftwareManager/imagewizard.xml
@@ -79,7 +79,7 @@ self.condition = (self.backuppath is False)
 	</step>
 
 	<step id="upgrade">
-		<text value="You need a PC connected to your %s %s. If you need further instructions, please visit the website http://www.open-plus.es.\nYour %s %s will now be halted. After you have performed the update instructions from the website, your new firmware will ask you to restore your settings." />
+		<text value="You need a PC connected to your %s %s. If you need further instructions, please visit the website http://www.opena.tv.\nYour %s %s will now be halted. After you have performed the update instructions from the website, your new firmware will ask you to restore your settings." />
 		<list>
 			<listentry caption="Yes, shut down now." step="shutdown" />
 			<listentry caption="No, do nothing." step="end" />
diff --git a/lib/python/Plugins/SystemPlugins/SoftwareManager/plugin.py b/lib/python/Plugins/SystemPlugins/SoftwareManager/plugin.py
index 9e6ace9..7eb65f7 100644
--- a/lib/python/Plugins/SystemPlugins/SoftwareManager/plugin.py
+++ b/lib/python/Plugins/SystemPlugins/SoftwareManager/plugin.py
@@ -21,7 +21,7 @@ from Components.Console import Console
 from Components.MultiContent import MultiContentEntryText, MultiContentEntryPixmapAlphaTest
 from Components.SelectionList import SelectionList
 from Components.PluginComponent import plugins
-from Plugins.Extensions.Openpanel.SoftwarePanel import SoftwarePanel
+from Plugins.Extensions.Infopanel.SoftwarePanel import SoftwarePanel
 from Components.PackageInfo import PackageInfoHandler
 from Components.Language import language
 from Components.AVSwitch import AVSwitch
@@ -179,9 +179,9 @@ class UpdatePluginMenu(Screen):
 			self.list.append(("install-extensions", _("Manage extensions"), _("\nManage extensions or plugins for your %s %s") % (getMachineBrand(), getMachineName()) + self.oktext, None))
 			self.list.append(("software-update", _("Software update"), _("\nOnline update of your %s %s software.") % (getMachineBrand(), getMachineName()) + self.oktext, None))
 			self.list.append(("software-restore", _("Software restore"), _("\nRestore your %s %s with a new firmware.") % (getMachineBrand(), getMachineName()) + self.oktext, None))
-			if not boxtype.startswith('az') and not boxtype in ('dm500hd','dm500hdv2','dm520','dm800','dm800se','dm800sev2','dm820','dm7020hd','dm7020hdv2','dm7080','dm8000') and not brandoem.startswith('cube') and not brandoem.startswith('wetek'):
+			if not boxtype.startswith('az') and not boxtype in ('dm500hd','dm500hdv2','dm520','dm800','dm800se','dm800sev2','dm820','dm7020hd','dm7020hdv2','dm7080','dm8000') and not brandoem.startswith('cube') and not brandoem.startswith('wetek') and not boxtype.startswith('alien'):
 				self.list.append(("flash-online", _("Flash Online"), _("\nFlash on the fly your %s %s.") % (getMachineBrand(), getMachineName()) + self.oktext, None))
-			if not boxtype.startswith('az') and not brandoem.startswith('cube') and not brandoem.startswith('wetek'):
+			if not boxtype.startswith('az') and not brandoem.startswith('cube') and not brandoem.startswith('wetek') and not boxtype.startswith('alien'):
 				self.list.append(("backup-image", _("Backup Image"), _("\nBackup your running %s %s image to HDD or USB.") % (getMachineBrand(), getMachineName()) + self.oktext, None))
 			self.list.append(("system-backup", _("Backup system settings"), _("\nBackup your %s %s settings.") % (getMachineBrand(), getMachineName()) + self.oktext + "\n\n" + self.infotext, None))
 			self.list.append(("system-restore",_("Restore system settings"), _("\nRestore your %s %s settings.") % (getMachineBrand(), getMachineName()) + self.oktext, None))
@@ -1601,20 +1601,20 @@ class UpdatePlugin(Screen):
 		# TODO: Use Twisted's URL fetcher, urlopen is evil. And it can
 		# run in parallel to the package update.
 		try:
-			urlOpenPlus = "http://feeds.open-plus.es/openplus"
-			d = urlopen(urlOpenPlus)
+			urlopenATV = "http://ampel.mynonpublic.com/Ampel/index.php"
+			d = urlopen(urlopenATV)
 			tmpStatus = d.read()
 			if (os.path.exists("/etc/.beta") and 'rot.png' in tmpStatus) or 'gelb.png' in tmpStatus:
-				message = _("Caution update not yet tested !!") + "\n" + _("Update at your own risk") + "\n\n" + _("For more information see http://www.open-plus.es") + "\n\n"# + _("Last Status Date") + ": "  + statusDate + "\n\n"
+				message = _("Caution update not yet tested !!") + "\n" + _("Update at your own risk") + "\n\n" + _("For more information see http://www.opena.tv") + "\n\n"# + _("Last Status Date") + ": "  + statusDate + "\n\n"
 				picon = MessageBox.TYPE_ERROR
 				default = False
 			elif 'rot.png' in tmpStatus:
-				message = _("Update is reported as faulty !!") + "\n" + _("Aborting updateprogress") + "\n\n" + _("For more information see http://www.open-plus.es")# + "\n\n" + _("Last Status Date") + ": " + statusDate
+				message = _("Update is reported as faulty !!") + "\n" + _("Aborting updateprogress") + "\n\n" + _("For more information see http://www.opena.tv")# + "\n\n" + _("Last Status Date") + ": " + statusDate
 				picon = MessageBox.TYPE_ERROR
 				default = False
 				doUpdate = False
 		except:
-			message = _("The status of the current update could not be checked because http://www.open-plus.es could not be reached for some reason") + "\n"
+			message = _("The status of the current update could not be checked because http://www.opena.tv could not be reached for some reason") + "\n"
 			picon = MessageBox.TYPE_ERROR
 			default = False
 		socket.setdefaulttimeout(currentTimeoutDefault)
diff --git a/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py b/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py
index d062ce3..599adec 100644
--- a/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py
+++ b/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py
@@ -17,6 +17,7 @@ class OverscanTestScreen(Screen):
 
 	def __init__(self, session, xres=1280, yres=720):
 		Screen.__init__(self, session)
+		self.setTitle(_("Overscan Test"))
 
 		self.xres, self.yres = getDesktop(0).size().width(), getDesktop(0).size().height()
 
@@ -58,6 +59,7 @@ class FullHDTestScreen(OverscanTestScreen):
 
 	def __init__(self, session):
 		OverscanTestScreen.__init__(self, session, 1920, 1080)
+		self.setTitle(_("FullHD Test"))
 
 		self["actions"] = NumberActionMap(["InputActions", "OkCancelActions"],
 		{
@@ -79,6 +81,7 @@ class VideoFinetune(Screen):
 
 	def __init__(self, session):
 		Screen.__init__(self, session)
+		self.setTitle(_("VideoFinetune"))
 		self.skinAttributes = None
 		self["Canvas"] = CanvasSource()
 
diff --git a/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py b/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py
index 8532d93..efeb48c 100644
--- a/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py
+++ b/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py
@@ -410,6 +410,7 @@ class Status:
 		data = { 'essid': False, 'frequency': False, 'accesspoint': False, 'bitrate': False, 'encryption': False, 'quality': False, 'signal': False }
 		for line in result.splitlines():
 			line = line.strip()
+			# print "[Wlan.py] line -->",line
 			if "ESSID" in line:
 				if "off/any" in line:
 					ssid = "off"
@@ -434,6 +435,8 @@ class Status:
 			if "Bit Rate" in line:
 				if "kb" in line:
 					br = line[line.index('Bit Rate')+9 :line.index(' kb/s')]
+				elif "Gb" in line:
+					br = line[line.index('Bit Rate')+9 :line.index(' Gb/s')]
 				else:
 					br = line[line.index('Bit Rate')+9 :line.index(' Mb/s')]
 				if br is not None:
diff --git a/lib/python/Screens/About.py b/lib/python/Screens/About.py
index 6d63630..3e13a93 100644
--- a/lib/python/Screens/About.py
+++ b/lib/python/Screens/About.py
@@ -8,6 +8,7 @@ from Components.NimManager import nimmanager
 from Components.About import about
 from Components.ScrollLabel import ScrollLabel
 from Components.Console import Console
+from Components.SystemInfo import SystemInfo
 from enigma import eTimer, getEnigmaVersionString
 from boxbranding import getBoxType, getMachineBuild, getMachineBrand, getMachineName, getImageVersion, getImageBuild, getDriverDate
 
@@ -19,6 +20,8 @@ from Tools.StbHardware import getFPVersion
 from os import path
 from re import search
 
+import time
+
 def parse_ipv4(ip):
 	ret = ""
 	idx = 0
@@ -51,9 +54,18 @@ def parseLines(filename):
 		print "[ERROR] failed to open file %s" % filename
 	return ret
 
+def MyDateConverter(StringDate):
+	## StringDate must be a string "YYYY-MM-DD"
+	try:
+		StringDate = StringDate.replace("-"," ")
+		StringDate = time.strftime(_("%Y-%m-%d"), time.strptime(StringDate, "%Y %m %d"))
+		return StringDate
+	except:
+		return _("unknown")
+
 def getAboutText():
 	AboutText = ""
-	AboutText += _("Model:\t%s %s\n") % (getMachineBrand(), getMachineName())
+	AboutText += _("Model:\t\t%s %s\n") % (getMachineBrand(), getMachineName())
 	AboutText += _("OEM Model:\t\t%s\n") % getMachineBuild()
 
 	bootloader = ""
@@ -64,18 +76,22 @@ def getAboutText():
 		AboutText += _("Bootloader:\t\t%s\n") % (bootloader)
 
 	if path.exists('/proc/stb/info/chipset'):
-		AboutText += _("Chipset:\t%s") % about.getChipSetString() + "\n"
+		AboutText += _("Chipset:\t\t%s") % about.getChipSetString() + "\n"
 
 	cpuMHz = ""
 	if getMachineBuild() in ('vusolo4k','vuultimo4k','vuzero4k'):
 		cpuMHz = "   (1,5 GHz)"
 	elif getMachineBuild() in ('formuler1tc','formuler1', 'triplex', 'tiviaraplus'):
 		cpuMHz = "   (1,3 GHz)"
-	elif getMachineBuild() in ('u5','u5pvr','h9'):
+	elif getMachineBuild() in ('u51','u5','u53','u52','u54','u5pvr','h9','h9combo','cc1','sf8008','sf8008s','hd60','i55plus','ustym4kpro','v8plus'):
 		cpuMHz = "   (1,6 GHz)"
 	elif getMachineBuild() in ('vuuno4kse','vuuno4k','dm900','dm920', 'gb7252', 'dags7252','xc7439','8100s'):
 		cpuMHz = "   (1,7 GHz)"
-	elif getMachineBuild() in ('sf5008','et13000','et1x000','hd52','hd51','sf4008','vs1500','h7'):
+	elif getMachineBuild() in ('alien5'):
+		cpuMHz = "   (2,0 GHz)"
+	elif getMachineBuild() in ('vuduo4k'):
+		cpuMHz = "   (2,1 GHz)"
+	elif getMachineBuild() in ('sf5008','et13000','et1x000','hd52','hd51','sf4008','vs1500','h7','osmio4k'):
 		try:
 			import binascii
 			f = open('/sys/firmware/devicetree/base/cpus/cpu@0/clock-frequency', 'rb')
@@ -99,8 +115,8 @@ def getAboutText():
 			except:
 				pass
 
-	AboutText += _("CPU:\t%s") % about.getCPUString() + cpuMHz + "\n"
-	AboutText += _("Cores:\t%s") % about.getCpuCoresString() + "\n"
+	AboutText += _("CPU:\t\t%s") % about.getCPUString() + cpuMHz + "\n"
+	AboutText += _("Cores:\t\t%s") % about.getCpuCoresString() + "\n"
 
 	imagestarted = ""
 	bootname = ''
@@ -108,40 +124,68 @@ def getAboutText():
 		f = open('/boot/bootname', 'r')
 		bootname = f.readline().split('=')[1]
 		f.close()
-
-	if path.exists('/boot/STARTUP'):
+	if getMachineBuild() in ('cc1','sf8008','sf8008s','ustym4kpro'):
+		if path.exists('/boot/STARTUP'):
+			f = open('/boot/STARTUP', 'r')
+			f.seek(5)
+			image = f.read(4)
+			if image == "emmc":
+				image = "1"
+			elif image == "usb0":
+				f.seek(13)
+				image = f.read(1)
+				if image == "1":
+					image = "2"
+				elif image == "3":
+					image = "3"
+				elif image == "5":
+					image = "4"
+				elif image == "7":
+					image = "5"
+			f.close()
+			if bootname: bootname = "   (%s)" %bootname 
+			AboutText += _("Selected Image:\t\t%s") % "STARTUP_" + image + bootname + "\n"
+	elif getMachineBuild() in ('osmio4k'):
+		if path.exists('/boot/STARTUP'):
+			f = open('/boot/STARTUP', 'r')
+			f.seek(38)
+			image = f.read(1) 
+			f.close()
+			if bootname: bootname = "   (%s)" %bootname 
+			AboutText += _("Selected Image:\t\t%s") % "STARTUP_" + image + bootname + "\n"
+	elif path.exists('/boot/STARTUP'):
 		f = open('/boot/STARTUP', 'r')
 		f.seek(22)
 		image = f.read(1) 
 		f.close()
 		if bootname: bootname = "   (%s)" %bootname 
-		AboutText += _("Selected Image:\t%s") % "STARTUP_" + image + bootname + "\n"
+		AboutText += _("Selected Image:\t\t%s") % "STARTUP_" + image + bootname + "\n"
 	elif path.exists('/boot/cmdline.txt'):
 		f = open('/boot/cmdline.txt', 'r')
 		f.seek(38)
 		image = f.read(1) 
 		f.close()
 		if bootname: bootname = "   (%s)" %bootname 
-		AboutText += _("Selected Image:\t%s") % "STARTUP_" + image + bootname + "\n"
+		AboutText += _("Selected Image:\t\t%s") % "STARTUP_" + image + bootname + "\n"
 
-	AboutText += _("Version:\t%s") % getImageVersion() + "\n"
-	AboutText += _("Build:\t%s") % getImageBuild() + "\n"
-	AboutText += _("Kernel:\t%s") % about.getKernelVersionString() + "\n"
+	AboutText += _("Version:\t\t%s") % getImageVersion() + "\n"
+	AboutText += _("Build:\t\t%s") % getImageBuild() + "\n"
+	AboutText += _("Kernel:\t\t%s") % about.getKernelVersionString() + "\n"
 
 	string = getDriverDate()
 	year = string[0:4]
 	month = string[4:6]
 	day = string[6:8]
 	driversdate = '-'.join((year, month, day))
-	AboutText += _("Drivers:\t%s") % driversdate + "\n"
+	AboutText += _("Drivers:\t\t%s") % MyDateConverter(driversdate) + "\n"
 
-	AboutText += _("GStreamer:\t%s") % about.getGStreamerVersionString() + "\n"
-	AboutText += _("Python:\t%s") % about.getPythonVersionString() + "\n"
+	AboutText += _("GStreamer:\t\t%s") % about.getGStreamerVersionString() + "\n"
+	AboutText += _("Python:\t\t%s") % about.getPythonVersionString() + "\n"
 
-	if getMachineBuild() not in ('h9','vuzero4k','sf5008','et13000','et1x000','hd51','hd52','vusolo4k','vuuno4k','vuuno4kse','vuultimo4k','sf4008','dm820','dm7080','dm900','dm920', 'gb7252', 'dags7252', 'vs1500','h7','xc7439','8100s','u5','u5pvr'):
-		AboutText += _("Installed:\t%s") % about.getFlashDateString() + "\n"
+	if getMachineBuild() not in ('vuduo4k','v8plus','ustym4kpro','hd60','i55plus','osmio4k','h9','h9combo','vuzero4k','sf5008','et13000','et1x000','hd51','hd52','vusolo4k','vuuno4k','vuuno4kse','vuultimo4k','sf4008','dm820','dm7080','dm900','dm920', 'gb7252', 'dags7252', 'vs1500','h7','xc7439','8100s','u5','u5pvr','u52','u53','u54','u51','cc1','sf8008','sf8008s'):
+		AboutText += _("Installed:\t\t%s") % about.getFlashDateString() + "\n"
 
-	AboutText += _("Last update:\t%s") % getEnigmaVersionString() + "\n"
+	AboutText += _("Last update:\t\t%s") % MyDateConverter(getEnigmaVersionString()) + "\n"
 
 	fp_version = getFPVersion()
 	if fp_version is None:
@@ -172,6 +216,10 @@ def getAboutText():
 		f = open('/proc/stb/fp/temp_sensor_avs', 'r')
 		tempinfo = f.read()
 		f.close()
+	elif path.exists('/proc/stb/power/avs'):
+		f = open('/proc/stb/power/avs', 'r')
+		tempinfo = f.read()
+		f.close()
 	elif path.exists('/sys/devices/virtual/thermal/thermal_zone0/temp'):
 		try:
 			f = open('/sys/devices/virtual/thermal/thermal_zone0/temp', 'r')
@@ -180,6 +228,16 @@ def getAboutText():
 			f.close()
 		except:
 			tempinfo = ""
+	elif path.exists('/proc/hisi/msp/pm_cpu'):
+		try:
+			for line in open('/proc/hisi/msp/pm_cpu').readlines():
+				line = [x.strip() for x in line.strip().split(":")]
+				if line[0] in ("Tsensor"):
+					temp = line[1].split("=")
+					temp = line[1].split(" ")
+					tempinfo = temp[2]
+		except:
+			tempinfo = ""
 	if tempinfo and int(tempinfo.replace('\n', '')) > 0:
 		mark = str('\xc2\xb0')
 		AboutText += _("Processor temperature:\t%s") % tempinfo.replace('\n', '').replace(' ','') + mark + "C\n"
@@ -194,6 +252,7 @@ class About(Screen):
 		self.skinName = ["AboutOE","About"]
 		self.populate()
 
+		self["key_red"] = Button(_("Exit"))
 		self["key_green"] = Button(_("Translations"))
 		self["actions"] = ActionMap(["SetupActions", "ColorActions", "TimerEditActions"],
 			{
@@ -202,21 +261,150 @@ class About(Screen):
 				"log": self.showAboutReleaseNotes,
 				"up": self.pageUp,
 				"down": self.pageDown,
+				"red": self.close,
 				"green": self.showTranslationInfo,
+				"0": self.showID,
 			})
 
 
 	def populate(self):
-		self["lab1"] = StaticText(_("OpenPlus"))
-		self["lab2"] = StaticText(_("By OpenPlus Image Team"))
-		model = None
-		self["lab3"] = StaticText(_("Support at") + " www.open-plus.es")
-		AboutText = getAboutText()[0]
-		self["AboutScrollLabel"] = ScrollLabel(AboutText)
+		if isVTISkin:
+			self["EnigmaVersion"] = StaticText(_("Version") + ": " + about.getEnigmaVersionString())
+			self["ImageVersion"] = StaticText(_("Image") + ": " + about.getImageVersionString())
+
+			self["TunerHeader"] = StaticText(_("Detected NIMs:"))
+
+			fp_version = getFPVersion()
+			if fp_version is None:
+				fp_version = ""
+			else:
+				fp_version = _("Frontprocessor version: %d") % fp_version
+
+			self["FPVersion"] = StaticText(fp_version)
+
+			nims = nimmanager.nimList()
+			self.tuner_list = []
+			if len(nims) <= 4 :
+				for count in (0, 1, 2, 3, 4, 5, 6, 7):
+					if count < len(nims):
+						self["Tuner" + str(count)] = StaticText(nims[count])
+						self.tuner_list.append((nims[count] + "\n"))
+					else:
+						self["Tuner" + str(count)] = StaticText("")
+			else:
+				desc_list = []
+				count = 0
+				cur_idx = -1
+				while count < len(nims):
+					data = nims[count].split(":")
+					idx = data[0].strip('Tuner').strip()
+					desc = data[1].strip()
+					if desc_list and desc_list[cur_idx]['desc'] == desc:
+						desc_list[cur_idx]['end'] = idx
+					else:
+						desc_list.append({'desc' : desc, 'start' : idx, 'end' : idx})
+						cur_idx += 1
+					count += 1
+
+				for count in (0, 1, 2, 3, 4, 5, 6, 7):
+					if count < len(desc_list):
+						if desc_list[count]['start'] == desc_list[count]['end']:
+							text = "Tuner %s: %s" % (desc_list[count]['start'], desc_list[count]['desc'])
+						else:
+							text = "Tuner %s-%s: %s" % (desc_list[count]['start'], desc_list[count]['end'], desc_list[count]['desc'])
+					else:
+						text = ""
+
+					self["Tuner" + str(count)] = StaticText(text)
+					if text != "":
+						self.tuner_list.append(text + "\n")
+
+			self["HDDHeader"] = StaticText(_("Detected HDD:"))
+			hddlist = harddiskmanager.HDDList()
+			hdd = hddlist and hddlist[0][1] or None
+			if hdd is not None and hdd.model() != "":
+				self["hddA"] = StaticText(_("%s\n(%s, %d MB free)") % (hdd.model(), hdd.capacity(),hdd.free()))
+			else:
+				self["hddA"] = StaticText(_("none"))
+
+
+			self.enigma2_version = _("Version") + ": " + about.getEnigmaVersionString()
+			self.image_version = _("Image") + ": " + about.getImageVersionString()
+			cpu_info = parseLines("/proc/cpuinfo")
+			cpu_name = "N/A"
+			for line in cpu_info:
+				if line.find('model') != -1:
+					cpu_name = line.split(':')
+					if len(cpu_name) >= 2:
+						cpu_name = cpu_name[1].strip()
+					break
+
+			self.cpu = _("CPU") + ": " + cpu_name
+			self.chipset = _("Chipset") + ": " + parseFile("/proc/stb/info/chipset")
+			self.tuner_header = _("Detected NIMs:")
+			self.hdd_header = _("Detected HDD:")
+			self.hdd_list = []
+			if len(hddlist):
+				for hddX in hddlist:
+					hdd = hddX[1]
+					if hdd.model() != "":
+						self.hdd_list.append((hdd.model() + "\n   %.2f GB - %.2f GB" % (hdd.diskSize()/1000.0, hdd.free()/1000.0) + " " + _("free") + "\n\n"))
+
+			ifaces = iNetwork.getConfiguredAdapters()
+			iface_list = []
+			for iface in ifaces:
+				iface_list.append((_("Interface") + " : " + iNetwork.getAdapterName(iface) + " ("+ iNetwork.getFriendlyAdapterName(iface) + ")\n"))
+				iface_list.append((_("IP") + " : " + parse_ipv4(iNetwork.getAdapterAttribute(iface, "ip")) + "\n"))
+				iface_list.append((_("Netmask") + " : " + parse_ipv4(iNetwork.getAdapterAttribute(iface, "netmask")) + "\n"))
+				iface_list.append((_("Gateway") + " : " + parse_ipv4(iNetwork.getAdapterAttribute(iface, "gateway")) + "\n"))
+				if iNetwork.getAdapterAttribute(iface, "dhcp"):
+					iface_list.append((_("DHCP") + " : " + _("Yes") + "\n"))
+				else:
+					iface_list.append((_("DHCP") + " : " + _("No") + "\n"))
+				iface_list.append((_("MAC") + " : " + iNetwork.getAdapterAttribute(iface, "mac") + "\n"))
+				iface_list.append(("\n"))
+
+			my_txt = self.enigma2_version + "\n"
+			my_txt += self.image_version + "\n"
+			my_txt += "\n"
+			my_txt += self.cpu + "\n"
+			my_txt += self.chipset + "\n"
+			my_txt += "\n"
+			my_txt += self.tuner_header + "\n"
+			for x in self.tuner_list:
+				my_txt += "   " + x
+			my_txt += "\n"
+			my_txt += _("Network") + ":\n"
+			for x in iface_list:
+				my_txt += "   " + x
+			my_txt += self.hdd_header + "\n"
+			for x in self.hdd_list:
+				my_txt += "   " + x
+			my_txt += "\n"
+
+			self["FullAbout"] = ScrollLabel(my_txt)
+		else:
+			self["lab1"] = StaticText(_("openATV"))
+			self["lab2"] = StaticText(_("By openATV Image Team"))
+			self["lab3"] = StaticText(_("Support at") + " www.opena.tv")
+			model = None
+			AboutText = getAboutText()[0]
+			self["AboutScrollLabel"] = ScrollLabel(AboutText)
 
 	def populate_vti(self):
 		pass
 
+	def showID(self):
+		if SystemInfo["HaveID"]:
+			try:
+				f = open("/etc/.id")
+				id = f.read()[:-1].split('=')
+				f.close()
+				from Screens.MessageBox import MessageBox
+				self.session.open(MessageBox,id[1], type = MessageBox.TYPE_INFO)
+			except:
+				pass
+
 	def showTranslationInfo(self):
 		self.session.open(TranslationInfo)
 
@@ -663,7 +851,7 @@ class SystemNetworkInfo(Screen):
 class AboutSummary(Screen):
 	def __init__(self, session, parent):
 		Screen.__init__(self, session, parent=parent)
-		self["selected"] = StaticText("OpenPlus:" + getImageVersion())
+		self["selected"] = StaticText("openATV:" + getImageVersion())
 
 		AboutText = getAboutText()[1]
 
@@ -715,7 +903,7 @@ class ViewGitLog(Screen):
 		fd = open('/etc/' + self.logtype + '-git.log', 'r')
 		releasenotes = fd.read()
 		fd.close()
-		releasenotes = releasenotes.replace('\nopenplus: build', "\n\nopenplus: build")
+		releasenotes = releasenotes.replace('\nopenatv: build', "\n\nopenatv: build")
 		self["text"].setText(releasenotes)
 		summarytext = releasenotes
 		try:
diff --git a/lib/python/Screens/AudioSelection.py b/lib/python/Screens/AudioSelection.py
index 7495ba6..91071f4 100644
--- a/lib/python/Screens/AudioSelection.py
+++ b/lib/python/Screens/AudioSelection.py
@@ -13,6 +13,7 @@ from Components.Sources.List import List
 from Components.Sources.Boolean import Boolean
 from Components.SystemInfo import SystemInfo
 from Components.VolumeControl import VolumeControl
+from boxbranding import getBoxType
 
 from enigma import iPlayableService, eTimer, eSize
 
@@ -108,7 +109,11 @@ class AudioSelection(Screen, ConfigListScreen):
 			n = audio and audio.getNumberOfTracks() or 0
 
 			if SystemInfo["CanDownmixAC3"]:
-				self.settings.downmix_ac3 = ConfigOnOff(default=config.av.downmix_ac3.value)
+				if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
+					choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI"))]
+					self.settings.downmix_ac3 = ConfigSelection(choices = choice_list, default=config.av.downmix_ac3.value)
+				else:
+					self.settings.downmix_ac3 = ConfigOnOff(default=config.av.downmix_ac3.value)
 				self.settings.downmix_ac3.addNotifier(self.changeAC3Downmix, initial_call = False)
 				conflist.append(getConfigListEntry(_("AC3 downmix"), self.settings.downmix_ac3, None))
 
@@ -118,27 +123,66 @@ class AudioSelection(Screen, ConfigListScreen):
 				conflist.append(getConfigListEntry(_("DTS downmix"), self.settings.downmix_dts, None))
 
 			if SystemInfo["CanDownmixAAC"]:
-				self.settings.downmix_aac = ConfigOnOff(default=config.av.downmix_aac.value)
+				if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
+					choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI"))]
+					self.settings.downmix_aac = ConfigSelection(choices = choice_list, default=config.av.downmix_aac.value)
+				elif getBoxType() in ('gbquad4k', 'gbue4k'):
+					choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("force_ac3", _("convert to AC3")), ("force_dts",  _("convert to DTS")), ("use_hdmi_cacenter",  _("use_hdmi_cacenter")), ("wide",  _("wide")), ("extrawide",  _("extrawide"))]
+					self.settings.downmix_aac = ConfigSelection(choices = choice_list, default=config.av.downmix_aac.value)
+				else:
+					self.settings.downmix_aac = ConfigOnOff(default=config.av.downmix_aac.value)
 				self.settings.downmix_aac.addNotifier(self.changeAACDownmix, initial_call = False)
 				conflist.append(getConfigListEntry(_("AAC downmix"), self.settings.downmix_aac, None))
 
+			if SystemInfo["CanDownmixAACPlus"]:
+				choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("force_ac3", _("convert to AC3")), ("force_dts",  _("convert to DTS")), ("use_hdmi_cacenter",  _("use_hdmi_cacenter")), ("wide",  _("wide")), ("extrawide",  _("extrawide"))]
+				self.settings.downmix_aacplus = ConfigSelection(choices = choice_list, default=config.av.downmix_aacplus.value)
+				self.settings.downmix_aacplus.addNotifier(self.changeAACDownmixPlus, initial_call = False)
+				conflist.append(getConfigListEntry(_("AAC Plus downmix"), self.settings.downmix_aacplus, None))
+
 			if SystemInfo["CanAACTranscode"]:
 				choice_list = [("off", _("off")), ("ac3", _("AC3")), ("dts", _("DTS"))]
-				self.settings.transcodeaac = ConfigSelection(choices = choice_list, default = "off")
+				self.settings.transcodeaac = ConfigSelection(choices = choice_list, default = config.av.transcodeaac.value)
 				self.settings.transcodeaac.addNotifier(self.setAACTranscode, initial_call = False)
 				conflist.append(getConfigListEntry(_("AAC transcoding"), self.settings.transcodeaac, None))
 
 			if SystemInfo["CanAC3plusTranscode"]:
-				choice_list = [("use_hdmi_caps", _("controlled by HDMI")), ("force_ac3", _("always"))]
-				self.settings.transcodeac3plus = ConfigSelection(choices = choice_list, default = "use_hdmi_caps")
+				if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
+					choice_list = [("use_hdmi_caps", _("controlled by HDMI")), ("force_ac3", _("convert to AC3")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI")), ("force_ddp",  _("force AC3plus"))]
+					self.settings.transcodeac3plus = ConfigSelection(choices = choice_list, default = config.av.transcodeac3plus.value)
+				elif getBoxType() in ('gbquad4k', 'gbue4k'):
+					choice_list = [("downmix", _("Downmix")), ("passthrough", _("Passthrough")), ("force_ac3", _("convert to AC3")), ("multichannel",  _("convert to multi-channel PCM")), ("force_dts",  _("convert to DTS"))]
+					self.settings.transcodeac3plus = ConfigSelection(choices = choice_list, default = config.av.transcodeac3plus.value)
+				else:
+					choice_list = [("use_hdmi_caps", _("controlled by HDMI")), ("force_ac3", _("convert to AC3"))]
+				self.settings.transcodeac3plus = ConfigSelection(choices = choice_list, default = config.av.transcodeac3plus.value)
 				self.settings.transcodeac3plus.addNotifier(self.setAC3plusTranscode, initial_call = False)
 				conflist.append(getConfigListEntry(_("AC3plus transcoding"), self.settings.transcodeac3plus, None))
 
 			if SystemInfo["CanPcmMultichannel"]:
-				self.settings.pcm_multichannel = ConfigOnOff(default=config.av.pcm_multichannel.value)
+				if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
+					choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI"))]
+					self.settings.pcm_multichannel = ConfigSelection(choices = choice_list, default = config.av.pcm_multichannel.value)
+				else:
+					self.settings.pcm_multichannel = ConfigOnOff(default=config.av.pcm_multichannel.value)
 				self.settings.pcm_multichannel.addNotifier(self.changePCMMultichannel, initial_call = False)
 				conflist.append(getConfigListEntry(_("PCM Multichannel"), self.settings.pcm_multichannel, None))
 
+			if SystemInfo["CanDTSHD"]:
+				if getBoxType() in ("dm7080" , "dm820"):
+					choice_list = [("use_hdmi_caps",  _("controlled by HDMI")), ("force_dts", _("convert to DTS"))]
+				else:
+					choice_list = [("downmix",  _("Downmix")), ("force_dts", _("convert to DTS")), ("use_hdmi_caps",  _("controlled by HDMI")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI"))]
+				self.settings.dtshd = ConfigSelection(choices = choice_list, default = config.av.dtshd.value)
+				self.settings.dtshd.addNotifier(self.setDTSHD, initial_call = False)
+				conflist.append(getConfigListEntry(_("DTS HD downmix"), self.settings.dtshd, None))
+
+			if SystemInfo["CanWMAPRO"]:
+				choice_list = [("downmix",  _("Downmix")), ("passthrough", _("Passthrough")), ("multichannel",  _("convert to multi-channel PCM")), ("hdmi_best",  _("use best / controlled by HDMI"))]
+				self.settings.wmapro = ConfigSelection(choices = choice_list, default = config.av.wmapro.value)
+				self.settings.wmapro.addNotifier(self.setWMAPro, initial_call = False)
+				conflist.append(getConfigListEntry(_("WMA Pro downmix"), self.settings.wmapro, None))
+
 			if n > 0:
 				self.audioChannel = service.audioChannel()
 				if self.audioChannel:
@@ -302,7 +346,6 @@ class AudioSelection(Screen, ConfigListScreen):
 		if surround_3d.value:
 			config.av.surround_3d.value = surround_3d.value
 		config.av.surround_3d.save()
-		self.fillList()
 
 	def change3DSurroundSpeaker(self, surround_3d_speaker):
 		if surround_3d_speaker.value:
@@ -315,36 +358,57 @@ class AudioSelection(Screen, ConfigListScreen):
 		config.av.autovolume.save()
 
 	def changeAC3Downmix(self, downmix):
-		if downmix.value:
-			config.av.downmix_ac3.setValue(True)
-			if SystemInfo["supportPcmMultichannel"]:
-				config.av.pcm_multichannel.setValue(False)
+		if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
+			config.av.downmix_ac3.setValue(downmix.value)
 		else:
-			config.av.downmix_ac3.setValue(False)
+			if downmix.value:
+				config.av.downmix_ac3.setValue(True)
+				if SystemInfo["supportPcmMultichannel"]:
+					config.av.pcm_multichannel.setValue(False)
+			else:
+				config.av.downmix_ac3.setValue(False)
 		config.av.downmix_ac3.save()
 		if SystemInfo["supportPcmMultichannel"]:
 			config.av.pcm_multichannel.save()
 		self.fillList()
 
 	def changePCMMultichannel(self, multichan):
-		if multichan.value:
-			config.av.pcm_multichannel.setValue(True)
+		if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800'):
+			config.av.pcm_multichannel.setValue(multichan.value)
 		else:
-			config.av.pcm_multichannel.setValue(False)
+			if multichan.value:
+				config.av.pcm_multichannel.setValue(True)
+			else:
+				config.av.pcm_multichannel.setValue(False)
 		config.av.pcm_multichannel.save()
 		self.fillList()
 
 	def changeAACDownmix(self, downmix):
-		if downmix.value:
-			config.av.downmix_aac.setValue(True)
+		if getBoxType() in ('dm900', 'dm920', 'dm7080', 'dm800','gbquad4k', 'gbue4k'):
+			config.av.downmix_aac.setValue(downmix.value)
 		else:
-			config.av.downmix_aac.setValue(False)
+			if downmix.value:
+				config.av.downmix_aac.setValue(True)
+			else:
+				config.av.downmix_aac.setValue(False)
 		config.av.downmix_aac.save()
 
+	def changeAACDownmixPlus(self, downmix):
+		config.av.downmix_aacplus.setValue(downmix.value)
+		config.av.downmix_aacplus.save()
+
 	def setAC3plusTranscode(self, transcode):
-		config.av.transcodeac3plus.setValue(transcode)
+		config.av.transcodeac3plus.setValue(transcode.value)
 		config.av.transcodeac3plus.save()
 
+	def setWMAPro(self, downmix):
+		config.av.wmapro.setValue(downmix.value)
+		config.av.wmapro.save()
+
+	def setDTSHD(self, downmix):
+		config.av.dtshd.setValue(downmix.value)
+		config.av.dtshd.save()
+
 	def changeDTSDownmix(self, downmix):
 		if downmix.value:
 			config.av.downmix_dts.setValue(True)
diff --git a/lib/python/Screens/AutoDiseqc.py b/lib/python/Screens/AutoDiseqc.py
index c344ef1..05a92b0 100644
--- a/lib/python/Screens/AutoDiseqc.py
+++ b/lib/python/Screens/AutoDiseqc.py
@@ -21,7 +21,9 @@ class AutoDiseqc(Screen, ConfigListScreen):
 		eDVBFrontendParametersSatellite.Inversion_Off, 192, \
 		eDVBFrontendParametersSatellite.System_DVB_S, eDVBFrontendParametersSatellite.Modulation_Auto, \
 		eDVBFrontendParametersSatellite.RollOff_auto, eDVBFrontendParametersSatellite.Pilot_Unknown, \
-		-1, 0, 0,
+		eDVBFrontendParametersSatellite.No_Stream_Id_Filter,
+		eDVBFrontendParametersSatellite.PLS_Gold,
+		0, # default gold PLS code
 		1079, 1, _("Astra 1 19.2e")),
 
 		# astra 235 astra ses
@@ -30,7 +32,9 @@ class AutoDiseqc(Screen, ConfigListScreen):
 		eDVBFrontendParametersSatellite.Inversion_Off, 235, \
 		eDVBFrontendParametersSatellite.System_DVB_S, eDVBFrontendParametersSatellite.Modulation_Auto, \
 		eDVBFrontendParametersSatellite.RollOff_auto, eDVBFrontendParametersSatellite.Pilot_Unknown, \
-		-1, 0, 0,
+		eDVBFrontendParametersSatellite.No_Stream_Id_Filter,
+		eDVBFrontendParametersSatellite.PLS_Gold,
+		0, # default gold PLS code
 		3224, 3, _("Astra 3 23.5e")),
 
 		# astra 282 bbc
@@ -39,7 +43,9 @@ class AutoDiseqc(Screen, ConfigListScreen):
 		eDVBFrontendParametersSatellite.Inversion_Off, 282, \
 		eDVBFrontendParametersSatellite.System_DVB_S, eDVBFrontendParametersSatellite.Modulation_Auto, \
 		eDVBFrontendParametersSatellite.RollOff_auto, eDVBFrontendParametersSatellite.Pilot_Unknown, \
-		-1, 0, 0,
+		eDVBFrontendParametersSatellite.No_Stream_Id_Filter,
+		eDVBFrontendParametersSatellite.PLS_Gold,
+		0, # default gold PLS code
 		2045, 2, _("Astra 2 28.2e")),
 
 		# hotbird 130 rai
@@ -48,7 +54,9 @@ class AutoDiseqc(Screen, ConfigListScreen):
 		eDVBFrontendParametersSatellite.Inversion_Off, 130, \
 		eDVBFrontendParametersSatellite.System_DVB_S, eDVBFrontendParametersSatellite.Modulation_Auto, \
 		eDVBFrontendParametersSatellite.RollOff_auto, eDVBFrontendParametersSatellite.Pilot_Unknown, \
-		-1, 0, 0,
+		eDVBFrontendParametersSatellite.No_Stream_Id_Filter,
+		eDVBFrontendParametersSatellite.PLS_Gold,
+		0, # default gold PLS code
 		12400, 318, _("Hotbird 13.0e")),
 
 		# hispasat 300 tsa
@@ -57,7 +65,9 @@ class AutoDiseqc(Screen, ConfigListScreen):
 		eDVBFrontendParametersSatellite.Inversion_Off, 3300, \
 		eDVBFrontendParametersSatellite.System_DVB_S, eDVBFrontendParametersSatellite.Modulation_Auto, \
 		eDVBFrontendParametersSatellite.RollOff_auto, eDVBFrontendParametersSatellite.Pilot_Unknown, \
-                -1, 0, 0,
+		eDVBFrontendParametersSatellite.No_Stream_Id_Filter,
+		eDVBFrontendParametersSatellite.PLS_Gold,
+		0, # default gold PLS code
 		1388, 1388, _("Hispasat 30.0w")),
 	]
 
diff --git a/lib/python/Screens/ButtonSetup.py b/lib/python/Screens/ButtonSetup.py
index 5b0df21..ba3dfbb 100644
--- a/lib/python/Screens/ButtonSetup.py
+++ b/lib/python/Screens/ButtonSetup.py
@@ -13,6 +13,7 @@ from Tools.BoundFunction import boundFunction
 from ServiceReference import ServiceReference
 from enigma import eServiceReference, eActionMap
 from Components.Label import Label
+from boxbranding import getHaveHDMIinHD, getHaveHDMIinFHD, getHaveCI
 import os
 
 def getButtonSetupKeys():
@@ -21,7 +22,7 @@ def getButtonSetupKeys():
 		(_("Green"), "green", ""),
 		(_("Green long"), "green_long", ""),
 		(_("Yellow"), "yellow", ""),
-		(_("Yellow long"), "yellow_long", "Plugins/Extensions/OPWeather/1"),
+		(_("Yellow long"), "yellow_long", ""),
 		(_("Blue"), "blue", ""),
 		(_("Blue long"), "blue_long", ""),
 		(_("Info (EPG)"), "info", "Infobar/InfoPressed/1"),
@@ -40,6 +41,8 @@ def getButtonSetupKeys():
 		(_("PageDown long"), "pagedown_long", ""),
 		(_("Channel up"), "channelup", ""),
 		(_("Channel down"), "channeldown", ""),
+		(_("EJECTCD"), "ejectcd", ""),
+		(_("EJECTCD long"), "ejectcd_long", ""),
 		(_("TV"), "showTv", ""),
 		(_("Radio"), "radio", ""),
 		(_("Radio long"), "radio_long", ""),
@@ -64,6 +67,8 @@ def getButtonSetupKeys():
 		(_("Media long"), "media_long", ""),
 		(_("Open"), "open", ""),
 		(_("Open long"), "open_long", ""),
+		(_("Option"), "option", ""),
+		(_("Option long"), "option_long", ""),
 		(_("Www"), "www", ""),
 		(_("Www long"), "www_long", ""),
 		(_("Directory"), "directory", ""),
@@ -99,13 +104,15 @@ def getButtonSetupKeys():
 		(_("Prevsong long"), "prevsong_long", ""),
 		(_("Program"), "prog", ""),
 		(_("Program long"), "prog_long", ""),
-		(_("Timeshift"), "timeshift", ""),
+		(_("Time"), "time", ""),
+		(_("Time long"), "time_long", ""),
 		(_("Homepage"), "homep", ""),
 		(_("Homepage long"), "homep_long", ""),
 		(_("Search/WEB"), "search", ""),
 		(_("Search/WEB long"), "search_long", ""),
 		(_("Slow"), "slow", ""),
 		(_("Mark/Portal/Playlist"), "mark", ""),
+		(_("Mark/Portal/Playlist long"), "mark_long", ""),
 		(_("Sleep"), "sleep", ""),
 		(_("Sleep long"), "sleep_long", ""),
 		(_("Power"), "power", ""),
@@ -148,22 +155,23 @@ def getButtonSetupFunctions():
 	pluginlist.sort(key=lambda p: p.name)
 	for plugin in pluginlist:
 		if plugin.name not in twinPlugins and plugin.path and 'selectedevent' not in plugin.__call__.func_code.co_varnames:
-			if twinPaths.has_key(plugin.path[24:]):
-				twinPaths[plugin.path[24:]] += 1
+			if twinPaths.has_key(plugin.path[plugin.path.rfind("Plugins"):]):
+				twinPaths[plugin.path[plugin.path.rfind("Plugins"):]] += 1
 			else:
-				twinPaths[plugin.path[24:]] = 1
-			ButtonSetupFunctions.append((plugin.name, plugin.path[24:] + "/" + str(twinPaths[plugin.path[24:]]) , "EPG"))
+				twinPaths[plugin.path[plugin.path.rfind("Plugins"):]] = 1
+			ButtonSetupFunctions.append((plugin.name, plugin.path[plugin.path.rfind("Plugins"):] + "/" + str(twinPaths[plugin.path[plugin.path.rfind("Plugins"):]]) , "EPG"))
 			twinPlugins.append(plugin.name)
 	pluginlist = plugins.getPlugins([PluginDescriptor.WHERE_PLUGINMENU, PluginDescriptor.WHERE_EXTENSIONSMENU, PluginDescriptor.WHERE_EVENTINFO])
 	pluginlist.sort(key=lambda p: p.name)
 	for plugin in pluginlist:
 		if plugin.name not in twinPlugins and plugin.path:
-			if twinPaths.has_key(plugin.path[24:]):
-				twinPaths[plugin.path[24:]] += 1
+			if twinPaths.has_key(plugin.path[plugin.path.rfind("Plugins"):]):
+				twinPaths[plugin.path[plugin.path.rfind("Plugins"):]] += 1
 			else:
-				twinPaths[plugin.path[24:]] = 1
-			ButtonSetupFunctions.append((plugin.name, plugin.path[24:] + "/" + str(twinPaths[plugin.path[24:]]) , "Plugins"))
+				twinPaths[plugin.path[plugin.path.rfind("Plugins"):]] = 1
+			ButtonSetupFunctions.append((plugin.name, plugin.path[plugin.path.rfind("Plugins"):] + "/" + str(twinPaths[plugin.path[plugin.path.rfind("Plugins"):]]) , "Plugins"))
 			twinPlugins.append(plugin.name)
+	ButtonSetupFunctions.append((_("Show vertical Program Guide"), "Infobar/openVerticalEPG", "EPG"))
 	ButtonSetupFunctions.append((_("Show graphical multi EPG"), "Infobar/openGraphEPG", "EPG"))
 	ButtonSetupFunctions.append((_("Main menu"), "Infobar/mainMenu", "InfoBar"))
 	ButtonSetupFunctions.append((_("Show help"), "Infobar/showHelp", "InfoBar"))
@@ -207,7 +215,7 @@ def getButtonSetupFunctions():
 		ButtonSetupFunctions.append((_("Move PIP"), "Infobar/movePiP", "InfoBar"))
 		ButtonSetupFunctions.append((_("Toggle PIPzap"), "Infobar/togglePipzap", "InfoBar"))
 	ButtonSetupFunctions.append((_("Activate HbbTV (Redbutton)"), "Infobar/activateRedButton", "InfoBar"))
-	if SystemInfo["HDMIin"]:
+	if getHaveHDMIinHD() in ('True') or getHaveHDMIinFHD() in ('True'):
 		ButtonSetupFunctions.append((_("Toggle HDMI-In full screen"), "Infobar/HDMIInFull", "InfoBar"))
 		ButtonSetupFunctions.append((_("Toggle HDMI-In PiP"), "Infobar/HDMIInPiP", "InfoBar"))
 	if SystemInfo["LcdLiveTV"]:
@@ -216,9 +224,16 @@ def getButtonSetupFunctions():
 		ButtonSetupFunctions.append((_("MultiBoot Selector"), "Module/Screens.MultiBootStartup/MultiBootStartup", "InfoBar"))
 	if SystemInfo["HaveMultiBootGB"]:
 		ButtonSetupFunctions.append((_("MultiBoot Selector"), "Module/Screens.MultiBootStartupGB/MultiBootStartup", "InfoBar"))
+	if SystemInfo["HaveMultiBootCY"]:
+		ButtonSetupFunctions.append((_("MultiBoot Selector"), "Module/Screens.MultiBootStartupCY/MultiBootStartup", "InfoBar"))
+	if SystemInfo["HaveMultiBootDS"]:
+		ButtonSetupFunctions.append((_("MultiBoot Selector"), "Module/Screens.MultiBootStartupDS/MultiBootStartup", "InfoBar"))
+	if SystemInfo["HaveMultiBootOS"]:
+		ButtonSetupFunctions.append((_("MultiBoot Selector"), "Module/Screens.MultiBootStartupOS/MultiBootStartup", "InfoBar"))
 	ButtonSetupFunctions.append((_("Hotkey Setup"), "Module/Screens.ButtonSetup/ButtonSetup", "Setup"))
 	ButtonSetupFunctions.append((_("Software update"), "Module/Screens.SoftwareUpdate/UpdatePlugin", "Setup"))
-	ButtonSetupFunctions.append((_("CI (Common Interface) Setup"), "Module/Screens.Ci/CiSelection", "Setup"))
+	if getHaveCI() in ('True'):
+		ButtonSetupFunctions.append((_("CI (Common Interface) Setup"), "Module/Screens.Ci/CiSelection", "Setup"))
 	ButtonSetupFunctions.append((_("Videosetup"), "Module/Screens.VideoMode/VideoSetup", "Setup"))
 	ButtonSetupFunctions.append((_("Tuner Configuration"), "Module/Screens.Satconfig/NimSelection", "Scanning"))
 	ButtonSetupFunctions.append((_("Manual Scan"), "Module/Screens.ScanSetup/ScanSetup", "Scanning"))
@@ -227,10 +242,12 @@ def getButtonSetupFunctions():
 		ButtonSetupFunctions.append((plugin[0], "MenuPlugin/scan/" + plugin[2], "Scanning"))
 	ButtonSetupFunctions.append((_("Network setup"), "Module/Screens.NetworkSetup/NetworkAdapterSelection", "Setup"))
 	ButtonSetupFunctions.append((_("Network menu"), "Infobar/showNetworkMounts", "Setup"))
+	ButtonSetupFunctions.append((_("VPN"), "Module/Screens.NetworkSetup/NetworkOpenvpn", "Setup"))
 	ButtonSetupFunctions.append((_("Plugin Browser"), "Module/Screens.PluginBrowser/PluginBrowser", "Setup"))
 	ButtonSetupFunctions.append((_("Channel Info"), "Module/Screens.ServiceInfo/ServiceInfo", "Setup"))
 	ButtonSetupFunctions.append((_("SkinSelector"), "Module/Screens.SkinSelector/SkinSelector", "Setup"))
-	ButtonSetupFunctions.append((_("LCD SkinSelector"), "Module/Screens.SkinSelector/LcdSkinSelector", "Setup"))
+	if SystemInfo["LCDSKINSetup"]:
+		ButtonSetupFunctions.append((_("LCD SkinSelector"), "Module/Screens.SkinSelector/LcdSkinSelector", "Setup"))
 	ButtonSetupFunctions.append((_("Timer"), "Module/Screens.TimerEdit/TimerEditList", "Setup"))
 	ButtonSetupFunctions.append((_("Open AutoTimer"), "Infobar/showAutoTimerList", "Setup"))
 	for plugin in plugins.getPluginsForMenu("system"):
@@ -259,14 +276,16 @@ def getButtonSetupFunctions():
 		for x in [x for x in os.listdir("/usr/script") if x.endswith(".sh")]:
 			x = x[:-3]
 			ButtonSetupFunctions.append((_("Shellscript") + " " + x, "Shellscript/" + x, "Shellscripts"))
-	if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/ScriptRunner.pyo"):
+	if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Infopanel/ScriptRunner.pyo"):
 		ButtonSetupFunctions.append((_("ScriptRunner"), "ScriptRunner/", "Plugins"))
-	if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/QuickMenu.pyo"):
+	if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Infopanel/QuickMenu.pyo"):
 		ButtonSetupFunctions.append((_("QuickMenu"), "QuickMenu/", "Plugins"))
 	if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Kodi/plugin.pyo"):
 		ButtonSetupFunctions.append((_("Kodi MediaCenter"), "Kodi/", "Plugins"))
 	if os.path.isfile("/usr/lib/enigma2/python/Plugins/SystemPlugins/BluetoothSetup/plugin.pyo"):
 		ButtonSetupFunctions.append((_("Bluetooth Setup"), "Bluetooth/", "Plugins"))
+	if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Chromium/plugin.pyo"):
+		ButtonSetupFunctions.append((_("Youtube TV"), "YoutubeTV/", "Plugins"))
 	return ButtonSetupFunctions
 
 class ButtonSetup(Screen):
@@ -315,17 +334,16 @@ class ButtonSetup(Screen):
 	def ButtonSetupGlobal(self, key):
 		if self.longkeyPressed:
 			self.longkeyPressed = False
-		else:
-			index = 0
-			for x in self.list[:config.misc.ButtonSetup.additional_keys.value and len(self.ButtonSetupKeys) or 10]:
-				if key == x[0][1]:
-					self["list"].moveToIndex(index)
-					if key.endswith("_long"):
-						self.longkeyPressed = True
-					break
-				index += 1
-			self.getFunctions()
-			self.session.open(ButtonSetupSelect, self["list"].l.getCurrentSelection())
+		index = 0
+		for x in self.list[:config.misc.ButtonSetup.additional_keys.value and len(self.ButtonSetupKeys) or 10]:
+			if key == x[0][1]:
+				self["list"].moveToIndex(index)
+				if key.endswith("_long"):
+					self.longkeyPressed = True
+				break
+			index += 1
+		self.getFunctions()
+		self.session.open(ButtonSetupSelect, self["list"].l.getCurrentSelection())
 
 	def getFunctions(self):
 		key = self["list"].l.getCurrentSelection()[0][1]
@@ -567,11 +585,11 @@ class InfoBarButtonSetup():
 				pluginlist.sort(key=lambda p: p.name)
 				for plugin in pluginlist:
 					if plugin.name not in twinPlugins and plugin.path and 'selectedevent' not in plugin.__call__.func_code.co_varnames:	
-						if twinPaths.has_key(plugin.path[24:]):
-							twinPaths[plugin.path[24:]] += 1
+						if twinPaths.has_key(plugin.path[plugin.path.rfind("Plugins"):]):
+							twinPaths[plugin.path[plugin.path.rfind("Plugins"):]] += 1
 						else:
-							twinPaths[plugin.path[24:]] = 1
-						if plugin.path[24:] + "/" + str(twinPaths[plugin.path[24:]]) == "/".join(selected):
+							twinPaths[plugin.path[plugin.path.rfind("Plugins"):]] = 1
+						if plugin.path[plugin.path.rfind("Plugins"):] + "/" + str(twinPaths[plugin.path[plugin.path.rfind("Plugins"):]]) == "/".join(selected):
 							self.runPlugin(plugin)
 							return
 						twinPlugins.append(plugin.name)
@@ -579,11 +597,11 @@ class InfoBarButtonSetup():
 				pluginlist.sort(key=lambda p: p.name)
 				for plugin in pluginlist:
 					if plugin.name not in twinPlugins and plugin.path:
-						if twinPaths.has_key(plugin.path[24:]):
-							twinPaths[plugin.path[24:]] += 1
+						if twinPaths.has_key(plugin.path[plugin.path.rfind("Plugins"):]):
+							twinPaths[plugin.path[plugin.path.rfind("Plugins"):]] += 1
 						else:
-							twinPaths[plugin.path[24:]] = 1
-						if plugin.path[24:] + "/" + str(twinPaths[plugin.path[24:]]) == "/".join(selected):
+							twinPaths[plugin.path[plugin.path.rfind("Plugins"):]] = 1
+						if plugin.path[plugin.path.rfind("Plugins"):] + "/" + str(twinPaths[plugin.path[plugin.path.rfind("Plugins"):]]) == "/".join(selected):
 							self.runPlugin(plugin)
 							return
 						twinPlugins.append(plugin.name)
@@ -642,12 +660,12 @@ class InfoBarButtonSetup():
 				except Exception as e:
 					print('[EMCPlayer] showMovies exception:\n' + str(e))
 			elif selected[0] == "ScriptRunner":
-				if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/ScriptRunner.pyo"):
-					from Plugins.Extensions.Openpanel.ScriptRunner import ScriptRunner
+				if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Infopanel/ScriptRunner.pyo"):
+					from Plugins.Extensions.Infopanel.ScriptRunner import ScriptRunner
 					self.session.open (ScriptRunner)
 			elif selected[0] == "QuickMenu":
-				if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Openpanel/QuickMenu.pyo"):
-					from Plugins.Extensions.Openpanel.QuickMenu import QuickMenu
+				if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Infopanel/QuickMenu.pyo"):
+					from Plugins.Extensions.Infopanel.QuickMenu import QuickMenu
 					self.session.open (QuickMenu)
 			elif selected[0] == "Kodi":
 				if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Kodi/plugin.pyo"):
@@ -657,6 +675,10 @@ class InfoBarButtonSetup():
 				if os.path.isfile("/usr/lib/enigma2/python/Plugins/SystemPlugins/BluetoothSetup/plugin.pyo"):
 					from Plugins.SystemPlugins.BluetoothSetup.plugin import BluetoothSetup
 					self.session.open(BluetoothSetup)
+			elif selected[0] == "YoutubeTV":
+				if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Chromium/plugin.pyo"):
+					from Plugins.Extensions.Chromium.youtube import YoutubeTVWindow
+					self.session.open(YoutubeTVWindow)
 
 	def showServiceListOrMovies(self):
 		if hasattr(self, "openServiceList"):
diff --git a/lib/python/Screens/ChannelSelection.py b/lib/python/Screens/ChannelSelection.py
index ca36acd..ee9c9cf 100644
--- a/lib/python/Screens/ChannelSelection.py
+++ b/lib/python/Screens/ChannelSelection.py
@@ -44,6 +44,7 @@ from Screens.ButtonSetup import InfoBarButtonSetup, ButtonSetupActionMap, getBut
 profile("ChannelSelection.py 4")
 from Screens.PictureInPicture import PictureInPicture
 from Screens.RdsDisplay import RassInteractive
+from Screens.EventView import EventViewEPGSelect
 from ServiceReference import ServiceReference
 from Tools.BoundFunction import boundFunction
 from Tools import Notifications
@@ -543,7 +544,7 @@ class ChannelContextMenu(Screen):
 		if int(xres) <= 720 or not getMachineBuild() == 'blackbox7405':
 			if self.session.pipshown:
 				del self.session.pip
-				if SystemInfo["LCDMiniTV"] and int(config.lcd.modepip.value) >= 1:
+				if SystemInfo["LCDMiniTVPiP"] and int(config.lcd.modepip.value) >= 1:
 					print '[LCDMiniTV] disable PIP'
 					f = open("/proc/stb/lcd/mode", "w")
 					f.write(config.lcd.modeminitv.value)
@@ -558,7 +559,7 @@ class ChannelContextMenu(Screen):
 					self.session.pipshown = True
 					self.session.pip.servicePath = self.csel.getCurrentServicePath()
 					self.session.pip.servicePath[1] = currentBouquet
-					if SystemInfo["LCDMiniTV"] and int(config.lcd.modepip.value) >= 1:
+					if SystemInfo["LCDMiniTVPiP"] and int(config.lcd.modepip.value) >= 1:
 						print '[LCDMiniTV] enable PIP'
 						f = open("/proc/stb/lcd/mode", "w")
 						f.write(config.lcd.modepip.value)
@@ -759,9 +760,10 @@ class ChannelSelectionEPG(InfoBarButtonSetup):
 		self.currentSavedPath = []
 		self.onExecBegin.append(self.clearLongkeyPressed)
 
-		self["ChannelSelectEPGActions"] = ActionMap(["ChannelSelectEPGActions"],
+		self["ChannelSelectEPGActions"] = ActionMap(["ChannelSelectInfoActions", "ChannelSelectEPGActions"],
 			{
 				"showEPGList": self.showEPGList,
+				"showEventInfo": self.showEventInfo
 			})
 		self["recordingactions"] = HelpableActionMap(self, "InfobarInstantRecord",
 			{
@@ -957,6 +959,32 @@ class ChannelSelectionEPG(InfoBarButtonSetup):
 			self.savedService = ref
 			self.session.openWithCallback(self.SingleServiceEPGClosed, EPGSelection, ref, serviceChangeCB=self.changeServiceCB, EPGtype="single")
 
+	def showEventInfo(self):
+		if config.usage.servicelist_infokey.value == 'epg':
+			self.showEPGList()
+			return
+		ref=self.getCurrentSelection()
+		if ref:
+			epglist = []
+			epg = eEPGCache.getInstance()
+			ptr = ref and ref.valid() and epg.lookupEventTime(ref, -1)
+			if ptr:
+				epglist.append(ptr)
+				ptr = epg.lookupEventTime(ref, ptr.getBeginTime(), +1)
+				if ptr:
+					epglist.append(ptr)
+				if epglist:
+					self.epglist = epglist
+					self.session.open(EventViewEPGSelect, epglist[0], ServiceReference(ref), self.eventViewCallback)
+
+	def eventViewCallback(self, setEvent, setService, val):
+		epglist = self.epglist
+		if len(epglist) > 1:
+			tmp = epglist[0]
+			epglist[0] = epglist[1]
+			epglist[1] = tmp
+			setEvent(epglist[0])
+
 	def SingleServiceEPGClosed(self, ret=False):
 		if ret:
 			service = self.getCurrentSelection()
diff --git a/lib/python/Screens/Ci.py b/lib/python/Screens/Ci.py
index ca3ffe1..c10d7f1 100644
--- a/lib/python/Screens/Ci.py
+++ b/lib/python/Screens/Ci.py
@@ -19,6 +19,7 @@ from boxbranding import getBrandOEM, getBoxType
 import time
 
 MAX_NUM_CI = 4
+relevantPidsRoutingChoices = None
 
 def setCIBitrate(configElement):
 	if configElement.value == "no":
@@ -31,6 +32,13 @@ def setdvbCiDelay(configElement):
 	f.write(configElement.value)
 	f.close()
 
+def setRelevantPidsRouting(configElement):
+	fileName = "/proc/stb/tsmux/ci%d_relevant_pids_routing" % (configElement.slotid)
+	if fileExists(fileName, 'r'):
+		f = open(fileName, "w")
+		f.write(configElement.value)
+		f.close()
+
 def InitCiConfig():
 	config.ci = ConfigSubList()
 	config.cimisc = ConfigSubsection()
@@ -47,16 +55,34 @@ def InitCiConfig():
 				config.ci[slot].canHandleHighBitrates = ConfigSelection(choices = [("no", _("No")), ("yes", _("Yes"))], default = "no")
 			config.ci[slot].canHandleHighBitrates.slotid = slot
 			config.ci[slot].canHandleHighBitrates.addNotifier(setCIBitrate)
-		if SystemInfo["CommonInterfaceCIDelay"]:
-			config.cimisc.dvbCiDelay = ConfigSelection(default = "256", choices = [ ("16", _("16")), ("32", _("32")), ("64", _("64")), ("128", _("128")), ("256", _("256"))] )
-			config.cimisc.dvbCiDelay.addNotifier(setdvbCiDelay)
-		if getBrandOEM() in ('entwopia', 'tripledot', 'dreambox'):
-			if SystemInfo["HaveCISSL"]:
-				config.cimisc.civersion = ConfigSelection(default = "ciplus1", choices = [("auto", _("Auto")), ("ciplus1", _("CI Plus 1.2")), ("ciplus2", _("CI Plus 1.3")), ("legacy", _("CI Legacy"))])
-			else:
-				config.cimisc.civersion = ConfigSelection(default = "legacy", choices = [("legacy", _("CI Legacy"))])
+		if SystemInfo["RelevantPidsRoutingSupport"]:
+			global relevantPidsRoutingChoices
+			if not relevantPidsRoutingChoices:
+				relevantPidsRoutingChoices = [("no", _("No")), ("yes", _("Yes"))]
+				default = "no"
+				fileName = "/proc/stb/tsmux/ci%d_relevant_pids_routing_choices"
+			if fileExists(fileName, 'r'):
+				relevantPidsRoutingChoices = []
+				fd = open(fileName, 'r')
+				data = fd.read()
+				data = data.split()
+				for x in data:
+					relevantPidsRoutingChoices.append((x, _(x)))
+				if default not in data:
+					default = data[0]
+			config.ci[slot].relevantPidsRouting = ConfigSelection(choices = relevantPidsRoutingChoices, default = default)
+			config.ci[slot].relevantPidsRouting.slotid = slot
+			config.ci[slot].relevantPidsRouting.addNotifier(setRelevantPidsRouting)
+	if SystemInfo["CommonInterfaceCIDelay"]:
+		config.cimisc.dvbCiDelay = ConfigSelection(default = "256", choices = [ ("16", _("16")), ("32", _("32")), ("64", _("64")), ("128", _("128")), ("256", _("256"))] )
+		config.cimisc.dvbCiDelay.addNotifier(setdvbCiDelay)
+	if getBrandOEM() in ('entwopia', 'tripledot', 'dreambox'):
+		if SystemInfo["HaveCISSL"]:
+			config.cimisc.civersion = ConfigSelection(default = "ciplus1", choices = [("auto", _("Auto")), ("ciplus1", _("CI Plus 1.2")), ("ciplus2", _("CI Plus 1.3")), ("legacy", _("CI Legacy"))])
 		else:
-			config.cimisc.civersion = ConfigSelection(default = "auto", choices = [("auto", _("Auto")), ("ciplus1", _("CI Plus 1.2")), ("ciplus2", _("CI Plus 1.3")), ("legacy", _("CI Legacy"))])
+			config.cimisc.civersion = ConfigSelection(default = "legacy", choices = [("legacy", _("CI Legacy"))])
+	else:
+		config.cimisc.civersion = ConfigSelection(default = "auto", choices = [("auto", _("Auto")), ("ciplus1", _("CI Plus 1.2")), ("ciplus2", _("CI Plus 1.3")), ("legacy", _("CI Legacy"))])
 
 class CISetup(Screen, ConfigListScreen):
 	def __init__(self, session):
@@ -398,6 +424,12 @@ class CiMessageHandler:
 			SystemInfo["CommonInterfaceCIDelay"] = True
 		except:
 			SystemInfo["CommonInterfaceCIDelay"] = False
+		try:
+			file = open("/proc/stb/tsmux/ci0_relevant_pids_routing", "r")
+			file.close()
+			SystemInfo["RelevantPidsRoutingSupport"] = True
+		except:
+			SystemInfo["RelevantPidsRoutingSupport"] = False
 
 	def setSession(self, session):
 		self.session = session
@@ -464,29 +496,38 @@ class CiSelection(Screen):
 
 		self.dlg = None
 		self.state = { }
+		self.slots = []
+		self.HighBitrateEntry = {}
+		self.RelevantPidsRoutingEntry = {}
+		self.entryData = []
+
 		self.list = [ ]
+		self["entries"] = ConfigList(self.list)
+		self["entries"].list = self.list
+		self["entries"].l.setList(self.list)
+		self["text"] = Label(_("Slot %d")%(1))
+		self.onLayoutFinish.append(self.initialUpdate)
 
+	def initialUpdate(self):
 		for slot in range(MAX_NUM_CI):
 			state = eDVBCI_UI.getInstance().getState(slot)
 			if state != -1:
-				self.appendEntries(slot, state)
+				self.slots.append(slot)
+				self.state[slot] = state
+				self.createEntries(slot)
 				CiHandler.registerCIMessageHandler(slot, self.ciStateChanged)
 
-		menuList = ConfigList(self.list)
-		menuList.list = self.list
-		menuList.l.setList(self.list)
-		self["entries"] = menuList
-		self["entries"].onSelectionChanged.append(self.selectionChanged)
-		self["text"] = Label(_("Slot %d")%(1))
+		self.updateEntries()
 
 	def selectionChanged(self):
-		cur_idx = self["entries"].getCurrentIndex()
-		self["text"].setText(_("Slot %d")%((cur_idx / 9)+1))
+		entryData = self.entryData[self["entries"].getCurrentIndex()]
+		self["text"].setText(_("Slot %d")%(entryData[1] + 1))
 
 	def keyConfigEntry(self, key):
+		current = self["entries"].getCurrent()
 		try:
 			self["entries"].handleKey(key)
-			self["entries"].getCurrent()[1].save()
+			current[1].save()
 		except:
 			pass
 
@@ -496,50 +537,47 @@ class CiSelection(Screen):
 	def keyRight(self):
 		self.keyConfigEntry(KEY_RIGHT)
 
-	def appendEntries(self, slot, state):
-		self.state[slot] = state
-		self.list.append( (_("Reset"), ConfigNothing(), 0, slot) )
-		self.list.append( (_("Init"), ConfigNothing(), 1, slot) )
-
-		if self.state[slot] == 0:			#no module
-			self.list.append( (_("no module found"), ConfigNothing(), 2, slot) )
-		elif self.state[slot] == 1:		#module in init
-			self.list.append( (_("init module"), ConfigNothing(), 2, slot) )
-		elif self.state[slot] == 2:		#module ready
-			#get appname
-			appname = eDVBCI_UI.getInstance().getAppName(slot)
-			self.list.append( (appname, ConfigNothing(), 2, slot) )
-		self.list.append(getConfigListEntry(_("Set pin code persistent"), config.ci[slot].use_static_pin))
-		self.list.append( ( _("Enter persistent PIN code"), ConfigNothing(), 5, slot) )
-		self.list.append( ( _("Reset persistent PIN code"), ConfigNothing(), 6, slot) )
-		self.list.append(getConfigListEntry(_("Show CI messages"), config.ci[slot].show_ci_messages))
-		self.list.append(getConfigListEntry(_("Multiple service support"), config.ci[slot].canDescrambleMultipleServices))
+	def createEntries(self, slot):
 		if SystemInfo["CommonInterfaceSupportsHighBitrates"]:
-			self.list.append(getConfigListEntry(_("High bitrate support"), config.ci[slot].canHandleHighBitrates))
-
-	def updateState(self, slot):
-		state = eDVBCI_UI.getInstance().getState(slot)
-		self.state[slot] = state
+			self.HighBitrateEntry[slot] = getConfigListEntry(_("High bitrate support"), config.ci[slot].canHandleHighBitrates)
+		if SystemInfo["RelevantPidsRoutingSupport"]:
+			self.RelevantPidsRoutingEntry[slot] = getConfigListEntry(_("Relevant PIDs Routing"), config.ci[slot].relevantPidsRouting)
 
-		slotidx=0
-		while len(self.list[slotidx]) < 3 or self.list[slotidx][3] != slot:
-			slotidx += 1
+	def addToList(self, data, action, slotid):
+		self.list.append(data)
+		self.entryData.append((action, slotid))
 
-		slotidx += 1 # do not change Reset
-		slotidx += 1 # do not change Init
-
-		if state == 0:			#no module
-			self.list[slotidx] = (_("no module found"), ConfigNothing(), 2, slot)
-		elif state == 1:		#module in init
-			self.list[slotidx] = (_("init module"), ConfigNothing(), 2, slot)
-		elif state == 2:		#module ready
-			#get appname
-			appname = eDVBCI_UI.getInstance().getAppName(slot)
-			self.list[slotidx] = (appname, ConfigNothing(), 2, slot)
-
-		lst = self["entries"]
-		lst.list = self.list
-		lst.l.setList(self.list)
+	def updateEntries(self):
+		self.list = []
+		self.entryData = []
+		for slot in self.slots:
+			self.addToList((_("Reset"), ConfigNothing()), 0, slot)
+			self.addToList((_("Init"), ConfigNothing()), 1, slot)
+
+			if self.state[slot] == 0:                       #no module
+				self.addToList((_("no module found"), ConfigNothing()), 2, slot)
+			elif self.state[slot] == 1:             #module in init
+				self.addToList((_("init module"), ConfigNothing()), 2, slot)
+			elif self.state[slot] == 2:             #module ready
+				#get appname
+				appname = eDVBCI_UI.getInstance().getAppName(slot)
+				self.addToList((appname, ConfigNothing()), 2, slot)
+
+			self.addToList(getConfigListEntry(_("Set pin code persistent"), config.ci[slot].use_static_pin), -1, slot)
+			self.addToList(( _("Enter persistent PIN code"), ConfigNothing()), 5, slot)
+			self.addToList(( _("Reset persistent PIN code"), ConfigNothing()), 6, slot)
+			self.addToList(getConfigListEntry(_("Show CI messages"), config.ci[slot].show_ci_messages), -1, slot)
+			self.addToList(getConfigListEntry(_("Multiple service support"), config.ci[slot].canDescrambleMultipleServices), -1, slot)
+
+			if SystemInfo["CommonInterfaceSupportsHighBitrates"]:
+				self.addToList(self.HighBitrateEntry[slot], -1, slot)
+			if SystemInfo["RelevantPidsRoutingSupport"]:
+				self.addToList(self.RelevantPidsRoutingEntry[slot], -1, slot)
+
+		self["entries"].list = self.list
+		self["entries"].l.setList(self.list)
+		if self.selectionChanged not in self["entries"].onSelectionChanged:
+			self["entries"].onSelectionChanged.append(self.selectionChanged)
 
 	def ciStateChanged(self, slot):
 		if self.dlg:
@@ -549,16 +587,18 @@ class CiSelection(Screen):
 			if self.state[slot] != state:
 				#print "something happens"
 				self.state[slot] = state
-				self.updateState(slot)
+				self.updateEntries()
 
 	def dlgClosed(self, slot):
 		self.dlg = None
 
 	def okbuttonClick(self):
 		cur = self["entries"].getCurrent()
-		if cur and len(cur) > 2:
-			action = cur[2]
-			slot = cur[3]
+		if cur:
+			idx = self["entries"].getCurrentIndex()
+			entryData = self.entryData[idx]
+			action = entryData[0]
+			slot = entryData[1]
 			if action == 0:		#reset
 				eDVBCI_UI.getInstance().setReset(slot)
 			elif action == 1:		#init
@@ -569,7 +609,7 @@ class CiSelection(Screen):
 				config.ci[slot].static_pin.value = 0
 				config.ci[slot].static_pin.save()
 				self.session.openWithCallback(self.cancelCB, MessageBox, _("The saved PIN was cleared."), MessageBox.TYPE_INFO)
-			elif self.state[slot] == 2:
+			elif action == 2 and self.state[slot] == 2:
 				self.dlg = self.session.openWithCallback(self.dlgClosed, MMIDialog, slot, action)
 
 	def cancelCB(self,value):
diff --git a/lib/python/Screens/CronTimer.py b/lib/python/Screens/CronTimer.py
index 92618f8..78c9496 100755
--- a/lib/python/Screens/CronTimer.py
+++ b/lib/python/Screens/CronTimer.py
@@ -5,6 +5,7 @@ from Components.Console import Console
 from Components.Label import Label
 from Components.Sources.List import List
 from Components.Sources.StaticText import StaticText
+from Components.Sources.Boolean import Boolean
 from Components.Pixmap import Pixmap
 from Screens.Screen import Screen
 from Screens.MessageBox import MessageBox
@@ -40,7 +41,7 @@ class CronTimers(Screen):
 		self['key_blue'] = Label(_("Autostart"))
 		self.list = []
 		self['list'] = List(self.list)
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions', "MenuActions"], {'ok': self.info, 'back': self.UninstallCheck, 'red': self.delcron, 'green': self.addtocron, 'yellow': self.CrondStart, 'blue': self.autostart, "menu": self.closeRecursive})
+		self['actions'] = ActionMap(['WizardActions', 'ColorActions', "MenuActions"], {'ok': self.info, 'back': self.UninstallCheck, 'red': self.delcron, 'green': self.addtocron, 'yellow': self.CrondStart, 'blue': self.autostart})
 		if not self.selectionChanged in self["list"].onSelectionChanged:
 			self["list"].onSelectionChanged.append(self.selectionChanged)
 		self.service_name = 'cronie'
@@ -258,9 +259,6 @@ class CronTimers(Screen):
 			myline = mysel[1]
 			self.session.open(MessageBox, _(myline), MessageBox.TYPE_INFO)
 
-	def closeRecursive(self):
-		self.close(True)
-
 config.crontimers = ConfigSubsection()
 config.crontimers.commandtype = NoSave(ConfigSelection(choices = [ ('custom',_("Custom")),('predefined',_("Predefined")) ]))
 config.crontimers.cmdtime = NoSave(ConfigClock(default=0))
@@ -280,7 +278,8 @@ class CronTimersConfig(Screen, ConfigListScreen):
 		ConfigListScreen.__init__(self, self.list, session = self.session, on_change = self.changedEntry)
 		self['key_red'] = Label(_("Close"))
 		self['key_green'] = Label(_("Save"))
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions', 'VirtualKeyboardActions', "MenuActions"], {'red': self.close,'green': self.checkentry, 'back': self.close, 'showVirtualKeyboard': self.KeyText, "menu": self.closeRecursive})
+		self['actions'] = ActionMap(['WizardActions', 'ColorActions', 'VirtualKeyboardActions', "MenuActions"], {'red': self.close,'green': self.checkentry, 'back': self.close, 'showVirtualKeyboard': self.KeyText})
+		self["VKeyIcon"] = Boolean(False)
 		self["HelpWindow"] = Pixmap()
 		self["HelpWindow"].hide()
 		self['footnote'] = Label()
diff --git a/lib/python/Screens/EpgSelection.py b/lib/python/Screens/EpgSelection.py
index 71d2b2f..50d415e 100644
--- a/lib/python/Screens/EpgSelection.py
+++ b/lib/python/Screens/EpgSelection.py
@@ -8,7 +8,8 @@ from Components.About import about
 from Components.ActionMap import HelpableActionMap, HelpableNumberActionMap
 from Components.Button import Button
 from Components.config import config, configfile, ConfigClock
-from Components.EpgList import EPGList, EPGBouquetList, TimelineText, EPG_TYPE_SINGLE, EPG_TYPE_SIMILAR, EPG_TYPE_MULTI, EPG_TYPE_ENHANCED, EPG_TYPE_INFOBAR, EPG_TYPE_INFOBARGRAPH, EPG_TYPE_GRAPH, MAX_TIMELINES
+from Components.EpgList import EPGList, EPGBouquetList, TimelineText, EPG_TYPE_SINGLE, EPG_TYPE_SIMILAR, EPG_TYPE_MULTI, EPG_TYPE_ENHANCED, EPG_TYPE_INFOBAR, EPG_TYPE_INFOBARGRAPH, EPG_TYPE_GRAPH, EPG_TYPE_VERTICAL, MAX_TIMELINES
+from Components.MenuList import MenuList
 from Components.Label import Label
 from Components.Pixmap import Pixmap
 from Components.Sources.ServiceEvent import ServiceEvent
@@ -65,6 +66,8 @@ class EPGSelection(Screen, HelpableScreen):
 				graphic = True
 		elif EPGtype == 'multi':
 			self.type = EPG_TYPE_MULTI
+		elif EPGtype == 'vertical':
+			self.type = EPG_TYPE_VERTICAL
 		elif EPGtype is None and eventid == None and isinstance(service, eServiceReference):
 			self.type = EPG_TYPE_SINGLE
 		else:
@@ -79,6 +82,9 @@ class EPGSelection(Screen, HelpableScreen):
 		self.eventviewDialog = None
 		self.eventviewWasShown = False
 		self.currch = None
+		self.Oldpipshown = False
+		if self.session.pipshown:
+			self.Oldpipshown = True
 		self.session.pipshown = False
 		self.cureventindex = None
 		if plugin_PiPServiceRelation_installed:
@@ -91,14 +97,30 @@ class EPGSelection(Screen, HelpableScreen):
 		self.NumberZapField = None
 		self.CurrBouquet = None
 		self.CurrService = None
-		self["number"] = Label()
-		self["number"].hide()
 		self['Service'] = ServiceEvent()
 		self['Event'] = Event()
 		self['lab1'] = Label(_('Please wait while gathering data...'))
 		self.key_green_choice = self.EMPTY
 
-		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
+		#//vertical
+		if self.type == EPG_TYPE_VERTICAL:
+			self.StartBouquet = StartBouquet
+			self.StartRef = StartRef
+			self.servicelist = service
+			self.bouquetlist_active = False
+			self.firststart = True
+			self.lastEventTime = (time(), time()+3600)
+			self.lastMinus = 0
+			self.activeList = 1
+			self.myServices = []
+			self.list = []
+		else:
+			self.activeList = ''
+			self["number"] = Label()
+			self["number"].hide()
+		#//
+
+		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH or self.type == EPG_TYPE_VERTICAL:
 			self.RefreshColouredKeys()
 		else:
 			self['key_red'] = Button(_('IMDb Search'))
@@ -381,18 +403,104 @@ class EPGSelection(Screen, HelpableScreen):
 					'menu': (self.createSetup, _('Setup menu'))
 				}, -1)
 			self['epgactions'].csel = self
+		elif self.type == EPG_TYPE_VERTICAL:
+			if config.epgselection.vertical_pig.value:
+				self.Fields = 4
+				self.skinName = 'EPGverticalPIG'
+			else:
+				self.Fields = 6
+				self.skinName = 'EPGvertical'
+			self['bouquetlist'] = EPGBouquetList(graphic=graphic)
+			self['bouquetlist'].hide()
+			self["list"] = MenuList([ ])
+			self["piconCh1"] = ServiceEvent()
+			self["piconCh2"] = ServiceEvent()
+			self["piconCh3"] = ServiceEvent()
+			self["piconCh4"] = ServiceEvent()
+			self["piconCh5"] = ServiceEvent()
+			self["currCh1"] = Label(" ")
+			self["currCh2"] = Label(" ")
+			self["currCh3"] = Label(" ")
+			self["currCh4"] = Label(" ")
+			self["currCh5"] = Label(" ")
+			self["Active1"] = Label(" ")
+			self["Active2"] = Label(" ")
+			self["Active3"] = Label(" ")
+			self["Active4"] = Label(" ")
+			self["Active5"] = Label(" ")
+			self["list1"] = EPGList(type = EPG_TYPE_VERTICAL, selChangedCB = self.onSelectionChanged, timer = session.nav.RecordTimer)
+			self["list2"] = EPGList(type = EPG_TYPE_VERTICAL, selChangedCB = self.onSelectionChanged, timer = session.nav.RecordTimer)
+			self["list3"] = EPGList(type = EPG_TYPE_VERTICAL, selChangedCB = self.onSelectionChanged, timer = session.nav.RecordTimer)
+			self["list4"] = EPGList(type = EPG_TYPE_VERTICAL, selChangedCB = self.onSelectionChanged, timer = session.nav.RecordTimer)
+			self["list5"] = EPGList(type = EPG_TYPE_VERTICAL, selChangedCB = self.onSelectionChanged, timer = session.nav.RecordTimer)
+
+			self['bouquetokactions'] = HelpableActionMap(self, 'OkCancelActions',
+				{
+					'cancel': (self.BouquetlistHide, _('Close bouquet list.')),
+					'OK': (self.BouquetOK, _('Change to bouquet')),
+				}, -1)
+			self['bouquetokactions'].csel = self
+			self["bouquetokactions"].setEnabled(False)
+
+			self['bouquetcursoractions'] = HelpableActionMap(self, 'DirectionActions', 
+				{
+					'left': (self.moveBouquetPageUp, _('Goto previous event')),
+					'right': (self.moveBouquetPageDown, _('Goto next event')),
+					'up': (self.moveBouquetUp, _('Goto previous channel')),
+					'down': (self.moveBouquetDown, _('Goto next channel'))
+				}, -1)
+			self['bouquetcursoractions'].csel = self
+			self["bouquetcursoractions"].setEnabled(False)
+
+			self['epgcursoractions'] = HelpableActionMap(self, 'DirectionActions', 
+				{
+					'left': (self.leftPressed, _('Goto previous event')),
+					'right': (self.rightPressed, _('Goto next event')),
+					'up': (self.moveUp, _('Goto previous channel')),
+					'down': (self.moveDown, _('Goto next channel'))
+				}, -1)
+			self['epgcursoractions'].csel = self
+
+			self['epgactions'] = HelpableActionMap(self, 'EPGSelectActions', 
+				{
+					'nextService': (self.nextPage, _('jump to next page or all up (setup in menu)')),
+					'prevService': (self.prevPage, _('jump to previous page or all down (setup in menu)')),
+					'nextBouquet': (self.nextBouquet, _('Goto next bouquet')),
+					'prevBouquet': (self.prevBouquet, _('Goto previous bouquet')),
+					'input_date_time': (self.enterDateTime, _('Goto specific data/time')),
+					'epg': (self.epgButtonPressed, _('Show single epg for current channel')),
+					'info': (self.Info, _('Show detailed event info (setup in menu)')),
+					'infolong': (self.InfoLong, _('Show single epg for current channel (setup in menu)')),
+					'tv': (self.Bouquetlist, _('Toggle between bouquet/epg lists')),
+					'tvlong': (self.togglePIG, _('Toggle Picture In Graphics')),
+					'menu': (self.createSetup, _('Setup menu'))
+				}, -1)
+
+			self['input_actions'] = HelpableNumberActionMap(self, 'NumberActions', 
+				{
+					'1': (self.keyNumberGlobal, _('goto first channel')),
+					'2': (self.keyNumberGlobal, _('all events up')),
+					'3': (self.keyNumberGlobal, _('goto last channel')),
+					'4': (self.keyNumberGlobal, _('previous channel page')),
+					'0': (self.keyNumberGlobal, _('goto current channel and now')),
+					'6': (self.keyNumberGlobal, _('next channel page')),
+					'7': (self.keyNumberGlobal, _('goto now')),
+					'8': (self.keyNumberGlobal, _('all events down')),
+					'9': (self.keyNumberGlobal, _('Goto Primetime')),
+					'5': (self.keyNumberGlobal, _('Set Basetime'))
+				}, -1)
+
 		if self.type == EPG_TYPE_GRAPH:
 			time_epoch=int(config.epgselection.graph_prevtimeperiod.value)
 		elif self.type == EPG_TYPE_INFOBARGRAPH:
 			time_epoch=int(config.epgselection.infobar_prevtimeperiod.value)
 		else:
 			time_epoch=None
-		self['list'] = EPGList(type=self.type, selChangedCB=self.onSelectionChanged, timer=session.nav.RecordTimer, time_epoch=time_epoch, overjump_empty=config.epgselection.overjump.value, graphic=graphic)
+		if self.type != EPG_TYPE_VERTICAL:
+			self['list'] = EPGList(type=self.type, selChangedCB=self.onSelectionChanged, timer=session.nav.RecordTimer, time_epoch=time_epoch, overjump_empty=config.epgselection.overjump.value, graphic=graphic)
+		self.onLayoutFinish.append(self.LayoutFinish)
 		self.refreshTimer = eTimer()
 		self.refreshTimer.timeout.get().append(self.refreshlist)
-		self.listTimer = eTimer()
-		self.listTimer.callback.append(self.hidewaitingtext)
-		self.onLayoutFinish.append(self.LayoutFinish)
 
 	def createSetup(self):
 		self.closeEventViewDialog()
@@ -409,6 +517,8 @@ class EPGSelection(Screen, HelpableScreen):
 			key = 'epggraphical'
 		elif self.type == EPG_TYPE_INFOBARGRAPH:
 			key = 'epginfobargraphical'
+		elif self.type == EPG_TYPE_VERTICAL:
+			key = 'epgvertical'
 		if key:
 			self.session.openWithCallback(self.onSetupClose, Setup, key)
 
@@ -418,11 +528,22 @@ class EPGSelection(Screen, HelpableScreen):
 				self.close('reopengraph')
 			elif self.type == EPG_TYPE_INFOBARGRAPH:
 				self.close('reopeninfobargraph')
-		else:
-			if self.type == EPG_TYPE_INFOBAR:
-				self.close('reopeninfobar')
+		elif self.type == EPG_TYPE_INFOBAR:
+			self.close('reopeninfobar')
+		elif self.type == EPG_TYPE_VERTICAL:
+			self.close('reopenvertical')
 
 	def togglePIG(self):
+		if self.type == EPG_TYPE_VERTICAL:
+			if not config.epgselection.vertical_pig.value:
+				config.epgselection.vertical_pig.setValue(True)
+			else:
+				config.epgselection.vertical_pig.setValue(False)
+			config.epgselection.vertical_pig.save()
+			configfile.save()
+			self.close('reopenvertical')
+			return
+
 		if not config.epgselection.graph_pig.value:
 			config.epgselection.graph_pig.setValue(True)
 		else:
@@ -431,12 +552,6 @@ class EPGSelection(Screen, HelpableScreen):
 		configfile.save()
 		self.close('reopengraph')
 
-	def hidewaitingtext(self):
-		self.listTimer.stop()
-		if self.type == EPG_TYPE_MULTI:
-			self['list'].moveToService(self.session.nav.getCurrentlyPlayingServiceOrGroup())
-		self['lab1'].hide()
-
 	def getBouquetServices(self, bouquet):
 		services = []
 		servicelist = eServiceCenter.getInstance().list(bouquet)
@@ -451,28 +566,79 @@ class EPGSelection(Screen, HelpableScreen):
 		return services
 
 	def LayoutFinish(self):
-		self['lab1'].show()
 		self.createTimer = eTimer()
 		self.createTimer.start(500, True)
+		self['lab1'].show()
 		self.onCreate()
 
 	def onCreate(self):
-		serviceref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
 		title = None
-		self['list'].recalcEntrySize()
 		self.BouquetRoot = False
-		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
+		serviceref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+		if self.type != EPG_TYPE_VERTICAL:
+			self['list'].recalcEntrySize()
+		if self.type == EPG_TYPE_VERTICAL:
+			self.ask_time = -1
+			self.lastEventTime = (time(), time()+3600)
+			self.BouquetRoot = False
+			if self.StartBouquet.toString().startswith('1:7:0'):
+				self.BouquetRoot = True
+			self.services = self.getBouquetServices(self.StartBouquet)
+			self['bouquetlist'].recalcEntrySize()
+			self['bouquetlist'].fillBouquetList(self.bouquets)
+			self['bouquetlist'].moveToService(self.StartBouquet)
+			self['bouquetlist'].setCurrentBouquet(self.StartBouquet)
+			self.setTitle(self['bouquetlist'].getCurrentBouquet())
+			self["list"].setList(self.getChannels())
+			if self.servicelist:
+				service = ServiceReference(self.servicelist.getCurrentSelection())
+				info = service and service.info()
+				nameROH = info and info.getName(service.ref).replace('\xc2\x86', '').replace('\xc2\x87', '')
+			else:
+				service = self.session.nav.getCurrentService()
+				info = service and service.info()
+				nameROH = info and info.getName().replace('\xc2\x86', '').replace('\xc2\x87', '')
+			if (nameROH is not None) and not ('channel1' in config.epgselection.vertical_startmode.value):
+				idx=0
+				for channel in self.myServices:
+					idx+=1
+					if channel[1] == nameROH:
+						break
+				page = idx/(self.Fields-1)
+				row = idx%(self.Fields-1)
+				if row:
+					self.activeList = row
+				else:
+					page-=1
+					self.activeList = self.Fields-1
+				self["list"].moveToIndex(0)
+				for i in range(0,page):
+					self["list"].pageDown()
+			else:
+				self["list"].moveToIndex(0)
+			self['Service'].newService(service.ref)
+			if self.firststart and 'primetime' in config.epgselection.vertical_startmode.value:
+				self.gotoPrimetime()
+			else:
+				self.updateVerticalEPG()
+			self.firststart = False
+		elif self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH or self.type == EPG_TYPE_MULTI:
 			if self.StartBouquet.toString().startswith('1:7:0'):
 				self.BouquetRoot = True
 			self.services = self.getBouquetServices(self.StartBouquet)
-			self['list'].fillGraphEPG(self.services, self.ask_time)
-			self['list'].moveToService(serviceref)
-			self['list'].setCurrentlyPlaying(serviceref)
 			self['bouquetlist'].recalcEntrySize()
 			self['bouquetlist'].fillBouquetList(self.bouquets)
 			self['bouquetlist'].moveToService(self.StartBouquet)
 			self['bouquetlist'].setCurrentBouquet(self.StartBouquet	)
 			self.setTitle(self['bouquetlist'].getCurrentBouquet())
+			if self.type == EPG_TYPE_MULTI:
+				self['list'].fillMultiEPG(self.services, self.ask_time)
+			else:
+				self['list'].fillGraphEPG(self.services, self.ask_time)
+			self['list'].setCurrentlyPlaying(serviceref)
+			self['list'].moveToService(serviceref)
+			if self.type != EPG_TYPE_MULTI:
+				self['list'].fillGraphEPG(None, self.ask_time, True)
 			if self.type == EPG_TYPE_GRAPH:
 				self['list'].setShowServiceMode(config.epgselection.graph_servicetitle_mode.value)
 				self.moveTimeLines()
@@ -481,15 +647,6 @@ class EPGSelection(Screen, HelpableScreen):
 			elif self.type == EPG_TYPE_INFOBARGRAPH:
 				self['list'].setShowServiceMode(config.epgselection.infobar_servicetitle_mode.value)
 				self.moveTimeLines()
-		elif self.type == EPG_TYPE_MULTI:
-			self['bouquetlist'].recalcEntrySize()
-			self['bouquetlist'].fillBouquetList(self.bouquets)
-			self['bouquetlist'].moveToService(self.StartBouquet)
-			self['bouquetlist'].fillBouquetList(self.bouquets)
-			self.services = self.getBouquetServices(self.StartBouquet)
-			self['list'].fillMultiEPG(self.services, self.ask_time)
-			self['list'].setCurrentlyPlaying(serviceref)
-			self.setTitle(self['bouquetlist'].getCurrentBouquet())
 		elif self.type == EPG_TYPE_SINGLE or self.type == EPG_TYPE_ENHANCED or self.type == EPG_TYPE_INFOBAR:
 			if self.type == EPG_TYPE_SINGLE:
 				service = self.currentService
@@ -506,15 +663,19 @@ class EPGSelection(Screen, HelpableScreen):
 			self['list'].sortSingleEPG(int(config.epgselection.sort.value))
 		else:
 			self['list'].fillSimilarList(self.currentService, self.eventid)
-		self.listTimer.start(10)
+		self['lab1'].hide()
 
 	def refreshlist(self):
 		self.refreshTimer.stop()
 		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
+			self.ask_time = self['list'].getTimeBase()
 			self['list'].fillGraphEPG(None, self.ask_time)
 			self.moveTimeLines()
 		elif self.type == EPG_TYPE_MULTI:
+			curr = self['list'].getCurrentChangeCount()
 			self['list'].fillMultiEPG(self.services, self.ask_time)
+			for i in range(curr):
+				self['list'].updateMultiEPG(1)
 		elif self.type == EPG_TYPE_SINGLE or self.type == EPG_TYPE_ENHANCED or self.type == EPG_TYPE_INFOBAR:
 			try:
 				if self.type == EPG_TYPE_SINGLE:
@@ -531,16 +692,48 @@ class EPGSelection(Screen, HelpableScreen):
 				self['list'].setCurrentIndex(index)
 			except:
 				pass
+		elif self.type == EPG_TYPE_VERTICAL:
+			curr = self['list'+str(self.activeList)].getSelectedEventId()
+			currPrg = self.myServices[self.getActivePrg()]
+			l = self['list'+str(self.activeList)]
+			l.recalcEntrySize()
+			service = ServiceReference(currPrg[0])
+			stime = None
+			if self.ask_time > time():
+				stime = self.ask_time
+			l.fillSingleEPG(service, stime)
+			self['list'+str(self.activeList)].moveToEventId(curr)
 
 	def moveUp(self):
-		self['list'].moveTo(self['list'].instance.moveUp)
+		if self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_updownbtn.value:
+			if self.getEventTime(self.activeList)[0] is None:
+				return
+			self.saveLastEventTime()
+			idx = self['list'+str(self.activeList)].getCurrentIndex()
+			if not idx:
+				tmp = self.lastEventTime
+				self.setMinus24h(True, 6)
+				self.lastEventTime = tmp
+				self.gotoLasttime()
+			elif config.epgselection.vertical_updownbtn.value:
+				if not idx % config.epgselection.vertical_itemsperpage.value:
+					self.syncUp(idx)
+		self['list'+str(self.activeList)].moveTo(self['list'+str(self.activeList)].instance.moveUp)
 		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
 			self.moveTimeLines(True)
+		if self.type == EPG_TYPE_VERTICAL:
+			self.saveLastEventTime()
 
 	def moveDown(self):
-		self['list'].moveTo(self['list'].instance.moveDown)
+		if self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_updownbtn.value:
+			idx = self['list'+str(self.activeList)].getCurrentIndex()
+			if not (idx+1) % config.epgselection.vertical_itemsperpage.value:
+				self.syncDown(idx+1)
+		self['list'+str(self.activeList)].moveTo(self['list'+str(self.activeList)].instance.moveDown)
 		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
 			self.moveTimeLines(True)
+		if self.type == EPG_TYPE_VERTICAL:
+			self.saveLastEventTime()
 
 	def updEvent(self, dir, visible = True):
 		ret = self['list'].selEntry(dir, visible)
@@ -549,11 +742,59 @@ class EPGSelection(Screen, HelpableScreen):
 		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
 			self.moveTimeLines(True)
 
-	def nextPage(self):
-		self['list'].moveTo(self['list'].instance.pageDown)
+	def nextPage(self, numberkey=False, reverse = False):
+		if self.type == EPG_TYPE_VERTICAL:
+			if not numberkey and 'scroll' in config.epgselection.vertical_channelbtn.value:
+				if config.epgselection.vertical_channelbtn_invert.value:
+					self.allDown()
+				else:
+					self.allUp()
+			elif not numberkey and '24' in config.epgselection.vertical_channelbtn.value:
+				if config.epgselection.vertical_channelbtn_invert.value:
+					self.setPlus24h()
+				else:
+					self.setMinus24h()
+			else:
+				if not numberkey:
+					if not reverse and config.epgselection.vertical_channelbtn_invert.value:
+						self.prevPage(reverse = True)
+						return
+				if len(self.list) <= self["list"].getSelectionIndex() + self.Fields-1:
+					self.gotoFirst()
+				else:
+					self["list"].pageDown()
+					self.activeList = 1
+					self.updateVerticalEPG()
+				self.gotoLasttime()
+		else:
+			self['list'].moveTo(self['list'].instance.pageDown)
 
-	def prevPage(self):
-		self['list'].moveTo(self['list'].instance.pageUp)
+	def prevPage(self, numberkey=False, reverse = False):
+		if self.type == EPG_TYPE_VERTICAL:
+			if not numberkey and 'scroll' in config.epgselection.vertical_channelbtn.value:
+				if config.epgselection.vertical_channelbtn_invert.value:
+					self.allUp()
+				else:
+					self.allDown()
+			elif not numberkey and '24' in config.epgselection.vertical_channelbtn.value:
+				if config.epgselection.vertical_channelbtn_invert.value:
+					self.setMinus24h()
+				else:
+					self.setPlus24h()
+			else:
+				if not numberkey:
+					if not reverse and config.epgselection.vertical_channelbtn_invert.value:
+						self.nextPage(reverse = True)
+						return
+				if not self["list"].getSelectionIndex():
+					self.gotoLast()
+				else:
+					self['list'].pageUp()
+					self.activeList = (self.Fields-1)
+					self.updateVerticalEPG()
+				self.gotoLasttime()
+		else:
+			self['list'].moveTo(self['list'].instance.pageUp)
 
 	def toTop(self):
 		self['list'].moveTo(self['list'].instance.moveTop)
@@ -562,13 +803,41 @@ class EPGSelection(Screen, HelpableScreen):
 		self['list'].moveTo(self['list'].instance.moveEnd)
 
 	def leftPressed(self):
-		if self.type == EPG_TYPE_MULTI:
+		if self.type == EPG_TYPE_VERTICAL:
+			first = not self["list"].getSelectionIndex() and self.activeList == 1
+			if self.activeList > 1 and not first:
+				self.activeList -= 1
+				self.displayActiveEPG()
+			else:
+				if first:
+					self.gotoLast()
+				else:
+					self["list"].pageUp()
+					self.activeList = (self.Fields-1)
+					self.updateVerticalEPG()
+				self.gotoLasttime()
+			self.onSelectionChanged()
+		elif self.type == EPG_TYPE_MULTI:
 			self['list'].updateMultiEPG(-1)
 		else:
 			self.updEvent(-1)
 
 	def rightPressed(self):
-		if self.type == EPG_TYPE_MULTI:
+		if self.type == EPG_TYPE_VERTICAL:
+			end = len(self.list) == self["list"].getSelectionIndex() + self.activeList
+			if self.activeList < (self.Fields-1) and not end:
+				self.activeList += 1
+				self.displayActiveEPG()
+			else:
+				if end:
+					self.gotoFirst()
+				else:
+					self["list"].pageDown()
+					self.activeList = 1
+					self.updateVerticalEPG()
+				self.gotoLasttime()
+			self.onSelectionChanged()
+		elif self.type == EPG_TYPE_MULTI:
 			self['list'].updateMultiEPG(1)
 		else:
 			self.updEvent(+1)
@@ -627,7 +896,13 @@ class EPGSelection(Screen, HelpableScreen):
 			self.moveTimeLines(True)
 		elif self.type == EPG_TYPE_MULTI:
 			self['list'].fillMultiEPG(self.services, self.ask_time)
-		self['list'].instance.moveSelectionTo(0)
+		if self.type == EPG_TYPE_VERTICAL:
+			self["list"].setList(self.getChannels())
+			self.gotoFirst()
+		else:
+			self['list'].instance.moveSelectionTo(0)
+		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
+			self['list'].fillGraphEPG(None, self.ask_time, True)
 		self.setTitle(self['bouquetlist'].getCurrentBouquet())
 		self.BouquetlistHide(False)
 
@@ -648,7 +923,7 @@ class EPGSelection(Screen, HelpableScreen):
 		self['bouquetlist'].fillBouquetList(self.bouquets)
 
 	def nextBouquet(self):
-		if self.type == EPG_TYPE_MULTI or self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
+		if self.type == EPG_TYPE_MULTI or self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH or self.type == EPG_TYPE_VERTICAL:
 			self.moveBouquetDown()
 			self.BouquetOK()
 		elif (self.type == EPG_TYPE_ENHANCED or self.type == EPG_TYPE_INFOBAR) and config.usage.multibouquet.value:
@@ -658,7 +933,7 @@ class EPGSelection(Screen, HelpableScreen):
 			self.onCreate()
 
 	def prevBouquet(self):
-		if self.type == EPG_TYPE_MULTI or self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
+		if self.type == EPG_TYPE_MULTI or self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH or self.type == EPG_TYPE_VERTICAL:
 			self.moveBouquetUp()
 			self.BouquetOK()
 		elif (self.type == EPG_TYPE_ENHANCED or self.type == EPG_TYPE_INFOBAR) and config.usage.multibouquet.value:
@@ -738,6 +1013,8 @@ class EPGSelection(Screen, HelpableScreen):
 			self.session.openWithCallback(self.onDateTimeInputClosed, TimeDateInput, config.epgselection.graph_prevtime)
 		elif self.type == EPG_TYPE_INFOBARGRAPH:
 			self.session.openWithCallback(self.onDateTimeInputClosed, TimeDateInput, config.epgselection.infobar_prevtime)
+		elif self.type == EPG_TYPE_VERTICAL:
+			self.session.openWithCallback(self.onDateTimeInputClosed, TimeDateInput, config.epgselection.vertical_prevtime)
 
 	def onDateTimeInputClosed(self, ret):
 		if len(ret) > 1:
@@ -756,11 +1033,17 @@ class EPGSelection(Screen, HelpableScreen):
 					l.resetOffset()
 					l.fillGraphEPG(None, self.ask_time)
 					self.moveTimeLines(True)
+				elif EPG_TYPE_VERTICAL:
+					if ret[1] > time():
+						self.ask_time = ret[1]
+						self.updateVerticalEPG()
+					else:
+						self.ask_time = -1
 		if self.eventviewDialog and (self.type == EPG_TYPE_INFOBAR or self.type == EPG_TYPE_INFOBARGRAPH):
 			self.infoKeyPressed(True)
 
 	def infoKeyPressed(self, eventviewopen=False):
-		cur = self['list'].getCurrent()
+		cur = self['list'+str(self.activeList)].getCurrent()
 		event = cur[0]
 		service = cur[1]
 		if event is not None and not self.eventviewDialog and not eventviewopen:
@@ -807,6 +1090,31 @@ class EPGSelection(Screen, HelpableScreen):
 					self.RecordTimerQuestion()
 				if config.epgselection.graph_red.value == "gotodatetime":
 					self.enterDateTime()
+			elif self.type == EPG_TYPE_VERTICAL:
+				if config.epgselection.vertical_red.value == "24plus":
+					self.setPlus24h()
+				if config.epgselection.vertical_red.value == "24minus":
+					self.setMinus24h()
+				if config.epgselection.vertical_red.value == "timer":
+					self.RecordTimerQuestion(True)
+				if config.epgselection.vertical_red.value == "imdb"  or config.epgselection.vertical_red.value == None:
+					self.openIMDb()
+				if config.epgselection.vertical_red.value == "autotimer":
+					self.addAutoTimer()
+				if config.epgselection.vertical_red.value == "bouquetlist":
+					self.Bouquetlist()
+				if config.epgselection.vertical_red.value == "epgsearch":
+					self.openEPGSearch()
+				if config.epgselection.vertical_red.value == "showmovies":
+					self.showMovieSelection()
+				if config.epgselection.vertical_red.value == "record":
+					self.RecordTimerQuestion()
+				if config.epgselection.vertical_red.value == "gotoprimetime":
+					self.gotoPrimetime()
+				if config.epgselection.vertical_red.value == "setbasetime":
+					self.setBasetime()
+				if config.epgselection.vertical_red.value == "gotodatetime":
+					self.enterDateTime()
 			else:
 				self.openIMDb()
 
@@ -843,6 +1151,31 @@ class EPGSelection(Screen, HelpableScreen):
 					self.RecordTimerQuestion()
 				if config.epgselection.graph_green.value == "gotodatetime":
 					self.enterDateTime()
+			elif self.type == EPG_TYPE_VERTICAL:
+				if config.epgselection.vertical_green.value == "24plus":
+					self.setPlus24h()
+				if config.epgselection.vertical_green.value == "24minus":
+					self.setMinus24h()
+				if config.epgselection.vertical_green.value == "timer":
+					self.RecordTimerQuestion(True)
+				if config.epgselection.vertical_green.value == "imdb"  or config.epgselection.vertical_green.value == None:
+					self.openIMDb()
+				if config.epgselection.vertical_green.value == "autotimer":
+					self.addAutoTimer()
+				if config.epgselection.vertical_green.value == "bouquetlist":
+					self.Bouquetlist()
+				if config.epgselection.vertical_green.value == "epgsearch":
+					self.openEPGSearch()
+				if config.epgselection.vertical_green.value == "showmovies":
+					self.showMovieSelection()
+				if config.epgselection.vertical_green.value == "record":
+					self.RecordTimerQuestion()
+				if config.epgselection.vertical_green.value == "gotoprimetime":
+					self.gotoPrimetime()
+				if config.epgselection.vertical_green.value == "setbasetime":
+					self.setBasetime()
+				if config.epgselection.vertical_green.value == "gotodatetime":
+					self.enterDateTime()
 			else:
 				self.RecordTimerQuestion(True)
 
@@ -879,6 +1212,31 @@ class EPGSelection(Screen, HelpableScreen):
 					self.RecordTimerQuestion()
 				if config.epgselection.graph_yellow.value == "gotodatetime":
 					self.enterDateTime()
+			elif self.type == EPG_TYPE_VERTICAL:
+				if config.epgselection.vertical_yellow.value == "24plus":
+					self.setPlus24h()
+				if config.epgselection.vertical_yellow.value == "24minus":
+					self.setMinus24h()
+				if config.epgselection.vertical_yellow.value == "timer":
+					self.RecordTimerQuestion(True)
+				if config.epgselection.vertical_yellow.value == "imdb"  or config.epgselection.vertical_yellow.value == None:
+					self.openIMDb()
+				if config.epgselection.vertical_yellow.value == "autotimer":
+					self.addAutoTimer()
+				if config.epgselection.vertical_yellow.value == "bouquetlist":
+					self.Bouquetlist()
+				if config.epgselection.vertical_yellow.value == "epgsearch":
+					self.openEPGSearch()
+				if config.epgselection.vertical_yellow.value == "showmovies":
+					self.showMovieSelection()
+				if config.epgselection.vertical_yellow.value == "record":
+					self.RecordTimerQuestion()
+				if config.epgselection.vertical_yellow.value == "gotoprimetime":
+					self.gotoPrimetime()
+				if config.epgselection.vertical_yellow.value == "setbasetime":
+					self.setBasetime()
+				if config.epgselection.vertical_yellow.value == "gotodatetime":
+					self.enterDateTime()
 			else:
 				self.openEPGSearch()
 
@@ -908,6 +1266,31 @@ class EPGSelection(Screen, HelpableScreen):
 					self.RecordTimerQuestion()
 				if config.epgselection.graph_blue.value == "gotodatetime":
 					self.enterDateTime()
+			elif self.type == EPG_TYPE_VERTICAL:
+				if config.epgselection.vertical_blue.value == "24plus":
+					self.setPlus24h()
+				if config.epgselection.vertical_blue.value == "24minus":
+					self.setMinus24h()
+				if config.epgselection.vertical_blue.value == "timer":
+					self.RecordTimerQuestion(True)
+				if config.epgselection.vertical_blue.value == "imdb"  or config.epgselection.vertical_blue.value == None:
+					self.openIMDb()
+				if config.epgselection.vertical_blue.value == "autotimer":
+					self.addAutoTimer()
+				if config.epgselection.vertical_blue.value == "bouquetlist":
+					self.Bouquetlist()
+				if config.epgselection.vertical_blue.value == "epgsearch":
+					self.openEPGSearch()
+				if config.epgselection.vertical_blue.value == "showmovies":
+					self.showMovieSelection()
+				if config.epgselection.vertical_blue.value == "record":
+					self.RecordTimerQuestion()
+				if config.epgselection.vertical_blue.value == "gotoprimetime":
+					self.gotoPrimetime()
+				if config.epgselection.vertical_blue.value == "setbasetime":
+					self.setBasetime()
+				if config.epgselection.vertical_blue.value == "gotodatetime":
+					self.enterDateTime()
 			else:
 				self.addAutoTimer()
 
@@ -930,7 +1313,7 @@ class EPGSelection(Screen, HelpableScreen):
 		self.onCreate()
 
 	def eventViewCallback(self, setEvent, setService, val):
-		l = self['list']
+		l = self['list'+str(self.activeList)]
 		old = l.getCurrent()
 		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
 			self.updEvent(val, False)
@@ -959,7 +1342,7 @@ class EPGSelection(Screen, HelpableScreen):
 			self['list'].sortSingleEPG(int(config.epgselection.sort.value))
 
 	def OpenSingleEPG(self):
-		cur = self['list'].getCurrent()
+		cur = self['list'+str(self.activeList)].getCurrent()
 		if cur[0] is not None:
 			event = cur[0]
 			serviceref = cur[1].ref
@@ -970,7 +1353,7 @@ class EPGSelection(Screen, HelpableScreen):
 		try:
 			from Plugins.Extensions.IMDb.plugin import IMDB, IMDBEPGSelection
 			try:
-				cur = self['list'].getCurrent()
+				cur = self['list'+str(self.activeList)].getCurrent()
 				event = cur[0]
 				name = event.getEventName()
 			except:
@@ -984,7 +1367,7 @@ class EPGSelection(Screen, HelpableScreen):
 		try:
 			from Plugins.Extensions.EPGSearch.EPGSearch import EPGSearch
 			try:
-				cur = self['list'].getCurrent()
+				cur = self['list'+str(self.activeList)].getCurrent()
 				event = cur[0]
 				name = event.getEventName()
 			except:
@@ -996,7 +1379,7 @@ class EPGSelection(Screen, HelpableScreen):
 	def addAutoTimer(self):
 		try:
 			from Plugins.Extensions.AutoTimer.AutoTimerEditor import addAutotimerFromEvent
-			cur = self['list'].getCurrent()
+			cur = self['list'+str(self.activeList)].getCurrent()
 			event = cur[0]
 			if not event:
 				return
@@ -1009,7 +1392,7 @@ class EPGSelection(Screen, HelpableScreen):
 	def addAutoTimerSilent(self):
 		try:
 			from Plugins.Extensions.AutoTimer.AutoTimerEditor import addAutotimerFromEventSilent
-			cur = self['list'].getCurrent()
+			cur = self['list'+str(self.activeList)].getCurrent()
 			event = cur[0]
 			if not event:
 				return
@@ -1063,9 +1446,6 @@ class EPGSelection(Screen, HelpableScreen):
 		else:
 			autopoller = None
 			autotimer = None
-			
-	def timerAdd(self):
-		self.RecordTimerQuestion(True)
 
 	def timerAdd(self):
 		self.RecordTimerQuestion(True)
@@ -1090,7 +1470,7 @@ class EPGSelection(Screen, HelpableScreen):
 		self.refreshlist()
 
 	def RecordTimerQuestion(self, manual=False):
-		cur = self['list'].getCurrent()
+		cur = self['list'+str(self.activeList)].getCurrent()
 		event = cur[0]
 		serviceref = cur[1]
 		if event is None:
@@ -1103,11 +1483,12 @@ class EPGSelection(Screen, HelpableScreen):
 				foundtimer = timer
 				break
 		else:
-			eventBegin = event.getBeginTime()
-			eventDuration = event.getDuration()
-			x = self.session.nav.RecordTimer.isInTimer(eventid, eventBegin, eventDuration, refstr, True)
-			if x and x[1] in (2,7,12):
-				foundtimer = x[3]
+			if self.session.nav.isRecordTimerImageStandard:
+				eventBegin = event.getBeginTime()
+				eventDuration = event.getDuration()
+				x = self.session.nav.RecordTimer.isInTimer(eventid, eventBegin, eventDuration, refstr, True)
+				if x and x[1] in (2,7,12):
+					foundtimer = x[3]
 
 		if foundtimer:
 			timer = foundtimer
@@ -1131,8 +1512,8 @@ class EPGSelection(Screen, HelpableScreen):
 
 		if title:
 			self.ChoiceBoxDialog = self.session.instantiateDialog(ChoiceBox, title=title, list=menu, keys=['green', 'blue'], skin_name="RecordTimerQuestion")
-			serviceref = eServiceReference(str(self['list'].getCurrent()[1]))
-			pos = self['list'].getSelectionPosition(serviceref)
+			serviceref = eServiceReference(str(self['list'+str(self.activeList)].getCurrent()[1]))
+			pos = self['list'+str(self.activeList)].getSelectionPosition(serviceref, self.activeList)
 			posx = pos[0]
 			dialogwidth = self.ChoiceBoxDialog.instance.size().width()
 			if posx - dialogwidth < 0:
@@ -1199,7 +1580,7 @@ class EPGSelection(Screen, HelpableScreen):
 		self.doInstantTimer(1)
 
 	def doInstantTimer(self, zap):
-		cur = self['list'].getCurrent()
+		cur = self['list'+str(self.activeList)].getCurrent()
 		event = cur[0]
 		serviceref = cur[1]
 		if event is None:
@@ -1252,9 +1633,15 @@ class EPGSelection(Screen, HelpableScreen):
 			if self.zapnumberstarted:
 				self.dozumberzap()
 			else:
-				if config.epgselection.graph_ok.value == 'Zap' or config.epgselection.enhanced_ok.value == 'Zap' or config.epgselection.infobar_ok.value == 'Zap' or config.epgselection.multi_ok.value == 'Zap':
+				if self.type == EPG_TYPE_VERTICAL and 'Channel' in config.epgselection.vertical_ok.value:
+					self.infoKeyPressed()
+				elif ((self.type == EPG_TYPE_GRAPH and config.epgselection.graph_ok.value == 'Zap') or (self.type == EPG_TYPE_ENHANCED and config.epgselection.enhanced_ok.value == 'Zap') or
+				((self.type == EPG_TYPE_INFOBAR or self.type == EPG_TYPE_INFOBARGRAPH) and config.epgselection.infobar_ok.value == 'Zap') or
+				(self.type == EPG_TYPE_MULTI and config.epgselection.multi_ok.value == 'Zap') or (self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_ok.value == 'Zap')):
 					self.zapTo()
-				if config.epgselection.graph_ok.value == 'Zap + Exit' or config.epgselection.enhanced_ok.value == 'Zap + Exit' or config.epgselection.infobar_ok.value == 'Zap + Exit' or config.epgselection.multi_ok.value == 'Zap + Exit':
+				elif ((self.type == EPG_TYPE_GRAPH and config.epgselection.graph_ok.value == 'Zap + Exit') or (self.type == EPG_TYPE_ENHANCED and config.epgselection.enhanced_ok.value == 'Zap + Exit') or
+				((self.type == EPG_TYPE_INFOBAR or self.type == EPG_TYPE_INFOBARGRAPH) and config.epgselection.infobar_ok.value == 'Zap + Exit') or
+				(self.type == EPG_TYPE_MULTI and config.epgselection.multi_ok.value == 'Zap + Exit') or (self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_ok.value == 'Zap + Exit')):
 					self.zap()
 
 	def OKLong(self):
@@ -1264,9 +1651,15 @@ class EPGSelection(Screen, HelpableScreen):
 			if self.zapnumberstarted:
 				self.dozumberzap()
 			else:
-				if config.epgselection.graph_oklong.value == 'Zap' or config.epgselection.enhanced_oklong.value == 'Zap' or config.epgselection.infobar_oklong.value == 'Zap' or config.epgselection.multi_oklong.value == 'Zap':
+				if self.type == EPG_TYPE_VERTICAL and 'Channel' in config.epgselection.vertical_oklong.value:
+					self.infoKeyPressed()
+				elif ((self.type == EPG_TYPE_GRAPH and config.epgselection.graph_oklong.value == 'Zap') or (self.type == EPG_TYPE_ENHANCED and config.epgselection.enhanced_oklong.value == 'Zap') or
+				((self.type == EPG_TYPE_INFOBAR or self.type == EPG_TYPE_INFOBARGRAPH) and config.epgselection.infobar_oklong.value == 'Zap') or
+				(self.type == EPG_TYPE_MULTI and config.epgselection.multi_oklong.value == 'Zap') or (self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_oklong.value == 'Zap')):
 					self.zapTo()
-				if config.epgselection.graph_oklong.value == 'Zap + Exit' or config.epgselection.enhanced_oklong.value == 'Zap + Exit' or config.epgselection.infobar_oklong.value == 'Zap + Exit' or config.epgselection.multi_oklong.value == 'Zap + Exit':
+				elif ((self.type == EPG_TYPE_GRAPH and config.epgselection.graph_oklong.value == 'Zap + Exit') or (self.type == EPG_TYPE_ENHANCED and config.epgselection.enhanced_oklong.value == 'Zap + Exit') or
+				((self.type == EPG_TYPE_INFOBAR or self.type == EPG_TYPE_INFOBARGRAPH) and config.epgselection.infobar_oklong.value == 'Zap + Exit') or
+				(self.type == EPG_TYPE_MULTI and config.epgselection.multi_oklong.value == 'Zap + Exit') or (self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_oklong.value == 'Zap + Exit')):
 					self.zap()
 
 	def epgButtonPressed(self):
@@ -1276,9 +1669,9 @@ class EPGSelection(Screen, HelpableScreen):
 		from InfoBar import InfoBar
 		InfoBarInstance = InfoBar.instance
 		if not InfoBarInstance.LongButtonPressed:
-			if self.type == EPG_TYPE_GRAPH and config.epgselection.graph_info.value == 'Channel Info':
+			if (self.type == EPG_TYPE_GRAPH and config.epgselection.graph_info.value == 'Channel Info') or (self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_info.value == 'Channel Info'):
 				self.infoKeyPressed()
-			elif self.type == EPG_TYPE_GRAPH and config.epgselection.graph_info.value == 'Single EPG':
+			elif (self.type == EPG_TYPE_GRAPH and config.epgselection.graph_info.value == 'Single EPG') or (self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_info.value == 'Single EPG'):
 				self.OpenSingleEPG()
 			else:
 				self.infoKeyPressed()
@@ -1287,9 +1680,9 @@ class EPGSelection(Screen, HelpableScreen):
 		from InfoBar import InfoBar
 		InfoBarInstance = InfoBar.instance
 		if InfoBarInstance.LongButtonPressed:
-			if self.type == EPG_TYPE_GRAPH and config.epgselection.graph_infolong.value == 'Channel Info':
+			if (self.type == EPG_TYPE_GRAPH and config.epgselection.graph_infolong.value == 'Channel Info') or (self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_infolong.value == 'Channel Info'):
 				self.infoKeyPressed()
-			elif self.type == EPG_TYPE_GRAPH and config.epgselection.graph_infolong.value == 'Single EPG':
+			elif (self.type == EPG_TYPE_GRAPH and config.epgselection.graph_infolong.value == 'Single EPG') or (self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_infolong.value == 'Single EPG'):
 				self.OpenSingleEPG()
 			else:
 				self.OpenSingleEPG()
@@ -1327,7 +1720,9 @@ class EPGSelection(Screen, HelpableScreen):
 				self['more_button_sel'].hide()
 
 	def onSelectionChanged(self):
-		cur = self['list'].getCurrent()
+		if self.type != EPG_TYPE_VERTICAL:
+			self.activeList = ''
+		cur = self['list'+str(self.activeList)].getCurrent()
 		event = cur[0]
 		self['Event'].newEvent(event)
 		if cur[1] is None:
@@ -1376,11 +1771,12 @@ class EPGSelection(Screen, HelpableScreen):
 				isRecordEvent = True
 				break
 		else:
-			eventBegin = event.getBeginTime()
-			eventDuration = event.getDuration()
-			x = self.session.nav.RecordTimer.isInTimer(eventid, eventBegin, eventDuration, refstr)
-			if x and x[1] in (2,7,12):
-				isRecordEvent = True
+			if self.session.nav.isRecordTimerImageStandard:
+				eventBegin = event.getBeginTime()
+				eventDuration = event.getDuration()
+				x = self.session.nav.RecordTimer.isInTimer(eventid, eventBegin, eventDuration, refstr)
+				if x and x[1] in (2,7,12):
+					isRecordEvent = True
 
 		if isRecordEvent and self.key_green_choice != self.REMOVE_TIMER:
 			self.setTimerButtonText(_("Change timer"))
@@ -1415,7 +1811,7 @@ class EPGSelection(Screen, HelpableScreen):
 			del self.eventviewDialog
 			self.eventviewDialog = None
 
-	def closeScreen(self):
+	def closeScreen(self, NOCLOSE = False):
 		if self.type == EPG_TYPE_SINGLE:
 			self.close()
 			return # stop and do not continue.
@@ -1430,7 +1826,8 @@ class EPGSelection(Screen, HelpableScreen):
 				if ((self.type == EPG_TYPE_GRAPH and config.epgselection.graph_preview_mode.value) or 
 					(self.type == EPG_TYPE_MULTI and config.epgselection.multi_preview_mode.value) or 
 					(self.type in (EPG_TYPE_INFOBAR, EPG_TYPE_INFOBARGRAPH) and config.epgselection.infobar_preview_mode.value in ('1', '2')) or 
-					(self.type == EPG_TYPE_ENHANCED and config.epgselection.enhanced_preview_mode.value)):
+					(self.type == EPG_TYPE_ENHANCED and config.epgselection.enhanced_preview_mode.value) or
+					(self.type == EPG_TYPE_VERTICAL and config.epgselection.vertical_preview_mode.value)):
 					if '0:0:0:0:0:0:0:0:0' not in self.StartRef.toString():
 						self.zapFunc(None, zapback = True)
 				elif '0:0:0:0:0:0:0:0:0' in self.StartRef.toString():
@@ -1438,12 +1835,19 @@ class EPGSelection(Screen, HelpableScreen):
 				else:
 					self.zapFunc(None, False)
 		if self.session.pipshown:
+			self.Oldpipshown = False
 			self.session.pipshown = False
 			del self.session.pip
+		if self.Oldpipshown:
+			self.session.pipshown = True
 		self.closeEventViewDialog()
+		if self.type == EPG_TYPE_VERTICAL and NOCLOSE:
+			return
 		self.close(True)
 
 	def zap(self):
+		if self.session.nav.getCurrentlyPlayingServiceOrGroup() and '0:0:0:0:0:0:0:0:0' in self.session.nav.getCurrentlyPlayingServiceOrGroup().toString():
+			return
 		if self.zapFunc:
 			self.zapSelectedService()
 			self.closeEventViewDialog()
@@ -1458,10 +1862,12 @@ class EPGSelection(Screen, HelpableScreen):
 			self.prevch = self.session.pip.getCurrentService() and str(self.session.pip.getCurrentService().toString()) or None
 		else:
 			self.prevch = self.session.nav.getCurrentlyPlayingServiceReference() and str(self.session.nav.getCurrentlyPlayingServiceReference().toString()) or None
-		lst = self["list"]
+		lst = self["list"+str(self.activeList)]
 		count = lst.getCurrentChangeCount()
 		if count == 0:
 			ref = lst.getCurrent()[1]
+			if ref is None and self.type == EPG_TYPE_VERTICAL and self.myServices[0][0]:
+				ref = ServiceReference(self.myServices[self["list"].getSelectionIndex()+self.activeList-1][0])
 			if ref is not None:
 				if (self.type == EPG_TYPE_INFOBAR or self.type == EPG_TYPE_INFOBARGRAPH) and config.epgselection.infobar_preview_mode.value == '2':
 					if not prev:
@@ -1491,12 +1897,13 @@ class EPGSelection(Screen, HelpableScreen):
 				else:
 					self.zapFunc(ref.ref, bouquet = self.getCurrentBouquet(), preview = prev)
 					self.currch = self.session.nav.getCurrentlyPlayingServiceReference() and str(self.session.nav.getCurrentlyPlayingServiceReference().toString())
-				self['list'].setCurrentlyPlaying(self.session.nav.getCurrentlyPlayingServiceOrGroup())
+				self['list'+str(self.activeList)].setCurrentlyPlaying(self.session.nav.getCurrentlyPlayingServiceOrGroup())
 
 	def zapTo(self):
 		if self.session.nav.getCurrentlyPlayingServiceOrGroup() and '0:0:0:0:0:0:0:0:0' in self.session.nav.getCurrentlyPlayingServiceOrGroup().toString():
-			from Screens.InfoBarGenerics import setResumePoint
-			setResumePoint(self.session)
+			#from Screens.InfoBarGenerics import setResumePoint
+			#setResumePoint(self.session)
+			return
 		if self.zapFunc:
 			self.zapSelectedService(True)
 			self.refreshTimer.start(2000)
@@ -1511,34 +1918,45 @@ class EPGSelection(Screen, HelpableScreen):
 
 	def keyNumberGlobal(self, number):
 		if self.createTimer.isActive(): return
-		if self.type == EPG_TYPE_GRAPH:
+		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
+			if self.type == EPG_TYPE_GRAPH:
+				prevtimeperiod = config.epgselection.graph_prevtimeperiod
+				roundto = config.epgselection.graph_roundto
+				primetimehour = config.epgselection.graph_primetimehour
+				primetimemins = config.epgselection.graph_primetimemins
+			else:
+				prevtimeperiod = config.epgselection.infobar_prevtimeperiod
+				roundto = config.epgselection.infobar_roundto
+				primetimehour = config.epgselection.infobar_primetimehour
+				primetimemins = config.epgselection.infobar_primetimemins
+
 			if number == 1:
-				timeperiod = int(config.epgselection.graph_prevtimeperiod.value)
+				timeperiod = int(prevtimeperiod.value)
 				if timeperiod > 60:
 					timeperiod -= 60
 					self['list'].setEpoch(timeperiod)
-					config.epgselection.graph_prevtimeperiod.setValue(timeperiod)
+					prevtimeperiod.setValue(timeperiod)
 					self.moveTimeLines()
 			elif number == 2:
 				self.prevPage()
 			elif number == 3:
-				timeperiod = int(config.epgselection.graph_prevtimeperiod.value)
+				timeperiod = int(prevtimeperiod.value)
 				if timeperiod < 300:
 					timeperiod += 60
 					self['list'].setEpoch(timeperiod)
-					config.epgselection.graph_prevtimeperiod.setValue(timeperiod)
+					prevtimeperiod.setValue(timeperiod)
 					self.moveTimeLines()
 			elif number == 4:
 				self.updEvent(-2)
 			elif number == 5:
 				now = time() - int(config.epg.histminutes.value) * 60
-				self.ask_time = now - now % (int(config.epgselection.graph_roundto.value) * 60)
+				self.ask_time = now - now % (int(roundto.value) * 60)
 				self['list'].resetOffset()
-				self['list'].fillGraphEPG(None, self.ask_time)
+				self['list'].fillGraphEPG(None, self.ask_time, True)
 				self.moveTimeLines(True)
 			elif number == 6:
 				self.updEvent(+2)
-			elif number == 7:
+			elif number == 7 and self.type == EPG_TYPE_GRAPH:
 				if config.epgselection.graph_heightswitch.value:
 					config.epgselection.graph_heightswitch.setValue(False)
 				else:
@@ -1550,7 +1968,7 @@ class EPGSelection(Screen, HelpableScreen):
 				self.nextPage()
 			elif number == 9:
 				basetime = localtime(self['list'].getTimeBase())
-				basetime = (basetime[0], basetime[1], basetime[2], int(config.epgselection.graph_primetimehour.value), int(config.epgselection.graph_primetimemins.value), 0, basetime[6], basetime[7], basetime[8])
+				basetime = (basetime[0], basetime[1], basetime[2], int(primetimehour.value), int(primetimemins.value), 0, basetime[6], basetime[7], basetime[8])
 				self.ask_time = mktime(basetime)
 				if self.ask_time + 3600 < time():
 					self.ask_time += 86400
@@ -1560,55 +1978,33 @@ class EPGSelection(Screen, HelpableScreen):
 			elif number == 0:
 				self.toTop()
 				now = time() - int(config.epg.histminutes.value) * 60
-				self.ask_time = now - now % (int(config.epgselection.graph_roundto.value) * 60)
+				self.ask_time = now - now % (int(roundto.value) * 60)
 				self['list'].resetOffset()
-				self['list'].fillGraphEPG(None, self.ask_time)
+				self['list'].fillGraphEPG(None, self.ask_time, True)
 				self.moveTimeLines()
-		elif self.type == EPG_TYPE_INFOBARGRAPH:
+		elif self.type == EPG_TYPE_VERTICAL:
 			if number == 1:
-				timeperiod = int(config.epgselection.infobar_prevtimeperiod.value)
-				if timeperiod > 60:
-					timeperiod -= 60
-					self['list'].setEpoch(timeperiod)
-					config.epgselection.infobar_prevtimeperiod.setValue(timeperiod)
-					self.moveTimeLines()
+				self.gotoFirst()
 			elif number == 2:
-				self.prevPage()
+				self.allUp()
 			elif number == 3:
-				timeperiod = int(config.epgselection.infobar_prevtimeperiod.value)
-				if timeperiod < 300:
-					timeperiod += 60
-					self['list'].setEpoch(timeperiod)
-					config.epgselection.infobar_prevtimeperiod.setValue(timeperiod)
-					self.moveTimeLines()
+				self.gotoLast()
 			elif number == 4:
-				self.updEvent(-2)
-			elif number == 5:
-				now = time() - int(config.epg.histminutes.value) * 60
-				self.ask_time = now - now % (int(config.epgselection.infobar_roundto.value) * 60)
-				self['list'].resetOffset()
-				self['list'].fillGraphEPG(None, self.ask_time)
-				self.moveTimeLines(True)
+				self.prevPage(True)
+			elif number == 0:
+				if self.zapFunc:
+					self.closeScreen(True)
+				self.onCreate()
 			elif number == 6:
-				self.updEvent(+2)
+				self.nextPage(True)
+			elif number == 7:
+				self.gotoNow()
 			elif number == 8:
-				self.nextPage()
+				self.allDown()
 			elif number == 9:
-				basetime = localtime(self['list'].getTimeBase())
-				basetime = (basetime[0], basetime[1], basetime[2], int(config.epgselection.infobar_primetimehour.value), int(config.epgselection.infobar_primetimemins.value), 0, basetime[6], basetime[7], basetime[8])
-				self.ask_time = mktime(basetime)
-				if self.ask_time + 3600 < time():
-					self.ask_time += 86400
-				self['list'].resetOffset()
-				self['list'].fillGraphEPG(None, self.ask_time)
-				self.moveTimeLines(True)
-			elif number == 0:
-				self.toTop()
-				now = time() - int(config.epg.histminutes.value) * 60
-				self.ask_time = now - now % (int(config.epgselection.infobar_roundto.value) * 60)
-				self['list'].resetOffset()
-				self['list'].fillGraphEPG(None, self.ask_time)
-				self.moveTimeLines()
+				self.gotoPrimetime()
+			elif number == 5:
+				self.setBasetime()
 		else:
 			self.zapnumberstarted = True
 			self.NumberZapTimer.start(5000, True)
@@ -1680,89 +2076,191 @@ class EPGSelection(Screen, HelpableScreen):
 		self.onCreate()
 
 	def RefreshColouredKeys(self):
-		if config.epgselection.graph_red.value == "24plus":
-			self['key_red'] = Button(_('+24'))
-		elif config.epgselection.graph_red.value == "24minus":
-			self['key_red'] = Button(_('-24'))
-		elif config.epgselection.graph_red.value == "timer":
-			self['key_red'] = Button(_('Add Timer'))
-		elif config.epgselection.graph_red.value == "imdb" or config.epgselection.graph_red.value == None :
-			self['key_red'] = Button(_('IMDb Search'))
-		elif config.epgselection.graph_red.value == "autotimer":
-			self['key_red'] = Button(_('Add AutoTimer'))
-		elif config.epgselection.graph_red.value == "bouquetlist":
-			self['key_red'] = Button(_('BouquetList'))
-		elif config.epgselection.graph_red.value == "epgsearch":
-			self['key_red'] = Button(_('EPG Search'))
-		elif config.epgselection.graph_red.value == "showmovies":
-			self['key_red'] = Button(_('Recordings'))
-		elif config.epgselection.graph_red.value == "record":
-			self['key_red'] = Button(_('Record'))
-		elif config.epgselection.graph_red.value == "gotodatetime":
-			self['key_red'] = Button(_('Goto Date/Time'))
-
-		if config.epgselection.graph_green.value == "24plus":
-			self['key_green'] = Button(_('+24'))
-		elif config.epgselection.graph_green.value == "24minus":
-			self['key_green'] = Button(_('-24'))
-		elif config.epgselection.graph_green.value == "timer" or config.epgselection.graph_green.value == None :
-			self['key_green'] = Button(_('Add Timer'))
-		elif config.epgselection.graph_green.value == "imdb":
-			self['key_green'] = Button(_('IMDb Search'))
-		elif config.epgselection.graph_green.value == "autotimer":
-			self['key_green'] = Button(_('Add AutoTimer'))
-		elif config.epgselection.graph_green.value == "bouquetlist":
-			self['key_green'] = Button(_('BouquetList'))
-		elif config.epgselection.graph_green.value == "epgsearch":
-			self['key_green'] = Button(_('EPG Search'))
-		elif config.epgselection.graph_green.value == "showmovies":
-			self['key_green'] = Button(_('Recordings'))
-		elif config.epgselection.graph_green.value == "record":
-			self['key_green'] = Button(_('Record'))
-		elif config.epgselection.graph_green.value == "gotodatetime":
-			self['key_green'] = Button(_('Goto Date/Time'))
-
-		if config.epgselection.graph_yellow.value == "24plus":
-			self['key_yellow'] = Button(_('+24'))
-		elif config.epgselection.graph_yellow.value == "24minus":
-			self['key_yellow'] = Button(_('-24'))
-		elif config.epgselection.graph_yellow.value == "timer":
-			self['key_yellow'] = Button(_('Add Timer'))
-		elif config.epgselection.graph_yellow.value == "imdb":
-			self['key_yellow'] = Button(_('IMDb Search'))
-		elif config.epgselection.graph_yellow.value == "autotimer":
-			self['key_yellow'] = Button(_('Add AutoTimer'))
-		elif config.epgselection.graph_yellow.value == "bouquetlist":
-			self['key_yellow'] = Button(_('BouquetList'))
-		elif config.epgselection.graph_yellow.value == "epgsearch" or config.epgselection.graph_yellow.value == None :
-			self['key_yellow'] = Button(_('EPG Search'))
-		elif config.epgselection.graph_yellow.value == "showmovies":
-			self['key_yellow'] = Button(_('Recordings'))
-		elif config.epgselection.graph_yellow.value == "record":
-			self['key_yellow'] = Button(_('Record'))
-		elif config.epgselection.graph_yellow.value == "gotodatetime":
-			self['key_yellow'] = Button(_('Goto Date/Time'))
-
-		if config.epgselection.graph_blue.value == "24plus":
-			self['key_blue'] = Button(_('+24'))
-		elif config.epgselection.graph_blue.value == "24minus":
-			self['key_blue'] = Button(_('-24'))
-		elif config.epgselection.graph_blue.value == "timer":
-			self['key_blue'] = Button(_('Add Timer'))
-		elif config.epgselection.graph_blue.value == "imdb":
-			self['key_blue'] = Button(_('IMDb Search'))
-		elif config.epgselection.graph_blue.value == "autotimer" or config.epgselection.graph_blue.value == None :
-			self['key_blue'] = Button(_('Add AutoTimer'))
-		elif config.epgselection.graph_blue.value == "bouquetlist":
-			self['key_blue'] = Button(_('BouquetList'))
-		elif config.epgselection.graph_blue.value == "epgsearch":
-			self['key_blue'] = Button(_('EPG Search'))
-		elif config.epgselection.graph_blue.value == "showmovies":
-			self['key_blue'] = Button(_('Recordings'))
-		elif config.epgselection.graph_blue.value == "record":
-			self['key_blue'] = Button(_('Record'))
-		elif config.epgselection.graph_blue.value == "gotodatetime":
-			self['key_blue'] = Button(_('Goto Date/Time'))
+		if self.type == EPG_TYPE_GRAPH or self.type == EPG_TYPE_INFOBARGRAPH:
+			if config.epgselection.graph_red.value == "24plus":
+				self['key_red'] = Button(_('+24'))
+			elif config.epgselection.graph_red.value == "24minus":
+				self['key_red'] = Button(_('-24'))
+			elif config.epgselection.graph_red.value == "timer":
+				self['key_red'] = Button(_('Add Timer'))
+			elif config.epgselection.graph_red.value == "imdb" or config.epgselection.graph_red.value == None :
+				self['key_red'] = Button(_('IMDb Search'))
+			elif config.epgselection.graph_red.value == "autotimer":
+				self['key_red'] = Button(_('Add AutoTimer'))
+			elif config.epgselection.graph_red.value == "bouquetlist":
+				self['key_red'] = Button(_('BouquetList'))
+			elif config.epgselection.graph_red.value == "epgsearch":
+				self['key_red'] = Button(_('EPG Search'))
+			elif config.epgselection.graph_red.value == "showmovies":
+				self['key_red'] = Button(_('Recordings'))
+			elif config.epgselection.graph_red.value == "record":
+				self['key_red'] = Button(_('Record'))
+			elif config.epgselection.graph_red.value == "gotodatetime":
+				self['key_red'] = Button(_('Goto Date/Time'))
+
+			if config.epgselection.graph_green.value == "24plus":
+				self['key_green'] = Button(_('+24'))
+			elif config.epgselection.graph_green.value == "24minus":
+				self['key_green'] = Button(_('-24'))
+			elif config.epgselection.graph_green.value == "timer" or config.epgselection.graph_green.value == None :
+				self['key_green'] = Button(_('Add Timer'))
+			elif config.epgselection.graph_green.value == "imdb":
+				self['key_green'] = Button(_('IMDb Search'))
+			elif config.epgselection.graph_green.value == "autotimer":
+				self['key_green'] = Button(_('Add AutoTimer'))
+			elif config.epgselection.graph_green.value == "bouquetlist":
+				self['key_green'] = Button(_('BouquetList'))
+			elif config.epgselection.graph_green.value == "epgsearch":
+				self['key_green'] = Button(_('EPG Search'))
+			elif config.epgselection.graph_green.value == "showmovies":
+				self['key_green'] = Button(_('Recordings'))
+			elif config.epgselection.graph_green.value == "record":
+				self['key_green'] = Button(_('Record'))
+			elif config.epgselection.graph_green.value == "gotodatetime":
+				self['key_green'] = Button(_('Goto Date/Time'))
+
+			if config.epgselection.graph_yellow.value == "24plus":
+				self['key_yellow'] = Button(_('+24'))
+			elif config.epgselection.graph_yellow.value == "24minus":
+				self['key_yellow'] = Button(_('-24'))
+			elif config.epgselection.graph_yellow.value == "timer":
+				self['key_yellow'] = Button(_('Add Timer'))
+			elif config.epgselection.graph_yellow.value == "imdb":
+				self['key_yellow'] = Button(_('IMDb Search'))
+			elif config.epgselection.graph_yellow.value == "autotimer":
+				self['key_yellow'] = Button(_('Add AutoTimer'))
+			elif config.epgselection.graph_yellow.value == "bouquetlist":
+				self['key_yellow'] = Button(_('BouquetList'))
+			elif config.epgselection.graph_yellow.value == "epgsearch" or config.epgselection.graph_yellow.value == None :
+				self['key_yellow'] = Button(_('EPG Search'))
+			elif config.epgselection.graph_yellow.value == "showmovies":
+				self['key_yellow'] = Button(_('Recordings'))
+			elif config.epgselection.graph_yellow.value == "record":
+				self['key_yellow'] = Button(_('Record'))
+			elif config.epgselection.graph_yellow.value == "gotodatetime":
+				self['key_yellow'] = Button(_('Goto Date/Time'))
+
+			if config.epgselection.graph_blue.value == "24plus":
+				self['key_blue'] = Button(_('+24'))
+			elif config.epgselection.graph_blue.value == "24minus":
+				self['key_blue'] = Button(_('-24'))
+			elif config.epgselection.graph_blue.value == "timer":
+				self['key_blue'] = Button(_('Add Timer'))
+			elif config.epgselection.graph_blue.value == "imdb":
+				self['key_blue'] = Button(_('IMDb Search'))
+			elif config.epgselection.graph_blue.value == "autotimer" or config.epgselection.graph_blue.value == None :
+				self['key_blue'] = Button(_('Add AutoTimer'))
+			elif config.epgselection.graph_blue.value == "bouquetlist":
+				self['key_blue'] = Button(_('BouquetList'))
+			elif config.epgselection.graph_blue.value == "epgsearch":
+				self['key_blue'] = Button(_('EPG Search'))
+			elif config.epgselection.graph_blue.value == "showmovies":
+				self['key_blue'] = Button(_('Recordings'))
+			elif config.epgselection.graph_blue.value == "record":
+				self['key_blue'] = Button(_('Record'))
+			elif config.epgselection.graph_blue.value == "gotodatetime":
+				self['key_blue'] = Button(_('Goto Date/Time'))
+
+		elif self.type == EPG_TYPE_VERTICAL:
+			if config.epgselection.vertical_red.value == "24plus":
+				self['key_red'] = Button(_('+24'))
+			elif config.epgselection.vertical_red.value == "24minus":
+				self['key_red'] = Button(_('-24'))
+			elif config.epgselection.vertical_red.value == "timer":
+				self['key_red'] = Button(_('Add Timer'))
+			elif config.epgselection.vertical_red.value == "imdb" or config.epgselection.vertical_red.value == None :
+				self['key_red'] = Button(_('IMDb Search'))
+			elif config.epgselection.vertical_red.value == "autotimer":
+				self['key_red'] = Button(_('Add AutoTimer'))
+			elif config.epgselection.vertical_red.value == "bouquetlist":
+				self['key_red'] = Button(_('BouquetList'))
+			elif config.epgselection.vertical_red.value == "epgsearch":
+				self['key_red'] = Button(_('EPG Search'))
+			elif config.epgselection.vertical_red.value == "showmovies":
+				self['key_red'] = Button(_('Recordings'))
+			elif config.epgselection.vertical_red.value == "record":
+				self['key_red'] = Button(_('Record'))
+			elif config.epgselection.vertical_red.value == "gotoprimetime":
+				self['key_red'] = Button(_('Goto Primetime'))
+			elif config.epgselection.vertical_red.value == "setbasetime":
+				self['key_red'] = Button(_('Set Basetime'))
+			elif config.epgselection.vertical_red.value == "gotodatetime":
+				self['key_red'] = Button(_('Goto Date/Time'))
+
+			if config.epgselection.vertical_green.value == "24plus":
+				self['key_green'] = Button(_('+24'))
+			elif config.epgselection.vertical_green.value == "24minus":
+				self['key_green'] = Button(_('-24'))
+			elif config.epgselection.vertical_green.value == "timer" or config.epgselection.vertical_green.value == None :
+				self['key_green'] = Button(_('Add Timer'))
+			elif config.epgselection.vertical_green.value == "imdb":
+				self['key_green'] = Button(_('IMDb Search'))
+			elif config.epgselection.vertical_green.value == "autotimer":
+				self['key_green'] = Button(_('Add AutoTimer'))
+			elif config.epgselection.vertical_green.value == "bouquetlist":
+				self['key_green'] = Button(_('BouquetList'))
+			elif config.epgselection.vertical_green.value == "epgsearch":
+				self['key_green'] = Button(_('EPG Search'))
+			elif config.epgselection.vertical_green.value == "showmovies":
+				self['key_green'] = Button(_('Recordings'))
+			elif config.epgselection.vertical_green.value == "record":
+				self['key_green'] = Button(_('Record'))
+			elif config.epgselection.vertical_green.value == "gotoprimetime":
+				self['key_green'] = Button(_('Goto Primetime'))
+			elif config.epgselection.vertical_green.value == "setbasetime":
+				self['key_green'] = Button(_('Set Basetime'))
+			elif config.epgselection.vertical_green.value == "gotodatetime":
+				self['key_green'] = Button(_('Goto Date/Time'))
+
+			if config.epgselection.vertical_yellow.value == "24plus":
+				self['key_yellow'] = Button(_('+24'))
+			elif config.epgselection.vertical_yellow.value == "24minus":
+				self['key_yellow'] = Button(_('-24'))
+			elif config.epgselection.vertical_yellow.value == "timer":
+				self['key_yellow'] = Button(_('Add Timer'))
+			elif config.epgselection.vertical_yellow.value == "imdb":
+				self['key_yellow'] = Button(_('IMDb Search'))
+			elif config.epgselection.vertical_yellow.value == "autotimer":
+				self['key_yellow'] = Button(_('Add AutoTimer'))
+			elif config.epgselection.vertical_yellow.value == "bouquetlist":
+				self['key_yellow'] = Button(_('BouquetList'))
+			elif config.epgselection.vertical_yellow.value == "epgsearch" or config.epgselection.vertical_yellow.value == None :
+				self['key_yellow'] = Button(_('EPG Search'))
+			elif config.epgselection.vertical_yellow.value == "showmovies":
+				self['key_yellow'] = Button(_('Recordings'))
+			elif config.epgselection.vertical_yellow.value == "record":
+				self['key_yellow'] = Button(_('Record'))
+			elif config.epgselection.vertical_yellow.value == "gotoprimetime":
+				self['key_yellow'] = Button(_('Goto Primetime'))
+			elif config.epgselection.vertical_yellow.value == "setbasetime":
+				self['key_yellow'] = Button(_('Set Basetime'))
+			elif config.epgselection.vertical_yellow.value == "gotodatetime":
+				self['key_yellow'] = Button(_('Goto Date/Time'))
+
+			if config.epgselection.vertical_blue.value == "24plus":
+				self['key_blue'] = Button(_('+24'))
+			elif config.epgselection.vertical_blue.value == "24minus":
+				self['key_blue'] = Button(_('-24'))
+			elif config.epgselection.vertical_blue.value == "timer":
+				self['key_blue'] = Button(_('Add Timer'))
+			elif config.epgselection.vertical_blue.value == "imdb":
+				self['key_blue'] = Button(_('IMDb Search'))
+			elif config.epgselection.vertical_blue.value == "autotimer" or config.epgselection.vertical_blue.value == None :
+				self['key_blue'] = Button(_('Add AutoTimer'))
+			elif config.epgselection.vertical_blue.value == "bouquetlist":
+				self['key_blue'] = Button(_('BouquetList'))
+			elif config.epgselection.vertical_blue.value == "epgsearch":
+				self['key_blue'] = Button(_('EPG Search'))
+			elif config.epgselection.vertical_blue.value == "showmovies":
+				self['key_blue'] = Button(_('Recordings'))
+			elif config.epgselection.vertical_blue.value == "record":
+				self['key_blue'] = Button(_('Record'))
+			elif config.epgselection.vertical_blue.value == "gotoprimetime":
+				self['key_blue'] = Button(_('Goto Primetime'))
+			elif config.epgselection.vertical_blue.value == "setbasetime":
+				self['key_blue'] = Button(_('Set Basetime'))
+			elif config.epgselection.vertical_blue.value == "gotodatetime":
+				self['key_blue'] = Button(_('Goto Date/Time'))
 
 	def setTimerButtonText(self, text = None):
 		if text == None:
@@ -1776,9 +2274,386 @@ class EPGSelection(Screen, HelpableScreen):
 				self["key_yellow"].setText(text)
 			if config.epgselection.graph_blue.value == 'timer':
 				self["key_blue"].setText(text)
+		elif self.type == EPG_TYPE_VERTICAL:
+			if config.epgselection.vertical_red.value == 'timer':
+				self["key_red"].setText(text)
+			if config.epgselection.vertical_green.value == 'timer':
+				self["key_green"].setText(text)
+			if config.epgselection.vertical_yellow.value == 'timer':
+				self["key_yellow"].setText(text)
+			if config.epgselection.vertical_blue.value == 'timer':
+				self["key_blue"].setText(text)
 		else:
 			self['key_green'].setText(text)
 
+	def getChannels(self):
+		self.list = []
+		self.myServices = []
+		idx = 0
+		for service in self.services:
+			idx = idx + 1
+			info = service.info()
+			servicename = info.getName(service.ref).replace('\xc2\x86', '').replace('\xc2\x87', '')
+			self.list.append(str(idx) + ". " + servicename)
+			self.myServices.append((service.ref.toString(),servicename))
+		if not idx:
+			self.list.append('')
+			self.myServices.append(('',''))
+		return self.list
+
+	def updateVerticalEPG(self, force = False):
+		self.displayActiveEPG()
+		stime = None
+		now = time()
+		if force or self.ask_time >= now - config.epg.histminutes.value*60:
+			stime = self.ask_time
+		prgIndex = self["list"].getSelectionIndex()
+		CurrentPrg = self.myServices[prgIndex]
+		x = len(self.list)-1
+		if x >= 0 and CurrentPrg[0]:
+			self["list1"].show()
+			self["currCh1"].setText(str(CurrentPrg[1]))
+			l = self["list1"]
+			l.recalcEntrySize()
+			myService = ServiceReference(CurrentPrg[0])
+			self["piconCh1"].newService(myService.ref)
+			l.fillSingleEPG(myService, stime)
+		else:
+			self["Active1"].hide()
+			self["piconCh1"].newService(None)
+			self["currCh1"].setText(str(" "))
+			self["list1"].hide()
+		prgIndex = prgIndex + 1
+		if prgIndex < (x+1):
+			self["list2"].show()
+			CurrentPrg = self.myServices[prgIndex]
+			self["currCh2"].setText(str(CurrentPrg[1]))
+			l = self["list2"]
+			l.recalcEntrySize()
+			myService = ServiceReference(CurrentPrg[0])
+			self["piconCh2"].newService(myService.ref)
+			l.fillSingleEPG(myService, stime)
+		else:
+			self["piconCh2"].newService(None)
+			self["currCh2"].setText(str(" "))
+			self["list2"].hide()
+		prgIndex = prgIndex + 1
+		if prgIndex < (x+1):
+			self["list3"].show()
+			CurrentPrg = self.myServices[prgIndex]
+			self["currCh3"].setText(str(CurrentPrg[1]))
+			l = self["list3"]
+			l.recalcEntrySize()
+			myService = ServiceReference(CurrentPrg[0])
+			self["piconCh3"].newService(myService.ref)
+			l.fillSingleEPG(myService, stime)
+		else:
+			self["piconCh3"].newService(None)
+			self["currCh3"].setText(str(" "))
+			self["list3"].hide()
+		if self.Fields == 6:
+			prgIndex = prgIndex + 1
+			if prgIndex < (x+1):
+				self["list4"].show()
+				CurrentPrg = self.myServices[prgIndex]
+				self["currCh4"].setText(str(CurrentPrg[1]))
+				l = self["list4"]
+				l.recalcEntrySize()
+				myService = ServiceReference(CurrentPrg[0])
+				self["piconCh4"].newService(myService.ref)
+				l.fillSingleEPG(myService, stime)
+			else:
+				self["piconCh4"].newService(None)
+				self["currCh4"].setText(str(" "))
+				self["piconCh4"].newService(None)
+				self["list4"].hide()
+			prgIndex = prgIndex + 1
+			if prgIndex < (x+1):
+				self["list5"].show()
+				CurrentPrg = self.myServices[prgIndex]
+				self["currCh5"].setText(str(CurrentPrg[1]))
+				l = self["list5"]
+				l.recalcEntrySize()
+				myService = ServiceReference(CurrentPrg[0])
+				self["piconCh5"].newService(myService.ref)
+				l.fillSingleEPG(myService, stime)
+			else:
+				self["piconCh5"].newService(None)
+				self["currCh5"].setText(str(" "))
+				self["list5"].hide()
+		else:
+			self["currCh4"].setText(str(" "))
+			self["list4"].hide()
+			self["Active4"].hide()
+			self["currCh5"].setText(str(" "))
+			self["list5"].hide()
+			self["Active5"].hide()
+
+	def displayActiveEPG(self):
+		marker = config.epgselection.vertical_eventmarker.value
+		for list in range(1,self.Fields):
+			if list == self.activeList:
+				self["list"+str(list)].selectionEnabled(True)
+				self["Active"+str(list)].show()
+			else:
+				self["Active"+str(list)].hide()
+				self["list"+str(list)].selectionEnabled(marker)
+
+	def getActivePrg(self):
+		return self["list"].getSelectionIndex()+(self.activeList-1)
+
+	def allUp(self):
+		if self.getEventTime(self.activeList)[0] is None:
+			return
+		idx = self['list'+str(self.activeList)].getCurrentIndex()
+		if not idx:
+			tmp = self.lastEventTime
+			self.setMinus24h(True, 6)
+			self.lastEventTime = tmp
+			self.gotoLasttime()
+		for list in range(1,self.Fields):
+			self['list'+str(list)].moveTo(self['list'+str(list)].instance.pageUp)
+		self.syncUp(idx)
+		self.saveLastEventTime()
+
+	def syncUp(self, idx):
+		idx = self['list'+str(self.activeList)].getCurrentIndex()
+		curTime = self.getEventTime(self.activeList)[0]
+		for list in range(1,self.Fields):
+			if list == self.activeList:
+				continue
+			for x in range(0,int(idx/config.epgselection.vertical_itemsperpage.value)):
+				evTime = self.getEventTime(list)[0]
+				if curTime is None or evTime is None or curTime <= evTime:
+					self['list'+str(list)].moveTo(self['list'+str(list)].instance.pageUp)
+				evTime = self.getEventTime(list)[0]
+				if curTime is None or evTime is None or curTime >= evTime:
+					break
+
+	def syncDown(self, idx):
+		curTime = self.getEventTime(self.activeList)[0]
+		for list in range(1,self.Fields):
+			if list == self.activeList:
+				continue
+			for x in range(0,int(idx/config.epgselection.vertical_itemsperpage.value)):
+				evTime = self.getEventTime(list)[0]
+				if curTime is None or evTime is None or curTime >= evTime:
+					self['list'+str(list)].moveTo(self['list'+str(list)].instance.pageDown)
+				evTime = self.getEventTime(list)[0]
+				if curTime is None or evTime is None or curTime <= evTime:
+					break
+
+	def allDown(self):
+		if self.getEventTime(self.activeList)[0] is None:
+			return
+		for list in range(1,self.Fields):
+			self['list'+str(list)].moveTo(self['list'+str(list)].instance.pageDown)
+		idx = self['list'+str(self.activeList)].getCurrentIndex()
+		self.syncDown(idx)
+		self.saveLastEventTime()
+
+	def gotoNow(self):
+		self.ask_time = time()
+		self.updateVerticalEPG()
+		self.saveLastEventTime()
+
+	def gotoFirst(self):
+		self["list"].moveToIndex(0)
+		self.activeList = 1
+		self.updateVerticalEPG()
+
+	def gotoLast(self):
+		idx = len(self.list)
+		page = idx/(self.Fields-1)
+		row = idx%(self.Fields-1)
+		if row:
+			self.activeList = row
+		else:
+			page-=1
+			self.activeList = self.Fields-1
+		self["list"].moveToIndex(0)
+		for i in range(0,page):
+			self["list"].pageDown()
+		self.updateVerticalEPG()
+
+	def setPrimetime(self, stime):
+		if stime is None:
+			stime = time()
+		t = localtime(stime)
+		primetime = mktime((t[0],t[1],t[2],config.epgselection.vertical_primetimehour.value,config.epgselection.vertical_primetimemins.value,0,t[6],t[7],t[8]))
+		return primetime
+
+	def findMaxEventTime(self, stime):
+		curr = self['list'+str(self.activeList)].getSelectedEventId()
+		self['list'+str(self.activeList)].moveTo(self['list'+str(self.activeList)].instance.moveEnd)
+		maxtime = self.getEventTime(self.activeList)[0]
+		self['list'+str(self.activeList)].moveToEventId(curr)
+		return maxtime is not None and maxtime >= stime
+
+	def findMinEventTime(self, stime):
+		curr = self['list'+str(self.activeList)].getSelectedEventId()
+		self['list'+str(self.activeList)].moveTo(self['list'+str(self.activeList)].instance.moveTop)
+		mintime = self.getEventTime(self.activeList)[0]
+		self['list'+str(self.activeList)].moveToEventId(curr)
+		return mintime is not None and mintime <= stime
+
+	def isInTimeRange(self, stime):
+		return self.findMaxEventTime(stime) and self.findMinEventTime(stime)
+
+	def setPlus24h(self):
+		oneDay = 24*3600
+		ev_begin, ev_end = self.getEventTime(self.activeList)
+
+		if ev_begin is not None:
+			if self.findMaxEventTime(ev_begin+oneDay):
+				primetime = self.setPrimetime(ev_begin)
+				if primetime >= ev_begin and primetime < ev_end:
+					self.ask_time = primetime + oneDay
+				else:
+					self.ask_time = ev_begin + oneDay
+				self.updateVerticalEPG()
+			else:
+				self['list'+str(self.activeList)].moveTo(self['list'+str(self.activeList)].instance.moveEnd)
+			self.saveLastEventTime()
+
+	def setMinus24h(self, force = False, daypart = 1):
+		now = time()
+		oneDay =  24*3600/daypart
+		if not self.lastMinus:
+			self.lastMinus = oneDay
+		ev_begin, ev_end = self.getEventTime(self.activeList)
+
+		if ev_begin is not None:
+			if ev_begin - oneDay < now:
+				self.ask_time = -1
+			else:
+				if self['list'+str(self.activeList)].getCurrentIndex() and not force and self.findMinEventTime(ev_begin - oneDay):
+					self.lastEventTime = ev_begin - oneDay, ev_end - oneDay
+					self.gotoLasttime()
+					return
+				else:
+					pt = 0
+					if self.ask_time == ev_begin - self.lastMinus:
+						self.lastMinus += self.lastMinus
+					else:
+						primetime = self.setPrimetime(ev_begin)
+						if primetime >= ev_begin and primetime < ev_end:
+							self.ask_time = pt = primetime - oneDay
+						self.lastMinus = oneDay
+					if not pt:
+						self.ask_time = ev_begin - self.lastMinus
+			self.updateVerticalEPG()
+			self.saveLastEventTime()
+
+	def setBasetime(self):
+		ev_begin, ev_end = self.getEventTime(self.activeList)
+		if ev_begin is not None:
+			self.ask_time = ev_begin
+			self.updateVerticalEPG()
+
+	def gotoPrimetime(self):
+		idx = 0
+		now = time()
+		oneDay = 24*3600
+		if self.firststart:
+			self.ask_time = self.setPrimetime(now)
+			self['list'+str(self.activeList)].moveTo(self['list'+str(self.activeList)].instance.moveTop)
+			ev_begin = self.getEventTime(self.activeList)[0]
+			if ev_begin is not None and ev_begin > self.ask_time:
+				self.ask_time += oneDay
+			self.updateVerticalEPG()
+			self.saveLastEventTime()
+			return
+
+		ev_begin, ev_end = self.getEventTime(self.activeList)
+		if ev_begin is None:
+			return
+		for list in range(1, self.Fields):
+			idx += self['list'+str(list)].getCurrentIndex()
+
+		primetime = self.setPrimetime(ev_begin)
+
+		onlyPT = False #key press primetime always sync
+		gotoNow = False #False -> -24h List expanded, True -> got to current event and sync (onlyPT must set to False!)
+		rPM = self.isInTimeRange(primetime-oneDay)
+		rPT = self.isInTimeRange(primetime)
+		rPP = self.isInTimeRange(primetime+oneDay)
+		if rPM or rPT or rPP:
+			if onlyPT or idx or not (primetime >= ev_begin and primetime < ev_end): #not sync or not primetime:
+				if rPT:
+					self.ask_time = primetime
+				elif rPP:
+					self.ask_time = primetime + oneDay
+				elif rPM:
+					self.ask_time = primetime - oneDay
+				self.updateVerticalEPG(True)
+			else:
+				if gotoNow:
+					self.gotoNow()
+					return
+				else:
+					self['list'+str(self.activeList)].moveTo(self['list'+str(self.activeList)].instance.moveTop)
+					self.setMinus24h(True, 6)
+					for list in range(1, self.Fields):
+						self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveEnd)
+						cnt = self['list'+str(list)].getCurrentIndex()
+						self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveTop)
+						self.findPrimetime(cnt, list, primetime)
+			self.saveLastEventTime()
+
+	def gotoLasttime(self, list = 0):
+		if list:
+			self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveEnd)
+			cnt = self['list'+str(list)].getCurrentIndex()
+			self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveTop)
+			self.findLasttime(cnt, list)
+		else:
+			for list in range(1, self.Fields):
+				self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveEnd)
+				cnt = self['list'+str(list)].getCurrentIndex()
+				self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveTop)
+				self.findLasttime(cnt, list)
+
+	def findLasttime(self, cnt, list, idx = 0):
+		last_begin, last_end = self.lastEventTime
+		for events in range(0,idx):
+			self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveDown)
+		for events in range(idx, cnt):
+			ev_begin, ev_end = self.getEventTime(list)
+			if ev_begin is not None:
+				if (ev_begin <= last_begin and ev_end > last_begin) or (ev_end >= last_end):
+					break
+				self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveDown)
+			else:
+				break
+
+	def findPrimetime(self, cnt, list, primetime):
+		for events in range(0, cnt):
+			ev_begin, ev_end = self.getEventTime(list)
+			if ev_begin is not None:
+				if (primetime >= ev_begin and primetime < ev_end):
+					break
+				self['list'+str(list)].moveTo(self['list'+str(list)].instance.moveDown)
+			else:
+				break
+
+	def saveLastEventTime(self, list = 0):
+		if not list:
+			list = self.activeList
+		now = time()
+		last = self.lastEventTime
+		self.lastEventTime = self.getEventTime(list)
+		if self.lastEventTime[0] is None and last[0] is not None:
+			self.lastEventTime = last
+		elif last[0] is None:
+			self.lastEventTime = (now, now+3600)
+
+	def getEventTime(self, list):
+		tmp = self['list'+str(list)].l.getCurrentSelection()
+		if tmp is None:
+			return None, None
+		return tmp[2], tmp[2]+tmp[3] #event begin, event end
+
 class SingleEPG(EPGSelection):
 	def __init__(self, session, service, EPGtype="single"):
 		EPGSelection.__init__(self, session, service=service, EPGtype=EPGtype)
diff --git a/lib/python/Screens/EventView.py b/lib/python/Screens/EventView.py
index 4dcc3be..f8dc6ff 100644
--- a/lib/python/Screens/EventView.py
+++ b/lib/python/Screens/EventView.py
@@ -250,19 +250,35 @@ class EventViewBase:
 
 		if not beginTimeString:
 			return
-		if beginTimeString.find(', ') > -1:
-			begintime = beginTimeString.split(', ')[1].split(':')
-			begindate = beginTimeString.split(', ')[0].split('.')
-		else:
-			if len(beginTimeString.split(' ')) > 1:
-				begintime = beginTimeString.split(' ')[1].split(':')
-			else:
-				return
-			begindate = beginTimeString.split(' ')[0].split('.')
+		begintime = begindate = []
+		for x in beginTimeString.split(' '):
+			x = x.rstrip(',').rstrip('.')
+			if ':' in x:
+				begintime = x.split(':')
+			elif '.' in x:
+				begindate = x.split('.')
+			elif '/' in x:
+				begindate = x.split('/')
+				begindate.reverse()
+		###check
+		fail = False
+		try:
+			if len(begintime) < 2 and len(begindate) < 2 or int(begintime[0]) > 23 or int(begintime[1]) > 59 or int(begindate[0]) > 31 or int(begindate[1]) > 12:
+				fail = True
+		except:
+			fail = True
+
+		if fail:
+			print 'wrong timestamp detected: source = %s ,date = %s ,time = %s' %(beginTimeString,begindate,begintime)
+			return
+		###
+
 		nowt = time()
 		now = localtime(nowt)
+
 		begin = localtime(int(mktime((now.tm_year, int(begindate[1]), int(begindate[0]), int(begintime[0]), int(begintime[1]), 0, now.tm_wday, now.tm_yday, now.tm_isdst))))
 		end = localtime(int(mktime((now.tm_year, int(begindate[1]), int(begindate[0]), int(begintime[0]), int(begintime[1]), 0, now.tm_wday, now.tm_yday, now.tm_isdst))) + event.getDuration())
+
 		self["datetime"].setText(strftime(_("%d.%m.   "), begin) + strftime(_("%-H:%M - "), begin) + strftime(_("%-H:%M"), end))
 		self["duration"].setText(_("%d min")%(event.getDuration()/60))
 		if self.SimilarBroadcastTimer is not None:
@@ -305,7 +321,7 @@ class EventViewBase:
 			ret.sort(self.sort_func)
 			for x in ret:
 				t = localtime(x[1])
-				text += _('\n%d.%d.%d, %2d:%02d  -  %s')%(t[2], t[1], t[0], t[3], t[4], x[0])
+				text += strftime(_("\n%Y/%m/%d  %H:%M - "), t) + x[0]
 			descr = self["epg_description"]
 			descr.setText(descr.getText()+text)
 			descr = self["FullDescription"]
diff --git a/lib/python/Screens/InfoBar.py b/lib/python/Screens/InfoBar.py
index 52fd6c1..4750dac 100755
--- a/lib/python/Screens/InfoBar.py
+++ b/lib/python/Screens/InfoBar.py
@@ -75,9 +75,11 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 				'HarddiskSetup': (self.HarddiskSetup, _('Select HDD')),	
 				"showWWW": (self.showPORTAL, _("Open MediaPortal...")),
 				"showSetup": (self.showSetup, _("Show setup...")),
+				"showInformation": (self.showInformation, _("Show Information...")),
 				"showFormat": (self.showFormat, _("Show Format Setup...")),
 				"showPluginBrowser": (self.showPluginBrowser, _("Show the plugins...")),
 				"showBoxPortal": (self.showBoxPortal, _("Show Box Portal...")),
+				"openSimpleUnmount": (self.openSimpleUnmount, _("Simple umounter mass storage device.")),
 			}, prio=2)
 
 		self["key_red"] = Label()
@@ -310,6 +312,15 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 		except Exception, e:
 			self.session.open(MessageBox, _("The IMDb plugin is not installed!\nPlease install it."), type = MessageBox.TYPE_INFO,timeout = 10 )
 
+	def openSimpleUnmount(self):
+		try:
+			for plugin in plugins.getPlugins([PluginDescriptor.WHERE_PLUGINMENU ,PluginDescriptor.WHERE_EXTENSIONSMENU, PluginDescriptor.WHERE_EVENTINFO]):
+				if plugin.name == _("SimpleUmount"):
+					self.runPlugin(plugin)
+					break
+		except Exception, e:
+			self.session.open(MessageBox, _("The SimpleUmount plugin is not installed!\nPlease install it."), type = MessageBox.TYPE_INFO,timeout = 10 )
+
 	def ZoomInOut(self):
 		zoomval = 0
 		if self.zoomrate > 3:
@@ -363,6 +374,18 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 					self.session.open(MainMenu, x)
 					return
 
+	def showInformation(self):
+		from Screens.Menu import MainMenu, mdom
+		root = mdom.getroot()
+		for x in root.findall("menu"):
+			y = x.find("id")
+			if y is not None:
+				id = y.get("val")
+				if id and id == "information":
+					self.session.infobar = self
+					self.session.open(MainMenu, x)
+					return
+
 	def showFormat(self):
 		try:
 			from Plugins.SystemPlugins.Videomode.plugin import videoSetupMain
diff --git a/lib/python/Screens/InfoBarGenerics.py b/lib/python/Screens/InfoBarGenerics.py
index 9e34c51..539f7fb 100644
--- a/lib/python/Screens/InfoBarGenerics.py
+++ b/lib/python/Screens/InfoBarGenerics.py
@@ -507,7 +507,10 @@ class SecondInfoBar(Screen):
 			description += '\n'
 		elif description and not extended:
 			extended = description
-		text = description + extended
+		if description == extended:
+			text = description
+		else:
+			text = description + extended
 		self.setTitle(event.getEventName())
 		self["epg_description"].setText(text)
 		self["FullDescription"].setText(extended)
@@ -1055,8 +1058,8 @@ class NumberZap(Screen):
 			self["servicename"].setText(ServiceReference(self.service).getServiceName())
 
 	def keyNumberGlobal(self, number):
-		if config.usage.numzaptimeoutmode.value is not "off":
-			if config.usage.numzaptimeoutmode.value is "standard":
+		if config.usage.numzaptimeoutmode.value != "off":
+			if config.usage.numzaptimeoutmode.value == "standard":
 				self.Timer.start(1000, True)
 			else:
 				self.Timer.start(config.usage.numzaptimeout2.value, True)
@@ -1072,7 +1075,9 @@ class NumberZap(Screen):
 			self.showPicon()
 
 		if len(self.numberString) >= int(config.usage.maxchannelnumlen.value):
-			self.keyOK()
+			if self.Timer.isActive():
+				self.Timer.stop()
+			self.Timer.start(100, True)
 
 	def showPicon(self):
 		self["Service"].newService(self.service)
@@ -1121,8 +1126,10 @@ class NumberZap(Screen):
 
 		self.Timer = eTimer()
 		self.Timer.callback.append(self.keyOK)
-		if config.usage.numzaptimeoutmode.value is not "off":
-			if config.usage.numzaptimeoutmode.value is "standard":
+		if config.usage.maxchannelnumlen.value == "1":
+			self.Timer.start(100, True)
+		elif config.usage.numzaptimeoutmode.value != "off":
+			if config.usage.numzaptimeoutmode.value == "standard":
 				self.Timer.start(3000, True)
 			else:
 				self.Timer.start(config.usage.numzaptimeout1.value, True)
@@ -1578,6 +1585,7 @@ class InfoBarMenu:
 				"showNetworkSetup": (self.showNetworkMounts, _("Show network mounts ...")),
 				"showSystemSetup": (self.showSystemMenu, _("Show network mounts ...")),
 				"showRFmod": (self.showRFSetup, _("Show RFmod setup...")),
+				"showHDMIRecord": (self.showHDMiRecordSetup, _("Show HDMIRecord setup...")),
 				"toggleAspectRatio": (self.toggleAspectRatio, _("Toggle aspect ratio...")),
 			})
 		self.session.infobar = None
@@ -1605,7 +1613,7 @@ class InfoBarMenu:
 		else:
 			config.av.aspect.value = "auto"
 		config.av.aspect.save()
-		self.session.open(MessageBox, _("AV aspect is %s." % ASPECT_MSG[config.av.aspect.value]), MessageBox.TYPE_INFO, timeout=5)
+		self.session.open(MessageBox, _("AV aspect is %s.") % ASPECT_MSG[config.av.aspect.value], MessageBox.TYPE_INFO, timeout=5)
 
 	def showSystemMenu(self):
 		menulist = mdom.getroot().findall('menu')
@@ -1636,13 +1644,17 @@ class InfoBarMenu:
 		if SystemInfo["RfModulator"]:
 			self.session.openWithCallback(self.mainMenuClosed, Setup, 'RFmod')
 
+	def showHDMiRecordSetup(self):
+		if SystemInfo["HDMIin"]:
+			self.session.openWithCallback(self.mainMenuClosed, Setup, 'HDMIRecord')
+
 	def mainMenuClosed(self, *val):
 		self.session.infobar = None
 
 class InfoBarSimpleEventView:
 	""" Opens the Eventview for now/next """
 	def __init__(self):
-		self["EPGActions"] = HelpableActionMap(self, "InfobarEPGActions",
+		self["EventViewActions"] = HelpableActionMap(self, "InfobarEPGActions",
 			{
 				"showEventInfo": (self.openEventView, _("show event details")),
 				"InfoPressed": (self.openEventView, _("show event details")),
@@ -1760,6 +1772,7 @@ class InfoBarEPG:
 		if pluginlist:
 			pluginlist.append((_("Event Info"), self.openEventView))
 			pluginlist.append((_("Graphical EPG"), self.openGraphEPG))
+			pluginlist.append((_("Vertical EPG"), self.openVerticalEPG))
 			pluginlist.append((_("Infobar EPG"), self.openInfoBarEPG))
 			pluginlist.append((_("Multi EPG"), self.openMultiServiceEPG))
 			pluginlist.append((_("Show EPG for current channel..."), self.openSingleServiceEPG))
@@ -1871,8 +1884,10 @@ class InfoBarEPG:
 				self.openMultiServiceEPG()
 			elif config.plisettings.PLIEPG_mode.value == "single":
 				self.openSingleServiceEPG()
-			elif config.plisettings.PLIEPG_mode.value == "merlinepgcenter":
-				self.openMerlinEPGCenter()	
+			elif config.plisettings.PLIEPG_mode.value == "vertical":
+				self.openVerticalEPG()
+			#elif config.plisettings.PLIEPG_mode.value == "merlinepgcenter":
+			#	self.openMerlinEPGCenter()	
 			elif config.plisettings.PLIEPG_mode.value == "cooltvguide" and COOLTVGUIDE:
 				if self.isInfo:
 					self.showCoolTVGuide()
@@ -1923,7 +1938,7 @@ class InfoBarEPG:
 	def openBouquetEPG(self, bouquet = None, bouquets = None):
 		if bouquet:
 			self.StartBouquet = bouquet
-		self.dlg_stack.append(self.session.openWithCallback(self.closed, EPGSelection, zapFunc=self.zapToService, EPGtype=self.EPGtype, StartBouquet=self.StartBouquet, StartRef=self.StartRef, bouquets = bouquets))
+		self.dlg_stack.append(self.session.openWithCallback(self.closed, EPGSelection, None, zapFunc=self.zapToService, EPGtype=self.EPGtype, StartBouquet=self.StartBouquet, StartRef=self.StartRef, bouquets = bouquets))
 
 	def closed(self, ret=False):
 		if not self.dlg_stack:
@@ -1980,6 +1995,21 @@ class InfoBarEPG:
 		self.EPGtype = "enhanced"
 		self.SingleServiceEPG()
 
+	def openVerticalEPG(self, reopen=False):
+		if self.servicelist is None:
+			return
+		if not reopen:
+			self.StartBouquet = self.servicelist.getRoot()
+			self.StartRef = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+		self.EPGtype = "vertical"
+		self.VerticalEPG()
+
+	def VerticalEPG(self):
+		#self.StartBouquet = self.servicelist.getRoot()
+		#self.StartRef = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+		bouquets = self.servicelist.getBouquetList()
+		self.dlg_stack.append(self.session.openWithCallback(self.closed, EPGSelection, self.servicelist, zapFunc=self.zapToService, EPGtype=self.EPGtype, StartBouquet=self.StartBouquet, StartRef=self.StartRef, bouquets = bouquets))
+
 	def openInfoBarEPG(self, reopen=False):
 		if self.servicelist is None:
 			return
@@ -2034,6 +2064,8 @@ class InfoBarEPG:
 	def reopen(self, answer):
 		if answer == 'reopengraph':
 			self.openGraphEPG(True)
+		elif answer == 'reopenvertical':
+			self.openVerticalEPG(True)
 		elif answer == 'reopeninfobargraph' or answer == 'reopeninfobar':
 			self.openInfoBarEPG(True)
 		elif answer == 'close' and isMoviePlayerInfoBar(self):
@@ -2554,9 +2586,9 @@ class InfoBarSeek:
 		self.setSeekState(self.SEEK_STATE_PAUSE)
 
 	def pauseServiceYellow(self):
-		if config.plugins.openpanel_yellowkey.list.value == '0':
+		if config.plugins.infopanel_yellowkey.list.value == '0':
 			self.audioSelection()
-		elif config.plugins.openpanel_yellowkey.list.value == '2':
+		elif config.plugins.infopanel_yellowkey.list.value == '2':
 			ToggleVideo()
 		else:
 			self.playpauseService()
@@ -3090,13 +3122,13 @@ class InfoBarExtensions:
 	def quickmenuStart(self):
 		try:
 			if not self.session.pipshown:
-				from Plugins.Extensions.Openpanel.QuickMenu import QuickMenu
+				from Plugins.Extensions.Infopanel.QuickMenu import QuickMenu
 				self.session.open(QuickMenu)
 			else:
 				self.showExtensionSelection()
 		except:
 			print "[INFOBARGENERICS] QuickMenu: error pipshow, starting Quick Menu"
-			from Plugins.Extensions.Openpanel.QuickMenu import QuickMenu
+			from Plugins.Extensions.Infopanel.QuickMenu import QuickMenu
 			self.session.open(QuickMenu)
 
 	def SelectopenEventView(self):
@@ -3118,7 +3150,7 @@ class InfoBarExtensions:
 		return _("Softcam-Panel")
 
 	def getSoftcamPanel(self):
-		if config.plugins.showopenpanelextensions.value:
+		if config.plugins.showinfopanelextensions.value:
 			return [((boundFunction(self.getSoftcamPanelname), boundFunction(self.openSoftcamPanel), lambda: True), None)]
 		else:
 			return []
@@ -3251,12 +3283,12 @@ class InfoBarExtensions:
 		self.session.open(OSD3DSetupScreen)
 
 	def openSoftcamPanel(self):
-		from Plugins.Extensions.Openpanel.SoftcamPanel import SoftcamPanel
+		from Plugins.Extensions.Infopanel.SoftcamPanel import SoftcamPanel
 		self.session.open(SoftcamPanel)
 
 	def openRestartNetwork(self):
 		try:
-			from Plugins.Extensions.Openpanel.RestartNetwork import RestartNetwork
+			from Plugins.Extensions.Infopanel.RestartNetwork import RestartNetwork
 			self.session.open(RestartNetwork)
 		except:
 			print'[INFOBARGENERICS] failed to restart network'
@@ -3633,6 +3665,8 @@ class InfoBarINFOpanel:
 			isHBBTV = True
 		if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/QtHbbtv/plugin.pyo"):
 			isHBBTV = True
+		if os.path.isfile("/usr/lib/enigma2/python/Plugins/Extensions/Hbbtv/plugin.pyo"):
+			isHBBTV = True
 
 		if isWEBBROWSER or isHBBTV:
 			service = self.session.nav.getCurrentService()
@@ -3641,57 +3675,57 @@ class InfoBarINFOpanel:
 				for x in self.onHBBTVActivation:
 					x()
 					
-			elif config.plugins.openpanel_redpanel.selection.value == '0':
+			elif config.plugins.infopanel_redpanel.selection.value == '0':
 				self.instantRecord()
 			else:
 				self.doRedKeyTask()
 		
-		elif config.plugins.openpanel_redpanel.selection.value == '0':
+		elif config.plugins.infopanel_redpanel.selection.value == '0':
 			self.instantRecord()
 		else:
 			self.doRedKeyTask()
 
 	def doRedKeyTask(self):
 		try:
-			if config.plugins.openpanel_redpanel.selection.value =='0':
+			if config.plugins.infopanel_redpanel.selection.value =='0':
 				self.instantRecord()
-			elif config.plugins.openpanel_redpanel.selection.value =='1':
-				from Plugins.Extensions.Openpanel.plugin import Openpanel
-				self.session.open(Openpanel, services = self.servicelist)
-			elif config.plugins.openpanel_redpanel.selection.value == '2':
+			elif config.plugins.infopanel_redpanel.selection.value =='1':
+				from Plugins.Extensions.Infopanel.plugin import Infopanel
+				self.session.open(Infopanel, services = self.servicelist)
+			elif config.plugins.infopanel_redpanel.selection.value == '2':
 				self.session.open(TimerEditList)
-			elif config.plugins.openpanel_redpanel.selection.value == '3':
+			elif config.plugins.infopanel_redpanel.selection.value == '3':
 				self.showMovies()
-			elif config.plugins.openpanel_redpanel.selection.value == '4':
+			elif config.plugins.infopanel_redpanel.selection.value == '4':
 				self.StartsoftcamPanel()
 			else:
-				self.StartPlugin(config.plugins.openpanel_redpanel.selection.value)
+				self.StartPlugin(config.plugins.infopanel_redpanel.selection.value)
 
 		except:
 			print "Error on RedKeyTask !!"
 		
 	def softcamPanel(self):
 		try:
-			if config.plugins.openpanel_redpanel.selectionLong.value =='0':
+			if config.plugins.infopanel_redpanel.selectionLong.value =='0':
 				self.instantRecord()
-			elif config.plugins.openpanel_redpanel.selectionLong.value =='1':
-				from Plugins.Extensions.Openpanel.plugin import Openpanel
-				self.session.open(Openpanel, services = self.servicelist)
-			elif config.plugins.openpanel_redpanel.selectionLong.value == '2':
+			elif config.plugins.infopanel_redpanel.selectionLong.value =='1':
+				from Plugins.Extensions.Infopanel.plugin import Infopanel
+				self.session.open(Infopanel, services = self.servicelist)
+			elif config.plugins.infopanel_redpanel.selectionLong.value == '2':
 				self.session.open(TimerEditList)
-			elif config.plugins.openpanel_redpanel.selectionLong.value == '3':
+			elif config.plugins.infopanel_redpanel.selectionLong.value == '3':
 				self.showMovies()
-			elif config.plugins.openpanel_redpanel.selectionLong.value == '4':
+			elif config.plugins.infopanel_redpanel.selectionLong.value == '4':
 				self.StartsoftcamPanel()
 			else:
-				self.StartPlugin(config.plugins.openpanel_redpanel.selectionLong.value)
+				self.StartPlugin(config.plugins.infopanel_redpanel.selectionLong.value)
 
 		except:
 			print "Error on RedKeyTask Long!!"
 			
 	def StartsoftcamPanel(self):
 		try:
-			from Plugins.Extensions.Openpanel.SoftcamPanel import SoftcamPanel
+			from Plugins.Extensions.Infopanel.SoftcamPanel import SoftcamPanel
 			self.session.open(SoftcamPanel)
 		except:
 			pass
@@ -3719,13 +3753,13 @@ class InfoBarQuickMenu:
 	def quickmenuStart(self):
 		try:
 			if not self.session.pipshown:
-				from Plugins.Extensions.Openpanel.QuickMenu import QuickMenu
+				from Plugins.Extensions.Infopanel.QuickMenu import QuickMenu
 				self.session.open(QuickMenu)
 			else:
 				self.showExtensionSelection()
 		except:
 			print "[INFOBARGENERICS] QuickMenu: error pipshow, starting Quick Menu"
-			from Plugins.Extensions.Openpanel.QuickMenu import QuickMenu
+			from Plugins.Extensions.Infopanel.QuickMenu import QuickMenu
 			self.session.open(QuickMenu)
 
 class InfoBarInstantRecord:
@@ -3929,6 +3963,9 @@ class InfoBarInstantRecord:
 #		print "stopping recording after", int(value), "minutes."
 		entry = self.recording[self.selectedEntry]
 		if value is not None:
+			value = value.replace(" ", "")
+			if value == "":
+				value = "0"
 			if int(value) != 0:
 				entry.autoincrease = False
 			entry.end = int(time()) + 60 * int(value)
@@ -4008,14 +4045,14 @@ class InfoBarAudioSelection:
 		if not hasattr(self, "LongButtonPressed"):
 			self.LongButtonPressed = False
 		if not self.LongButtonPressed:
-			if config.plugins.openpanel_yellowkey.list.value == '0':
+			if config.plugins.infopanel_yellowkey.list.value == '0':
 				from Screens.AudioSelection import AudioSelection
 				self.session.openWithCallback(self.audioSelected, AudioSelection, infobar=self)
-			elif config.plugins.openpanel_yellowkey.list.value == '2':
+			elif config.plugins.infopanel_yellowkey.list.value == '2':
 				global AUDIO
 				AUDIO = True
 				ToggleVideo()
-			elif config.plugins.openpanel_yellowkey.list.value == '3':
+			elif config.plugins.infopanel_yellowkey.list.value == '3':
 				self.startTeletext()
 			else:
 				try:
@@ -4023,14 +4060,14 @@ class InfoBarAudioSelection:
 				except:
 					pass
 		else:
-			if config.plugins.openpanel_yellowkey.listLong.value == '0':
+			if config.plugins.infopanel_yellowkey.listLong.value == '0':
 				from Screens.AudioSelection import AudioSelection
 				self.session.openWithCallback(self.audioSelected, AudioSelection, infobar=self)
-			elif config.plugins.openpanel_yellowkey.listLong.value == '2':
+			elif config.plugins.infopanel_yellowkey.listLong.value == '2':
 				global AUDIO
 				AUDIO = True
 				ToggleVideo()
-			elif config.plugins.openpanel_yellowkey.listLong.value == '3':
+			elif config.plugins.infopanel_yellowkey.listLong.value == '3':
 				self.startTeletext()
 			else:
 				try:
diff --git a/lib/python/Screens/InputDeviceSetup.py b/lib/python/Screens/InputDeviceSetup.py
index 30e933e..5ebf168 100644
--- a/lib/python/Screens/InputDeviceSetup.py
+++ b/lib/python/Screens/InputDeviceSetup.py
@@ -12,8 +12,6 @@ from Tools.LoadPixmap import LoadPixmap
 from Components.Pixmap import Pixmap
 from boxbranding import getBoxType, getMachineBrand, getMachineName, getBrandOEM
 
-boxtype = getBoxType()
-
 class InputDeviceSelection(Screen, HelpableScreen):
 	def __init__(self, session):
 		Screen.__init__(self, session)
@@ -259,7 +257,7 @@ class InputDeviceSetup(Screen, ConfigListScreen):
 
 
 class RemoteControlType(Screen, ConfigListScreen):
-	if getBrandOEM() in ('broadmedia','octagon','odin','protek','ultramini') or getBoxType() in ('et7x00','et8500','et1x000','et13000'):
+	if getBrandOEM() in ('broadmedia','octagon','odin','protek','ultramini') or getBoxType() in ('et7000','et7100','et7200','et7500','et7x00','et8500','et1x000','et13000'):
 		rcList = [
 				("0", _("Default")),
 				("3", _("MaraM9")),
@@ -279,18 +277,24 @@ class RemoteControlType(Screen, ConfigListScreen):
 				("20", _("Zgemma Star S/2S/H1/H2")),
 				("21", _("Zgemma H.S/H.2S/H.2H/H5/H7")),
 				("500", _("WWIO_BRE2ZE_TC")),
-				("501", _("OCTAGON_SFXXX8")),
+				("501", _("OCTAGON_SF4008")),
 				("502", _("GIGABLUE Black")),
 				("503", _("MIRACLEBOX_TWINPLUS")),
 				("504", _("E3HD/XPEEDLX/GI")),
-				("505", _("ODIN_M7"))
+				("505", _("ODIN_M7")),
+				("507", _("Beyonwiz U4")),
+				("511", _("OCTAGON SF5008"))
 				]
 		defaultRcList = [
+				("default", 0),
 				("et4000", 13),
 				("et5000", 7),
 				("et6000", 7),
 				("et6500", 11),
 				("et7x00",16),
+				("et7100",16),
+				("et7000",16),
+				("et7500",16),
 				("et7000mini",16),
 				("et8000", 9),
 				("et13000", 9),
@@ -325,14 +329,15 @@ class RemoteControlType(Screen, ConfigListScreen):
 				("sf4008", 501),
 				("g100", 501),
 				("sf4018", 501),
-				("sf5008", 9),
 				("gbquadplus", 502),
 				("g300", 503),
 				("e3hd", 504),
 				("et7000mini", 504),
 				("et1x000", 504),
 				("xpeedc.", 504),
-				("odinm7", 505)
+				("odinm7", 505),
+				("beyonwizu4", 507),
+				("sf5008", 511)
 				]
 	else:
 		rcList = [
@@ -343,7 +348,7 @@ class RemoteControlType(Screen, ConfigListScreen):
 				("6", _("DMM advanced")),
 				("7", _("et5000/6000")),
 				("8", _("VU+")),
-				("9", _("et8000/et10000/et13000/SF5008")),
+				("9", _("et8000/et10000/et13000")),
 				("11", _("et9200/9500/6500")),
 				("13", _("et4000")),
 				("14", _("XP1000")),
@@ -352,9 +357,16 @@ class RemoteControlType(Screen, ConfigListScreen):
 				("18", _("F1/F3/F4/F4-TURBO/TRIPLEX")),
 				("19", _("HD2400")),
 				("20", _("Zgemma Star S/2S/H1/H2")),
-				("21", _("Zgemma H.S/H.2S/H.2H/H5/H7"))
+				("21", _("Zgemma H.S/H.2S/H.2H/H5/H7")),
+				("22", _("Zgemma i55")),
+				("23", _("WWIO 4K")),
+				("24", _("Axas E4HD Ultra")),
+				("25", _("Zgemma H9/I55Plus")),
+				("26", _("Protek 4K UHD")),
+				("27", _("HD60"))
 				]
 		defaultRcList = [
+				("default", 0),
 				("et4000", 13),
 				("et5000", 7),
 				("et6000", 7),
@@ -384,10 +396,16 @@ class RemoteControlType(Screen, ConfigListScreen):
 				("xp1000", 14),
 				("xp3000", 17),
 				("sh1", 20),
-				("sf5008", 9),
 				("h3", 21),
 				("h5", 21),
-				("h7", 21)
+				("h7", 21),
+				("i55", 22),
+				("bre2ze4k", 23),
+				("e4hd", 24),
+				("h9", 25),
+				("i55plus", 25),
+				("protek4k", 26),
+				("hd60", 27)
 				]
 
 	def __init__(self, session):
@@ -416,15 +434,36 @@ class RemoteControlType(Screen, ConfigListScreen):
 		self.list.append(getConfigListEntry(_("Remote control type"), self.rctype))
 		self["config"].list = self.list
 
-		self.defaultRcType = None
+		self.defaultRcType = 0
 		self.getDefaultRcType()
 
+	def getBoxTypeCompatible(self):
+		try:
+			with open('/proc/stb/info/boxtype', 'r') as fd:
+				boxType = fd.read()
+				return boxType
+		except:
+			return "Default"
+		return "Default"
+
 	def getDefaultRcType(self):
-		data = iRcTypeControl.getBoxType()
+		boxtype = getBoxType()
+		boxtypecompat = self.getBoxTypeCompatible() 
+		self.defaultRcType = 0
+		#print "Boxtype is %s" % boxtype         
 		for x in self.defaultRcList:
-			if x[0] in data:
+			if x[0] in boxtype:
 				self.defaultRcType = x[1]
+				#print "Selecting %d as defaultRcType" % self.defaultRcType               
 				break
+		
+		# boxtypecompat should be removed in the future                
+		if (self.defaultRcType==0):    
+			for x in self.defaultRcList:
+				if x[0] in boxtypecompat:
+					self.defaultRcType = x[1]
+					#print "Selecting %d as defaultRcType" % self.defaultRcType               
+					break
 
 	def setDefaultRcType(self):
 		iRcTypeControl.writeRcType(self.defaultRcType)
diff --git a/lib/python/Screens/InstallWizard.py b/lib/python/Screens/InstallWizard.py
index bb6f299..70d5c0d 100644
--- a/lib/python/Screens/InstallWizard.py
+++ b/lib/python/Screens/InstallWizard.py
@@ -45,8 +45,8 @@ class InstallWizard(Screen, ConfigListScreen):
 				self.createMenu()
 		elif self.index == self.STATE_CHOISE_CHANNELLIST:
 			self.enabled = ConfigYesNo(default = True)
-			modes = {"astra": "Openplus default(Astra)", "hispasat": "Openplus Hispasat"}
-			self.channellist_type = ConfigSelection(choices = modes, default = "astra")
+			modes = {"ATV": "ATV default(13e-19e)", "19e": "Astra 1", "23e": "Astra 3", "19e-23e": "Astra 1 Astra 3", "19e-23e-28e": "Astra 1 Astra 2 Astra 3", "13e-19e-23e-28e": "Astra 1 Astra 2 Astra 3 Hotbird"}
+			self.channellist_type = ConfigSelection(choices = modes, default = "ATV")
 			self.createMenu()
 # 		elif self.index == self.STATE_CHOISE_SOFTCAM:
 # 			self.enabled = ConfigYesNo(default = True)
@@ -103,9 +103,8 @@ class InstallWizard(Screen, ConfigListScreen):
 		if self.index == self.STATE_UPDATE:
 			if config.misc.installwizard.hasnetwork.value:
 				self.session.open(InstallWizardIpkgUpdater, self.index, _('Please wait (updating packages)'), IpkgComponent.CMD_UPDATE)
-##				self.session.open(InstallWizardIpkgUpdater, self.index, _('Please wait (downloading channel list)'), IpkgComponent.CMD_REMOVE, {'package': 'enigma2-plugin-settings-openplus.settings.astra' })
 		elif self.index == self.STATE_CHOISE_CHANNELLIST and self.enabled.value and self.channellist_type.value != "ATV":
-			self.session.open(InstallWizardIpkgUpdater, self.index, _('Please wait (downloading channel list)'), IpkgComponent.CMD_REMOVE, {'package': 'enigma2-plugin-settings-openplus.settings.' + self.channellist_type.value})
+			self.session.open(InstallWizardIpkgUpdater, self.index, _('Please wait (downloading channel list)'), IpkgComponent.CMD_REMOVE, {'package': 'enigma2-plugin-settings-henksat-' + self.channellist_type.value})
 # 		elif self.index == self.STATE_CHOISE_SOFTCAM and self.enabled.value:
 # 			self.session.open(InstallWizardIpkgUpdater, self.index, _('Please wait (downloading softcam)'), IpkgComponent.CMD_INSTALL, {'package': 'enigma2-plugin-softcams-' + self.softcam_type.value})
 		return
@@ -143,4 +142,3 @@ class InstallWizardIpkgUpdater(Screen):
 					eDVBDB.getInstance().reloadBouquets()
 					eDVBDB.getInstance().reloadServicelist()
 			self.close()
-			
diff --git a/lib/python/Screens/LanguageSelection.py b/lib/python/Screens/LanguageSelection.py
index cccd669..31a8f11 100644
--- a/lib/python/Screens/LanguageSelection.py
+++ b/lib/python/Screens/LanguageSelection.py
@@ -1,5 +1,6 @@
 from Screens.Screen import Screen
 from Screens.MessageBox import MessageBox
+from Screens.Standby import TryQuitMainloop
 from Components.ActionMap import ActionMap
 from Components.Language import language
 from Components.config import config
@@ -91,14 +92,26 @@ class LanguageSelection(Screen):
 		global inWizzard
 		if inWizzard:
 			inWizzard = False
-			self.session.openWithCallback(self.deletelanguagesCB, MessageBox, _("Do you want to delete all other languages?"), default = False)
+			#self.session.openWithCallback(self.deletelanguagesCB, MessageBox, _("Do you want to delete all other languages?"), default = False)
+			if self.oldActiveLanguage != config.osd.language.value:
+				self.session.open(TryQuitMainloop, 3)
+			self.close()
 		else:
-			self.close(self.oldActiveLanguage != config.osd.language.value)
+			if self.oldActiveLanguage != config.osd.language.value:
+				self.session.openWithCallback(self.restartGUI, MessageBox,_("GUI needs a restart to apply a new language\nDo you want to restart the GUI now?"), MessageBox.TYPE_YESNO)
+			else:
+				self.close()
+
+	def restartGUI(self, answer=True):
+		if answer is True:
+			self.session.open(TryQuitMainloop, 3)
+		else:
+			self.close()
 
-	def deletelanguagesCB(self, anwser):
-		if anwser:
-			language.delLanguage()
-		self.close()
+	#def deletelanguagesCB(self, anwser):
+		#if anwser:
+			#language.delLanguage()
+		#self.close()
 
 	def cancel(self):
 		language.activateLanguage(self.oldActiveLanguage)
diff --git a/lib/python/Screens/LogManager.py b/lib/python/Screens/LogManager.py
index 59afbdb..5a43a6f 100644
--- a/lib/python/Screens/LogManager.py
+++ b/lib/python/Screens/LogManager.py
@@ -1,4 +1,4 @@
-from Screens.Screen import Screen
+from Screens.Screen import Screen
 from Components.GUIComponent import GUIComponent
 from Components.VariableText import VariableText
 from Components.ActionMap import ActionMap
@@ -11,7 +11,7 @@ from Components.config import config, configfile
 from Components.FileList import MultiFileSelectList
 from Screens.MessageBox import MessageBox
 from os import path, remove, walk, stat, rmdir
-from time import time
+from time import time, ctime
 from datetime import datetime
 from enigma import eTimer, eBackgroundFileEraser, eLabel, getDesktop, gFont, fontRenderClass
 from Tools.TextBoundary import getTextBoundarySize
@@ -149,12 +149,15 @@ class LogManagerPoller:
 						try:
 							fn = path.join(root, name)
 							st = stat(fn)
-							if st.st_ctime < ctimeLimit:
-								print "[LogManager] " + str(fn) + ": Too old:", name, st.st_ctime
+							#print "Logname: %s" % fn
+							#print "Last created: %s" % ctime(st.st_ctime)
+							#print "Last modified: %s" % ctime(st.st_mtime)
+							if st.st_mtime < ctimeLimit:
+								print "[LogManager] " + str(fn) + ": Too old:", ctime(st.st_mtime)
 								eBackgroundFileEraser.getInstance().erase(fn)
 								bytesToRemove -= st.st_size
 							else:
-								candidates.append((st.st_ctime, fn, st.st_size))
+								candidates.append((st.st_mtime, fn, st.st_size))
 								size += st.st_size
 						except Exception, e:
 							print "[LogManager] Failed to stat %s:"% name, e
diff --git a/lib/python/Screens/MessageBox.py b/lib/python/Screens/MessageBox.py
index 5d73499..108974d 100644
--- a/lib/python/Screens/MessageBox.py
+++ b/lib/python/Screens/MessageBox.py
@@ -61,8 +61,6 @@ class MessageBox(Screen):
 		self["QuestionPixmap"].hide()
 		self["InfoPixmap"] = Pixmap()
 		self["InfoPixmap"].hide()
-                self["WarningPixmap"] = Pixmap()
-                self["WarningPixmap"].hide()
 
 		self.timerRunning = False
 		self.initTimeout(timeout)
@@ -73,10 +71,8 @@ class MessageBox(Screen):
 				self["ErrorPixmap"].show()
 			elif picon == self.TYPE_YESNO:
 				self["QuestionPixmap"].show()
-			elif picon == self.TYPE_INFO:
+			elif picon == self.TYPE_INFO or picon == self.TYPE_WARNING:
 				self["InfoPixmap"].show()
-                        elif picon == self.TYPE_WARNING:
-                                self["WarningPixmap"].show()
 
 		self.messtype = type
 		if type == self.TYPE_YESNO:
@@ -119,7 +115,7 @@ class MessageBox(Screen):
 		if not self["text"].text:
 			textsize = (520, 0)
 			listsize = (520, 25*count)
-			if self["ErrorPixmap"].visible or self["QuestionPixmap"].visible or self["InfoPixmap"].visible or self["WarningPixmap"].visible:
+			if self["ErrorPixmap"].visible or self["QuestionPixmap"].visible or self["InfoPixmap"].visible:
 				self["list"].instance.move(enigma.ePoint(65, 0))
 			else:
 				self["list"].instance.move(enigma.ePoint(0, 0))
@@ -136,12 +132,12 @@ class MessageBox(Screen):
 			listsize = (textsize[0], 25*count)
 
 			self["text"].instance.resize(enigma.eSize(*textsize))
-			if self["ErrorPixmap"].visible or self["QuestionPixmap"].visible or self["InfoPixmap"].visible or self["WarningPixmap"].visible:
+			if self["ErrorPixmap"].visible or self["QuestionPixmap"].visible or self["InfoPixmap"].visible:
 				self["text"].instance.move(enigma.ePoint(65, 0))
 			else:
 				self["text"].instance.move(enigma.ePoint(10, 10))
 
-			if self["ErrorPixmap"].visible or self["QuestionPixmap"].visible or self["InfoPixmap"].visible or self["WarningPixmap"].visible:
+			if self["ErrorPixmap"].visible or self["QuestionPixmap"].visible or self["InfoPixmap"].visible:
 				self["list"].instance.move(enigma.ePoint(65, textsize[1]))
 				wsizex = textsize[0]+65
 			else:
diff --git a/lib/python/Screens/MinuteInput.py b/lib/python/Screens/MinuteInput.py
index e89f14c..4691046 100644
--- a/lib/python/Screens/MinuteInput.py
+++ b/lib/python/Screens/MinuteInput.py
@@ -8,6 +8,7 @@ class MinuteInput(Screen):
 		Screen.__init__(self, session)
 
 		self["minutes"] = Input(str(basemins), type=Input.NUMBER)
+		self.MaxMinutes = 9999
 
 		self["actions"] = NumberActionMap([ "InputActions" , "MinuteInputActions", "TextEntryActions", "KeyboardInputActions" ],
 		{
@@ -33,6 +34,11 @@ class MinuteInput(Screen):
 			"cancel": self.cancel
 		})
 
+	def checkFieldIsEmpty(self):
+		if self["minutes"].getText() == "":
+			self["minutes"].setText("0")
+			self["minutes"].markAll()
+
 	def keyNumberGlobal(self, number):
 		self["minutes"].number(number)
 		pass
@@ -51,9 +57,11 @@ class MinuteInput(Screen):
 
 	def deleteForward(self):
 		self["minutes"].delete()
+		self.checkFieldIsEmpty()
 
 	def deleteBackward(self):
 		self["minutes"].deleteBackward()
+		self.checkFieldIsEmpty()
 
 	def up(self):
 		self["minutes"].up()
@@ -62,11 +70,12 @@ class MinuteInput(Screen):
 		self["minutes"].down()
 
 	def ok(self):
-		try:
-			self.close(int(self["minutes"].getText()))
-		except:
-			self.session.open(MessageBox, _("Incorrect format for skip value: '%s'\nSkip cancelled.") % self["minutes"].getText(), MessageBox.TYPE_WARNING, timeout=5)
+		IntMinutes = int(self["minutes"].getText())
+		if  IntMinutes > self.MaxMinutes:
+			self.session.open(MessageBox, _("Maximum minutes to jump %d !") %self.MaxMinutes, MessageBox.TYPE_WARNING, timeout=5)
 			self.cancel()
+		else:
+			self.close(IntMinutes)
 
 	def cancel(self):
 		self.close(0)
diff --git a/lib/python/Screens/MovieSelection.py b/lib/python/Screens/MovieSelection.py
index 705158a..d6df4b2 100644
--- a/lib/python/Screens/MovieSelection.py
+++ b/lib/python/Screens/MovieSelection.py
@@ -2029,7 +2029,7 @@ class MovieSelection(Screen, HelpableScreen, SelectionEventInfo, InfoBarBase, Pr
 		self.session.open(NetworkSetup.NetworkMountsMenu)
 
 	def showDeviceMounts(self):
-		from Plugins.Extensions.Openpanel.MountManager import HddMount
+		from Plugins.Extensions.Infopanel.MountManager import HddMount
 		self.session.open(HddMount)
 
 	def showActionFeedback(self, text):
diff --git a/lib/python/Screens/NetworkSetup.py b/lib/python/Screens/NetworkSetup.py
index ea664e9..752dce5 100644
--- a/lib/python/Screens/NetworkSetup.py
+++ b/lib/python/Screens/NetworkSetup.py
@@ -17,6 +17,8 @@ from Components.Sources.Boolean import Boolean
 from Components.Sources.List import List
 from Components.SystemInfo import SystemInfo
 from Components.Label import Label, MultiColorLabel
+from Components.Input import Input
+from Screens.InputBox import InputBox
 from Components.ScrollLabel import ScrollLabel
 from Components.Pixmap import Pixmap, MultiPixmap
 from Components.MenuList import MenuList
@@ -25,15 +27,18 @@ from Components.ConfigList import ConfigListScreen
 from Components.PluginComponent import plugins
 from Components.FileList import MultiFileSelectList
 from Components.ActionMap import ActionMap, NumberActionMap, HelpableActionMap
-from datetime import datetime
 from Tools.Directories import fileExists, resolveFilename, SCOPE_PLUGINS, SCOPE_ACTIVE_SKIN
 from Tools.LoadPixmap import LoadPixmap
 from Plugins.Plugin import PluginDescriptor
 from subprocess import call
 import commands
-import os.path
+import os
+import glob
 
-basegroup = "packagegroup-base"
+if float(getVersionString()) >= 4.0:
+	basegroup = "packagegroup-base"
+else:
+	basegroup = "task-base"
 
 class NetworkAdapterSelection(Screen,HelpableScreen):
 	def __init__(self, session):
@@ -2024,21 +2029,23 @@ class NetworkFtp(Screen):
 
 	def activateFtp(self):
 		commands = []
-		if fileExists('/etc/rc2.d/S20vsftpd'):
+		if len(glob.glob('/etc/rc2.d/S*0vsftpd')):
+		#if fileExists('/etc/rc2.d/S20vsftpd'):
 			commands.append('update-rc.d -f vsftpd remove')
 		else:
 			commands.append('update-rc.d -f vsftpd defaults')
 		self.Console.eBatch(commands, self.StartStopCallback, debug=True)
 
 	def updateService(self):
-		import process		
-		p = process.ProcessList()		
+		import process
+		p = process.ProcessList()
 		ftp_process = str(p.named('vsftpd')).strip('[]')
 		self['labrun'].hide()
 		self['labstop'].hide()
 		self['labactive'].setText(_("Disabled"))
 		self.my_ftp_active = False
-		if fileExists('/etc/rc2.d/S20vsftpd'):
+		if len(glob.glob('/etc/rc2.d/S*0vsftpd')):
+		#if fileExists('/etc/rc2.d/S20vsftpd'):
 			self['labactive'].setText(_("Enabled"))
 			self['labactive'].show()
 			self.my_ftp_active = True
@@ -2199,151 +2206,7 @@ class NetworkNfs(Screen):
 
 		for cb in self.onChangedEntry:
 			cb(title, status_summary, autostartstatus_summary)
-#######################################################Remote tuner server ##################################################################################################
-
-
-class RemoteTunerServer(Screen):
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Remote Tuner Server"))
-		self.skinName = "NetworkNfs"
-		self.onChangedEntry = [ ]
-		self['lab1'] = Label(_("Autostart:"))
-		self['labactive'] = Label(_(_("Disabled")))
-		self['lab2'] = Label(_("Current Status:"))
-		self['labstop'] = Label(_("Stopped"))
-		self['labrun'] = Label(_("Running"))
-		self['key_green'] = Label(_("Start"))
-		self['key_red'] = Label(_("Remove Service"))
-		self['key_yellow'] = Label(_("Autostart"))
-		self['key_blue'] = Label()
-		self.Console = Console()
-		self.my_rts_active = False
-		self.my_rts_run = False
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions'], {'ok': self.close, 'back': self.close, 'red': self.UninstallCheck, 'green': self.RemoteTunerServerStartStop, 'yellow': self.RemoteTunerServerSet})
-		self.service_name = 'enigma2-plugin-extensions-optunerserver'
-		self.onLayoutFinish.append(self.InstallCheck)
-
-	def InstallCheck(self):
-		print"INSTALL"
-		print '/usr/bin/opkg list_installed ' + self.service_name
-		self.Console.ePopen('/usr/bin/opkg list_installed ' + self.service_name, self.checkNetworkState)
-
-	def checkNetworkState(self, str, retval, extra_args):
-		print "checkNetworkState ", str
-		if 'Collected errors' in str:
-			self.session.openWithCallback(self.close, MessageBox, _("A background update check is in progress, please wait a few minutes and try again."), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		elif not str:
-			self.feedscheck = self.session.open(MessageBox,_('Please wait whilst feeds state is checked.'), MessageBox.TYPE_INFO, enable_input = False)
-			self.feedscheck.setTitle(_('Checking Feeds'))
-			cmd1 = "opkg update"
-			self.CheckConsole = Console()
-			self.CheckConsole.ePopen(cmd1, self.checkNetworkStateFinished)
-		else:
-			self.updateService()
-
-	def checkNetworkStateFinished(self, result, retval,extra_args=None):
-		print "checkNetworkStateFinished ", result
-		if 'bad address' in result:
-			self.session.openWithCallback(self.InstallPackageFailed, MessageBox, _("Your %s %s is not connected to the internet, please check your network settings and try again.") % (getMachineBrand(), getMachineName()), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		elif ('wget returned 1' or 'wget returned 255' or '404 Not Found') in result:
-			self.session.openWithCallback(self.InstallPackageFailed, MessageBox, _("Sorry feeds are down for maintenance, please try again later."), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		else:
-			self.session.openWithCallback(self.InstallPackage,MessageBox,_('Your %s %s will be restarted after the installation of service\nReady to install %s ?')  % (getMachineBrand(), getMachineName(), self.service_name), MessageBox.TYPE_YESNO)
-
-	def InstallPackage(self, val):
-		print "InstallPackage ", val
-		if val:
-			self.doInstall(self.installComplete, self.service_name)
-		else:
-			self.feedscheck.close()
-			self.close()
-
-	def InstallPackageFailed(self, val):
-		print "InstallPackageFailed"
-		self.feedscheck.close()
-		self.close()
-
-	def doInstall(self, callback, pkgname):
-		print "doInstall " ,callback, pkgname
-		self.message = self.session.open(MessageBox,_("please wait..."), MessageBox.TYPE_INFO, enable_input = False)
-		self.message.setTitle(_('Installing Service'))
-		self.Console.ePopen('/usr/bin/opkg install enigma2-plugin-extensions-optunerserver', callback)
-
-	def installComplete(self,result = None, retval = None, extra_args = None):
-		self.session.open(TryQuitMainloop, 2)
-
-	def UninstallCheck(self):
-		self.Console.ePopen('/usr/bin/opkg list_installed ' + self.service_name, self.RemovedataAvail)
-
-	def RemovedataAvail(self, str, retval, extra_args):
-		if str:
-			restartbox = self.session.openWithCallback(self.RemovePackage,MessageBox,_('Your %s %s will be restarted after the removal of service\nDo you want to remove now ?') % (getMachineBrand(), getMachineName()), MessageBox.TYPE_YESNO)
-			restartbox.setTitle(_('Ready to remove %s ?') % self.service_name)
-		else:
-			self.updateService()
-
-	def RemovePackage(self, val):
-		if val:
-			self.doRemove(self.removeComplete, self.service_name)
-
-	def doRemove(self, callback, pkgname):
-		self.message = self.session.open(MessageBox,_("please wait..."), MessageBox.TYPE_INFO, enable_input = False)
-		self.message.setTitle(_('Removing Service'))
-		self.Console.ePopen('/usr/bin/opkg remove ' + pkgname + ' --force-remove --autoremove --force-depends', callback)
-
-	def removeComplete(self,result = None, retval = None, extra_args = None):
-		self.session.open(TryQuitMainloop, 2)
-
-	def createSummary(self):
-		return NetworkServicesSummary
-
-	def RemoteTunerServerStartStop(self):
-		if not self.my_rts_run:
-			self.Console.ePopen('/etc/init.d/xupnpd start', self.StartStopCallback)
-		elif self.my_rts_run:
-			self.Console.ePopen('/etc/init.d/xupnpd stop', self.StartStopCallback)
-
-	def StartStopCallback(self, result = None, retval = None, extra_args = None):
-		time.sleep(3)
-		self.updateService()
-
-	def RemoteTunerServerSet(self):
-		if fileExists('/etc/rc2.d/S11xupnpd'):
-			self.Console.ePopen('update-rc.d -f xupnpd remove', self.StartStopCallback)
-		else:
-			self.Console.ePopen('update-rc.d -f xupnpd defaults 11', self.StartStopCallback)
-
-	def updateService(self):
-		import process
-		p = process.ProcessList()
-		rts_process = str(p.named('xupnpd')).strip('[]')
-		self['labrun'].hide()
-		self['labstop'].hide()
-		self['labactive'].setText(_("Disabled"))
-		self.my_rts_active = False
-		self.my_rts_run = False
-		if fileExists('/etc/rc2.d/S11xupnpd'):
-			self['labactive'].setText(_("Enabled"))
-			self['labactive'].show()
-			self.my_rts_active = True
-		if rts_process:
-			self.my_rts_run = True
-		if self.my_rts_run:
-			self['labstop'].hide()
-			self['labrun'].show()
-			self['key_green'].setText(_("Stop"))
-			status_summary= self['lab2'].text + ' ' + self['labrun'].text
-		else:
-			self['labstop'].show()
-			self['labrun'].hide()
-			self['key_green'].setText(_("Start"))
-			status_summary= self['lab2'].text + ' ' + self['labstop'].text
-		title = _("Remote Tuner Server Setup")
-		autostartstatus_summary = self['lab1'].text + ' ' + self['labactive'].text
 
-		for cb in self.onChangedEntry:
-			cb(title, status_summary, autostartstatus_summary)
 class NetworkOpenvpn(Screen):
 	def __init__(self, session):
 		Screen.__init__(self, session)
@@ -2355,15 +2218,17 @@ class NetworkOpenvpn(Screen):
 		self['lab2'] = Label(_("Current Status:"))
 		self['labstop'] = Label(_("Stopped"))
 		self['labrun'] = Label(_("Running"))
+		self['labconfig'] = Label(_("Config file name (ok to change):"))
+		self['labconfigfilename']=Label(_("default"))
+		self.config_file=""
 		self['key_green'] = Label(_("Start"))
 		self['key_red'] = Label(_("Remove Service"))
 		self['key_yellow'] = Label(_("Autostart"))
-		self['key_blue'] = Label(_("Simple Config"))
-                self['key_info'] = Label(_("Show Log"))
+		self['key_blue'] = Label(_("Show Log"))
 		self.Console = Console()
 		self.my_vpn_active = False
 		self.my_vpn_run = False
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions'], {'ok': self.close, 'back': self.close, 'red': self.UninstallCheck, 'green': self.VpnStartStop, 'yellow': self.activateVpn, 'blue': self.Vpnsimpleconf, 'info': self.Vpnshowlog})
+		self['actions'] = ActionMap(['WizardActions', 'ColorActions'], {'ok': self.inputconfig, 'back': self.close, 'red': self.UninstallCheck, 'green': self.VpnStartStop, 'yellow': self.activateVpn, 'blue': self.Vpnshowlog})
 		self.service_name = 'openvpn'
 		self.onLayoutFinish.append(self.InstallCheck)
 
@@ -2405,9 +2270,6 @@ class NetworkOpenvpn(Screen):
 		self.message = self.session.open(MessageBox,_("please wait..."), MessageBox.TYPE_INFO, enable_input = False)
 		self.message.setTitle(_('Installing Service'))
 		self.Console.ePopen('/usr/bin/opkg install ' + pkgname, callback)
-                import os
-                os.system("mkdir /etc/openvpn")
-
 
 	def installComplete(self,result = None, retval = None, extra_args = None):
 		self.message.close()
@@ -2426,9 +2288,7 @@ class NetworkOpenvpn(Screen):
 	def RemovePackage(self, val):
 		if val:
 			self.doRemove(self.removeComplete, self.service_name)
-                        import os
-                        os.system("rm -r /etc/openvpn")
-                        
+
 	def doRemove(self, callback, pkgname):
 		self.message = self.session.open(MessageBox,_("please wait..."), MessageBox.TYPE_INFO, enable_input = False)
 		self.message.setTitle(_('Removing Service'))
@@ -2444,12 +2304,9 @@ class NetworkOpenvpn(Screen):
 	def Vpnshowlog(self):
 		self.session.open(NetworkVpnLog)
 
-        def Vpnsimpleconf(self):
-		self.session.open(Networksimpleconf)
-
 	def VpnStartStop(self):
 		if not self.my_vpn_run:
-			self.Console.ePopen('/etc/init.d/openvpn start', self.StartStopCallback)
+			self.Console.ePopen('/etc/init.d/openvpn start ' + self.config_file, self.StartStopCallback)
 		elif self.my_vpn_run:
 			self.Console.ePopen('/etc/init.d/openvpn stop', self.StartStopCallback)
 
@@ -2491,9 +2348,22 @@ class NetworkOpenvpn(Screen):
 		title = _("OpenVpn Setup")
 		autostartstatus_summary = self['lab1'].text + ' ' + self['labactive'].text
 
+		self['labconfig'].show()
+
 		for cb in self.onChangedEntry:
 			cb(title, status_summary, autostartstatus_summary)
 
+	def inputconfig(self):
+		self.session.openWithCallback(self.askForWord, InputBox, title=_("Input config file name:"), text=" " * 20, maxSize=20, type=Input.TEXT)
+
+	def askForWord(self, word):
+		if word is None:
+			pass
+		else:
+			self.config_file=_(word)
+			self['labconfigfilename'].setText(self.config_file)
+
+			
 class NetworkVpnLog(Screen):
 	def __init__(self, session):
 		Screen.__init__(self, session)
@@ -2513,46 +2383,6 @@ class NetworkVpnLog(Screen):
 			remove('/etc/openvpn/tmp.log')
 		self['infotext'].setText(strview)
 
-class Networksimpleconf(Screen):
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("OpenVPN Simple Config"))
-		self.skinName = "NetworkOpenvpnSetup"
-                self['data'] = Label(_('To create config for OpenVPN press green button and please wait...'))
-                self["key_red"] = Label(_("Exit"))
-                self["key_green"] = Label(_("Create"))
-                self['actions'] = ActionMap(['OkCancelActions','ColorActions'],{'cancel': self.exit, 'red': self.exit, 'green': self.check,})
-                
-        def check(self):
-                if (os.path.exists('/etc/openvpn/client1-android/client.ovpn')):
-                        self.session.openWithCallback(self.checkf,MessageBox,_('The configuration has already been created, do you want to overwrite?'), MessageBox.TYPE_YESNO)                         
-                else:
-                        self.create()
-                             
-        def checkf(self, val):
-		if val:
-			self.create()
-		else:
-			self.close() 
-                        
-        def create(self, value=1):
-                try:
-                         if value:
-			 	cod = datetime.now().strftime('%Y%m%d%H%M%S%f')
-                         	file = open('/var/volatile/tmp/systemop'+str(cod),'w+')
-                         	file.write ( "run /usr/bin/setup_openvpn.sh ")
-                         	file.close()
-                except IOError:
-                         self.session.open(MessageBox, _("Error: File Not created."), MessageBox.TYPE_INFO, timeout = 10)
-                         print "Error: File Not created."
-                         return 0    
-                resultext = 'Building server and clients in the background... \nOnce finished, you will see a message on the screen, and the configurations will already be created. \n\nYou can transfer the settings from: \netc/openvpn/client1-android \netc/openvpn/client2-ipad \netc/openvpn/client3-pc_lin \n\nYou should now configure your IP range in the server.conf eg: push route 192.168.1.0 255.255.255.0 in /etc/openvpn. Then on each generated client.ovpn remember to put the public ip or Dyndns where the server is hosted and the port if you want to change it, (remember to open it on the router for the IP of the server) eg: remote my.dyndns.org 1194. \n\nNote: Be sure to restart the OpenVPN Server after you make the changes. And to automatically start OpenVPN, choose the option in the OpenPlus graphical user interface!'
-                self.session.open(MessageBox, _("Building server and clients..."), MessageBox.TYPE_INFO, timeout = 10)
-                self['data'].setText(_(resultext)) 
-                   
-        def exit(self):
-                self.close()
-
 class NetworkSamba(Screen):
 	def __init__(self, session):
 		Screen.__init__(self, session)
@@ -2708,6 +2538,7 @@ class NetworkSamba(Screen):
 		for cb in self.onChangedEntry:
 			cb(title, status_summary, autostartstatus_summary)
 
+			
 class NetworkSambaLog(Screen):
 	def __init__(self, session):
 		Screen.__init__(self, session)
@@ -4125,355 +3956,4 @@ class NetworkServicesSummary(Screen):
 		self["title"].text = title
 		self["status_summary"].text = status_summary
 		self["autostartstatus_summary"].text = autostartstatus_summary
-
-######################################################################################################################		
-from Components.config import config, getConfigListEntry, ConfigText, ConfigSelection, ConfigSubsection, configfile, NoSave
-config.networkiptv = ConfigSubsection()
-config.networkiptv.udpxyport = ConfigNumber(default = "8088")
-config.networkiptv.udpxyipserver = ConfigIP(default = [127,0,0,1])
-config.networkiptv.udpxyipclient = ConfigIP(default = [192,168,0,1])
-config.networkiptv.udpxyloginclient = ConfigText(default = "root",fixed_size = False, visible_width=30)
-config.networkiptv.udpxypassclient = ConfigText(default = "",fixed_size = False, visible_width=30)
-
-class udpxySendConfig(ConfigListScreen, Screen):
-        skin = """ 
-		<screen name="iptvconfsend" position="center,238" size="580,308" title="Movistar+ Iptv Config Sharing" backgroundColor="white">        
-		 <widget name="config" position="9,19" size="400,218" font="Regular;20" valign="center" transparent="0" backgroundColor="white" foregroundColor="black" />
-		 <widget name="key_green" position="0,254" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="green" transparent="0" />
-		 <widget name="key_blue" position="140,254" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="blue" transparent="0" />
-		 <widget name="key_yellow" position="280,254" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="yellow" transparent="0" />
-		 <widget name="key_red" position="420,254" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="red" transparent="0" />
-		</screen>
-        """	
-        def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Movistar+ Iptv Config Sharing"))
-		self.skinName = "iptvconfsend"
-		self['key_green'] = Label(_("Send Cfg"))
-		self['key_red'] = Label(_("Cancel"))
-		self['key_yellow'] = Label("")
-		self['key_blue'] = Label("")
-		self['key_yellow'].hide()
-		self['key_blue'].hide()
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions'], {'ok': self.sendCfg, 'back': self.close, 'red': self.close, 'green': self.sendCfg })
-		self.list = []
-                self.list.append(getConfigListEntry(_("Client IP"), config.networkiptv.udpxyipclient))
-		self.list.append(getConfigListEntry(_("Client User"), config.networkiptv.udpxyloginclient))
-		self.list.append(getConfigListEntry(_("Client Password"), config.networkiptv.udpxypassclient))
-        	ConfigListScreen.__init__(self, self.list)
-
-	def sendCfg(self):
-		print "Sending config"
-		self.message = self.session.open(MessageBox, _("Sharing config..."), MessageBox.TYPE_INFO, timeout=4)
-		self.message.setTitle(_("Update config by ftp"))
-		config.networkiptv.udpxyipclient.save()
-		config.networkiptv.udpxyloginclient.save()
-		config.networkiptv.udpxypassclient.save()
-		configfile.save()
-		try:
-			import ftplib
-			_ip = config.networkiptv.udpxyipclient.getText() 
-			ftp = ftplib.FTP(_ip)
-			ftp.login(config.networkiptv.udpxyloginclient.value, config.networkiptv.udpxypassclient.value)
-			ftp.cwd("/etc/enigma2")
-			myfile = open("/tmp/bouquets.tv", 'wb')
-			ftp.retrbinary('RETR bouquets.tv', myfile.write)
-			myfile.close()
-			myfile = open("/tmp/bouquets.tv",'r')
-			find="0"
-			for line in myfile:
-				if line.find('userbouquetsmp.iptv.tv') >= 0:
-					find=line
-				
-			myfile.close()
-			if (find != "0"):
-				self.strReplace("/tmp/bouquets.tv", find, "#SERVICE: 1:7:1:0:0:0:0:0:0:0:userbouquetsmp.iptv.tv")
-			else:
-				myfile = open ("/tmp/bouquets.tv", "a")
-				myfile.write("#SERVICE: 1:7:1:0:0:0:0:0:0:0:userbouquetsmp.iptv.tv\n")
-				myfile.close()
-			ftp.cwd("/etc/enigma2")
-			myfile = open("/tmp/bouquets.tv", 'r')
-			ftp.storlines('STOR ' + "bouquets.tv", myfile)
-			myfile.close()
-			ftp.cwd("/etc/enigma2")
-			myfile = open("/etc/enigma2/userbouquetsmp.iptv.tv", 'r')
-			ftp.storlines('STOR ' + "userbouquetsmp.iptv.tv", myfile)
-			myfile.close()
-			
-			self.session.open(MessageBox, _("Transfer was successfully finished"), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		except ftplib.all_errors, e:
-		  	errorcode = str(e).split(None, 1)
-		  	self.session.open(MessageBox, _("Transfer was finished with errors: %s") % errorcode, type=MessageBox.TYPE_ERROR, timeout=10, close_on_any_key=True)
-		  	         
-		self.message.close()
-		
-	def strReplace(self, file, search, replace):
-		with open(file,'r') as f:
-			newlines = []
-			for line in f.readlines():
-				newlines.append(line.replace(search, replace))
-		with open(file, 'w') as f:
-			for line in newlines:
-				f.write(line)
-						
-class udpxyConfig(ConfigListScreen, Screen):
-        skin = """ 
-		<screen name="iptvconf" position="center,238" size="580,308" title="Movistar+ Iptv Server Config" backgroundColor="white">        
-		 <widget name="config" position="9,19" size="400,218" font="Regular;20" valign="center" transparent="0" backgroundColor="white" foregroundColor="black" />
-		 <widget name="key_green" position="0,254" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="green" transparent="0" />
-		 <widget name="key_blue" position="140,254" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="blue" transparent="0" />
-		 <widget name="key_yellow" position="280,254" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="yellow" transparent="0" />
-		 <widget name="key_red" position="420,254" zPosition="1" size="140,40" font="Regular;20" halign="center" valign="center" backgroundColor="red" transparent="0" />
-		</screen>
-        """
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Movistar+ Iptv Server Config"))
-		self.skinName = "iptvconf"
-		self['key_green'] = Label(_("Save"))
-		self['key_red'] = Label(_("Cancel"))
-		self['key_blue'] = Label(_("Down m3u"))
-                self['key_yellow'] = Label(_("Send Conf"))
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions'], {'ok': self.saveIp, 'back': self.close, 'red': self.close, 'green': self.saveIp, 'yellow': self.sendConfig, 'blue': self.InstallM3u })
-		self.list = []
-                self.list.append(getConfigListEntry(_("Udpxy Server IP"), config.networkiptv.udpxyipserver))
-		self.list.append(getConfigListEntry(_("Udpxy Server port"), config.networkiptv.udpxyport))
-        	ConfigListScreen.__init__(self, self.list)
-        	self["config"].list = self.list
-        	self.Console = Console()       
-		self.lastport=config.networkiptv.udpxyport.value
-		self.lastip=config.networkiptv.udpxyipserver.getText()
-		print "Config"
-		
-	def InstallM3u(self):
-		self.pkt_name = 'enigma2-plugin-settings-openplus.movistar.iptv.vlc'
-		self.Console.ePopen('/usr/bin/opkg list_installed ' + self.pkt_name, self.checkNetworkState)
-
-	def checkNetworkState(self, str, retval, extra_args):
-		print "checkNetworkState ", str
-		if 'Collected errors' in str:
-			self.session.openWithCallback(self.close, MessageBox, _("A background update check is in progress, please wait a few minutes and try again."), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		elif not str:
-			self.feedscheck = self.session.open(MessageBox,_('Please wait whilst feeds state is checked.'), MessageBox.TYPE_INFO, enable_input = False)
-			self.feedscheck.setTitle(_('Checking Feeds'))
-			cmd1 = "opkg update"
-			self.CheckConsole = Console()
-			self.CheckConsole.ePopen(cmd1, self.checkNetworkStateFinished)
-		else:
-			self.session.open(MessageBox, _("The package %s is already installed") % self.pkt_name, type=MessageBox.TYPE_ERROR, timeout=10, close_on_any_key=True)
-	
-
-	def checkNetworkStateFinished(self, result, retval,extra_args=None):
-		print "checkNetworkStateFinished ", result
-		if 'bad address' in result:
-			self.session.openWithCallback(self.InstallPackageFailed, MessageBox, _("Your %s %s is not connected to the internet, please check your network settings and try again.") % (getMachineBrand(), getMachineName()), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		elif ('wget returned 1' or 'wget returned 255' or '404 Not Found') in result:
-			self.session.openWithCallback(self.InstallPackageFailed, MessageBox, _("Sorry feeds are down for maintenance, please try again later."), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		else:
-			self.session.openWithCallback(self.InstallPackage,MessageBox,_('The package will be  installed in your %s %s\nReady to install %s ?')  % (getMachineBrand(), getMachineName(), self.pkt_name), MessageBox.TYPE_YESNO)
-
-	def InstallPackage(self, val):
-		if val:
-			self.doInstall(self.installComplete, self.pkt_name)
-		else:
-			self.feedscheck.close()
-			self.close()
-
-	def InstallPackageFailed(self, val):
-		print "Install Package Failed"
-		self.feedscheck.close()
-		self.close()
-
-	def doInstall(self, callback, pkgname):
-		print "doInstall " ,callback, self.pkt_name
-		self.message = self.session.open(MessageBox,_("please wait..."), MessageBox.TYPE_INFO, enable_input = False)
-		self.message.setTitle(_('Installing Package'))
-		self.Console.ePopen('/usr/bin/opkg install %s' % self.pkt_name, callback)
-
-	def installComplete(self,result = None, retval = None, extra_args = None):
-		print "Instalation finished"
-		self.feedscheck.close()
-		self.message.close()
-		self.close()
-		
-	def sendConfig(self):
-		self.session.open(udpxySendConfig)
-
-	def saveIp(self):
-		config.networkiptv.udpxyport.save()
-		config.networkiptv.udpxyipserver.save()
-		configfile.save()
-		self.strReplace("/etc/enigma2/userbouquetsmp.iptv.tv", str(self.lastport), str(config.networkiptv.udpxyport.value))
-		self.strReplace("/etc/init.d/udpxy", str(self.lastport), str(config.networkiptv.udpxyport.value))
-		self.strReplace("/etc/enigma2/userbouquetsmp.iptv.tv", self.lastip, config.networkiptv.udpxyipserver.getText())
-		self.lastport=config.networkiptv.udpxyport.value
-		self.lastip=config.networkiptv.udpxyipserver.getText()
-		self.Console.ePopen('killall -9 udpxy; /etc/init.d/udpxy start')
-		# Reload settings
-		from enigma import eDVBDB
-		eDVBDB.getInstance().reloadBouquets()
-		eDVBDB.getInstance().reloadServicelist()
-		self.mbox = self.session.open(MessageBox,(_("Configuration is saved and service restarted")), MessageBox.TYPE_INFO, timeout = 4 )
 		
-	def strReplace(self, file, search, replace):
-		with open(file,'r') as f:
-			newlines = []
-			for line in f.readlines():
-                		newlines.append(line.replace(search, replace))
-                with open(file, 'w') as f:
-                    for line in newlines:
-                            f.write(line)	                        
-
-class udpxyServer(Screen):
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		Screen.setTitle(self, _("Movistar+ Iptv Server"))
-		self.skinName = "NetworkNfs"
-		self.onChangedEntry = [ ]
-		self['lab1'] = Label(_("Autostart:"))
-		self['labactive'] = Label(_(_("Disabled")))
-		self['lab2'] = Label(_("Current Status:"))
-		self['labstop'] = Label(_("Stopped"))
-		self['labrun'] = Label(_("Running"))
-		self['key_green'] = Label(_("Start"))
-		self['key_red'] = Label(_("Remove Service"))
-		self['key_yellow'] = Label(_("Autostart"))
-		self['key_blue'] = Label(_("Config"))
-		self.Console = Console()
-		self.my_mitv_active = False
-		self.my_mitv_run = False
-		self['actions'] = ActionMap(['WizardActions', 'ColorActions'], {'ok': self.close, 'back': self.close, 'red': self.UninstallCheck, 'green': self.udpxyServerStartStop, 'yellow': self.udpxyServerSet, 'blue': self.udpxyCfg })
-		self.service_name = 'enigma2-plugin-extensions-udpxyserver'
-		self.onLayoutFinish.append(self.InstallCheck)
-	
-	def udpxyCfg(self):
-		self.session.open(udpxyConfig)
-
-	def InstallCheck(self):
-		print '/usr/bin/opkg list_installed ' + self.service_name
-		self.Console.ePopen('/usr/bin/opkg list_installed ' + self.service_name, self.checkNetworkState)
-
-	def checkNetworkState(self, str, retval, extra_args):
-		print "checkNetworkState ", str
-		if 'Collected errors' in str:
-			self.session.openWithCallback(self.close, MessageBox, _("A background update check is in progress, please wait a few minutes and try again."), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		elif not str:
-			self.feedscheck = self.session.open(MessageBox,_('Please wait whilst feeds state is checked.'), MessageBox.TYPE_INFO, enable_input = False)
-			self.feedscheck.setTitle(_('Checking Feeds'))
-			cmd1 = "opkg update"
-			self.CheckConsole = Console()
-			self.CheckConsole.ePopen(cmd1, self.checkNetworkStateFinished)
-		else:
-			self.updateService()
-
-	def checkNetworkStateFinished(self, result, retval,extra_args=None):
-		print "checkNetworkStateFinished ", result
-		if 'bad address' in result:
-			self.session.openWithCallback(self.InstallPackageFailed, MessageBox, _("Your %s %s is not connected to the internet, please check your network settings and try again.") % (getMachineBrand(), getMachineName()), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		elif ('wget returned 1' or 'wget returned 255' or '404 Not Found') in result:
-			self.session.openWithCallback(self.InstallPackageFailed, MessageBox, _("Sorry feeds are down for maintenance, please try again later."), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
-		else:
-			self.session.openWithCallback(self.InstallPackage,MessageBox,_('Your %s %s will be restarted after the installation of service\nReady to install %s ?')  % (getMachineBrand(), getMachineName(), self.service_name), MessageBox.TYPE_YESNO)
-
-	def InstallPackage(self, val):
-		print "InstallPackage ", val
-		if val:
-			self.doInstall(self.installComplete, self.service_name)
-		else:
-			self.feedscheck.close()
-			self.close()
-
-	def InstallPackageFailed(self, val):
-		print "InstallPackageFailed"
-		self.feedscheck.close()
-		self.close()
-
-	def doInstall(self, callback, pkgname):
-		print "doInstall " ,callback, pkgname
-		self.message = self.session.open(MessageBox,_("please wait..."), MessageBox.TYPE_INFO, enable_input = False)
-		self.message.setTitle(_('Installing Service'))
-		self.Console.ePopen('/usr/bin/opkg install enigma2-plugin-settings-openplus.movistar.e2.iptv', callback)
-
-	def installComplete(self,result = None, retval = None, extra_args = None):
-		self.session.open(TryQuitMainloop, 2)
-
-	def UninstallCheck(self):
-		self.Console.ePopen('/usr/bin/opkg list_installed ' + self.service_name, self.RemovedataAvail)
-
-	def RemovedataAvail(self, str, retval, extra_args):
-		if str:
-			restartbox = self.session.openWithCallback(self.RemovePackage,MessageBox,_('Your %s %s will be restarted after the removal of service\nDo you want to remove now ?') % (getMachineBrand(), getMachineName()), MessageBox.TYPE_YESNO)
-			restartbox.setTitle(_('Ready to remove %s ?') % self.service_name)
-		else:
-			self.updateService()
-
-	def RemovePackage(self, val):
-		if val:
-			self.doRemove(self.removeComplete, self.service_name)
-
-	def doRemove(self, callback, pkgname):
-		self.message = self.session.open(MessageBox,_("please wait..."), MessageBox.TYPE_INFO, enable_input = False)
-		self.message.setTitle(_('Removing Service'))
-		self.Console.ePopen('/usr/bin/opkg remove ' + pkgname + ' enigma2-plugin-settings-openplus.movistar.e2.iptv --force-remove --autoremove --force-depends', callback)
-		config.networkiptv.udpxyport.setValue("8088")
-		config.networkiptv.udpxyipserver.setValue([127,0,0,1])
-		config.networkiptv.udpxyipclient.setValue([192,168,0,1])
-		config.networkiptv.udpxyloginclient.setValue("root")
-		config.networkiptv.udpxypassclient.setValue("")
-		config.networkiptv.udpxyport.save()
-		config.networkiptv.udpxyipserver.save()
-		configfile.save()
-
-	def removeComplete(self,result = None, retval = None, extra_args = None):
-		self.session.open(TryQuitMainloop, 2)
-
-	def createSummary(self):
-		return NetworkServicesSummary
-
-	def udpxyServerStartStop(self):
-		if not self.my_mitv_run:
-			self.Console.ePopen('/etc/init.d/udpxy start', self.StartStopCallback)
-		elif self.my_mitv_run:
-			self.Console.ePopen('/etc/init.d/udpxy stop', self.StartStopCallback)
-
-	def StartStopCallback(self, result = None, retval = None, extra_args = None):
-		time.sleep(3)
-		self.updateService()
-
-	def udpxyServerSet(self):
-		if fileExists('/etc/rc3.d/S20udpxy'):
-			self.Console.ePopen('update-rc.d -f udpxy remove', self.StartStopCallback)
-		else:
-			self.Console.ePopen('update-rc.d -f udpxy defaults 20', self.StartStopCallback)
-
-	def updateService(self):
-		import process
-		p = process.ProcessList()
-		mitv_process = str(p.named('udpxy')).strip('[]')
-		self['labrun'].hide()
-		self['labstop'].hide()
-		self['labactive'].setText(_("Disabled"))
-		self.my_mitv_active = False
-		self.my_mitv_run = False
-		if fileExists('/etc/rc3.d/S20udpxy'):
-			self['labactive'].setText(_("Enabled"))
-			self['labactive'].show()
-			self.my_mitv_active = True
-		if mitv_process:
-			self.my_mitv_run = True
-		if self.my_mitv_run:
-			self['labstop'].hide()
-			self['labrun'].show()
-			self['key_green'].setText(_("Stop"))
-			status_summary= self['lab2'].text + ' ' + self['labrun'].text
-		else:
-			self['labstop'].show()
-			self['labrun'].hide()
-			self['key_green'].setText(_("Start"))
-			status_summary= self['lab2'].text + ' ' + self['labstop'].text
-		title = _("Movistar+ Iptv Server")
-		autostartstatus_summary = self['lab1'].text + ' ' + self['labactive'].text
-
-		for cb in self.onChangedEntry:
-			cb(title, status_summary, autostartstatus_summary)
diff --git a/lib/python/Screens/OScamInfo.py b/lib/python/Screens/OScamInfo.py
index 92faace..1db6034 100644
--- a/lib/python/Screens/OScamInfo.py
+++ b/lib/python/Screens/OScamInfo.py
@@ -26,11 +26,11 @@ sizeH = 700
 HDSKIN = False
 screenwidth = getDesktop(0).size().width()
 if screenwidth and screenwidth == 1920:
-	f = 1
+	f = 1.5
 	sizeH = screenwidth - 150
 	HDSKIN = True
 elif screenwidth and screenwidth > 1920:
-	f = 1.5
+	f = 3
 	HDSKIN = True
 	sizeH = screenwidth - 300
 elif screenwidth and screenwidth > 1024:
@@ -88,6 +88,8 @@ class OscamInfo:
 
 	def getUserData(self):
 		[webif, port, conf, ipcompiled] = self.confPath()
+		if conf == None:
+			conf = ""
 		conf += "/oscam.conf"
 
 		# Assume that oscam webif is NOT blocking localhost, IPv6 is also configured if it is compiled in,
@@ -176,7 +178,7 @@ class OscamInfo:
 			elif hasattr(e, "code"):
 				err = str(e.code)
 		if err is not False:
-			print "[openWebIF] Fehler: %s" % err
+			print "[openWebIF] error: %s" % err
 			return False, err
 		else:
 			return True, data
@@ -367,7 +369,7 @@ class oscMenuList(MenuList):
 	def __init__(self, list, itemH = 30):
 		MenuList.__init__(self, list, False, eListboxPythonMultiContent)
 		self.l.setItemHeight(int(itemH*f))
-		self.l.setFont(0, gFont("Regular", int(22*f)))
+		self.l.setFont(0, gFont("Regular", int(20*f)))
 		self.l.setFont(1, gFont("Regular", int(18*f)))
 		self.clientFont = gFont("Regular", int(16*f))
 		self.l.setFont(2, self.clientFont)
diff --git a/lib/python/Screens/ParentalControlSetup.py b/lib/python/Screens/ParentalControlSetup.py
index 6fe7a3d..2feaa89 100644
--- a/lib/python/Screens/ParentalControlSetup.py
+++ b/lib/python/Screens/ParentalControlSetup.py
@@ -89,7 +89,7 @@ class ParentalControlSetup(Screen, ConfigListScreen, ProtectedScreen):
 			self.list.append(getConfigListEntry(_("Protect movie list"), config.ParentalControl.config_sections.movie_list))
 			self.list.append(getConfigListEntry(_("Protect context menus"), config.ParentalControl.config_sections.context_menus))
 			self.list.append(getConfigListEntry(_("Protect Quickmenu"), config.ParentalControl.config_sections.quickmenu))
-			self.list.append(getConfigListEntry(_("Protect OpenPanel"), config.ParentalControl.config_sections.openpanel))
+			self.list.append(getConfigListEntry(_("Protect InfoPanel"), config.ParentalControl.config_sections.infopanel))
 		self["config"].list = self.list
 		self["config"].setList(self.list)
 
diff --git a/lib/python/Screens/PluginBrowser.py b/lib/python/Screens/PluginBrowser.py
index 33691aa..97d68c9 100644
--- a/lib/python/Screens/PluginBrowser.py
+++ b/lib/python/Screens/PluginBrowser.py
@@ -28,13 +28,13 @@ config.pluginfilter = ConfigSubsection()
 config.pluginfilter.kernel = ConfigYesNo(default = False)
 config.pluginfilter.drivers = ConfigYesNo(default = True)
 config.pluginfilter.extensions = ConfigYesNo(default = True)
+config.pluginfilter.po = ConfigYesNo(default = True)
 config.pluginfilter.m2k = ConfigYesNo(default = True)
 config.pluginfilter.picons = ConfigYesNo(default = True)
 config.pluginfilter.pli = ConfigYesNo(default = False)
 config.pluginfilter.security = ConfigYesNo(default = True)
 config.pluginfilter.settings = ConfigYesNo(default = True)
-config.pluginfilter.skins = ConfigYesNo(default = True)
-config.pluginfilter.skincomponents = ConfigYesNo(default = True)
+config.pluginfilter.skin = ConfigYesNo(default = True)
 config.pluginfilter.display = ConfigYesNo(default = True)
 config.pluginfilter.softcams = ConfigYesNo(default = True)
 config.pluginfilter.systemplugins = ConfigYesNo(default = True)
@@ -473,6 +473,8 @@ class PluginDownloadBrowser(Screen):
 			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'drivers')
 		if config.pluginfilter.extensions.value:
 			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'extensions')
+		if config.pluginfilter.po.value:
+			self.PLUGIN_PREFIX2.append('enigma2-locale-')
 		if config.pluginfilter.m2k.value:
 			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'm2k')
 		if config.pluginfilter.picons.value:
@@ -483,10 +485,8 @@ class PluginDownloadBrowser(Screen):
 			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'security')
 		if config.pluginfilter.settings.value:
 			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'settings')
-		if config.pluginfilter.skins.value:
-			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'skins')
-		if config.pluginfilter.skincomponents.value:
-			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'skincomponents')
+		if config.pluginfilter.skin.value:
+			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'skin')
 		if config.pluginfilter.display.value:
 			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'display')
 		if config.pluginfilter.softcams.value:
@@ -499,7 +499,6 @@ class PluginDownloadBrowser(Screen):
 			self.PLUGIN_PREFIX2.append(self.PLUGIN_PREFIX + 'weblinks')
 		if config.pluginfilter.kernel.value:
 			self.PLUGIN_PREFIX2.append('kernel-module-')
-		self.PLUGIN_PREFIX2.append('enigma2-locale-')
 
 	def go(self):
 		sel = self["list"].l.getCurrentSelection()
@@ -631,6 +630,9 @@ class PluginDownloadBrowser(Screen):
 	def startIpkgListInstalled(self, pkgname = PLUGIN_PREFIX + '*'):
 		self.container.execute(self.ipkg + Ipkg.opkgExtraDestinations() + " list_installed")
 
+	def startIpkgListAvailable(self):
+		self.container.execute(self.ipkg + Ipkg.opkgExtraDestinations() + " list")
+		
 	def startRun(self):
 		listsize = self["list"].instance.size()
 		self["list"].instance.hide()
@@ -682,19 +684,7 @@ class PluginDownloadBrowser(Screen):
 				self.startIpkgListInstalled()
 		elif self.run == 1 and self.type == self.DOWNLOAD:
 			self.run = 2
-			from Components import opkg
-			pluginlist = []
-			self.pluginlist = pluginlist
-			for plugin in opkg.enumPlugins(self.PLUGIN_PREFIX):
-				if not plugin[0].endswith('-common') and not plugin[0].endswith('-meta') and plugin[0] not in self.installedplugins and ((not config.pluginbrowser.po.value and not plugin[0].endswith('-po')) or config.pluginbrowser.po.value) and ((not config.pluginbrowser.src.value and not plugin[0].endswith('-src')) or config.pluginbrowser.src.value):
-					pluginlist.append(plugin + (plugin[0][15:],))
-			if pluginlist:
-				self["text"].hide()
-				pluginlist.sort()
-				self.updateList()
-				self["list"].instance.show()
-			else:
-				self["text"].setText(_("No new plugins found"))
+			self.startIpkgListAvailable()
 		else:
 			if len(self.pluginlist) > 0:
 				self.updateList()
@@ -859,12 +849,12 @@ class PluginFilter(ConfigListScreen, Screen):
 		self.list = []
 		self.list.append(getConfigListEntry(_("drivers"), config.pluginfilter.drivers, _("This allows you to show drivers modules in downloads")))
 		self.list.append(getConfigListEntry(_("extensions"), config.pluginfilter.extensions, _("This allows you to show extensions modules in downloads")))
+		self.list.append(getConfigListEntry(_("languages"), config.pluginfilter.po, _("This allows you to show languages in downloads")))
 		self.list.append(getConfigListEntry(_("systemplugins"), config.pluginfilter.systemplugins, _("This allows you to show systemplugins modules in downloads")))
 		if Check_Softcam():
 			self.list.append(getConfigListEntry(_("softcams"), config.pluginfilter.softcams, _("This allows you to show softcams modules in downloads")))
-		self.list.append(getConfigListEntry(_("skins"), config.pluginfilter.skins, _("This allows you to show skins modules in downloads")))
-		self.list.append(getConfigListEntry(_("skincomponents"), config.pluginfilter.skincomponents, _("This allows you to show skincomponents in downloads")))
-		self.list.append(getConfigListEntry(_("display"), config.pluginfilter.skins, _("This allows you to show lcd skins in downloads")))
+		self.list.append(getConfigListEntry(_("skin"), config.pluginfilter.skin, _("This allows you to show skin modules in downloads")))
+		self.list.append(getConfigListEntry(_("display"), config.pluginfilter.display, _("This allows you to show lcd skins in downloads")))
 		self.list.append(getConfigListEntry(_("picons"), config.pluginfilter.picons, _("This allows you to show picons modules in downloads")))
 		self.list.append(getConfigListEntry(_("settings"), config.pluginfilter.settings, _("This allows you to show settings modules in downloads")))
 		self.list.append(getConfigListEntry(_("m2k"), config.pluginfilter.m2k, _("This allows you to show m2k modules in downloads")))
@@ -873,7 +863,7 @@ class PluginFilter(ConfigListScreen, Screen):
 		self.list.append(getConfigListEntry(_("vix"), config.pluginfilter.vix, _("This allows you to show vix modules in downloads")))
 		self.list.append(getConfigListEntry(_("security"), config.pluginfilter.security, _("This allows you to show security modules in downloads")))
 		self.list.append(getConfigListEntry(_("kernel modules"), config.pluginfilter.kernel, _("This allows you to show kernel modules in downloads")))
-		self.list.append(getConfigListEntry(_("user feed url"), config.pluginfilter.userfeed, _("Please enter the your personal feed URL")))
+		self.list.append(getConfigListEntry(_("user feed url"), config.pluginfilter.userfeed, _("Please enter your personal feed URL")))
 		
 		self["config"].list = self.list
 		self["config"].setList(self.list)
diff --git a/lib/python/Screens/PowerTimerEntry.py b/lib/python/Screens/PowerTimerEntry.py
index 03b20e8..c3d8001 100644
--- a/lib/python/Screens/PowerTimerEntry.py
+++ b/lib/python/Screens/PowerTimerEntry.py
@@ -123,7 +123,7 @@ class TimerEntry(Screen, ConfigListScreen):
 		else:
 			shutdownString = _("shut down")
 		self.timerentry_timertype = ConfigSelection(choices = [("nothing", _("do nothing")),("wakeup", _("wakeup")),("wakeuptostandby", _("wakeup to standby")), ("autostandby", _("auto standby")), ("autodeepstandby", _("auto deepstandby")), ("standby", _("go to standby")), ("deepstandby", shutdownString), ("reboot", _("reboot system")), ("restart", _("restart GUI"))], default = timertype)
-		self.timerentry_afterevent = ConfigSelection(choices = [("nothing", _("do nothing")),("wakeup", _("wakeup")), ("wakeuptostandby", _("wakeup to standby")), ("standby", _("go to standby")), ("deepstandby", shutdownString), ("nothing", _("do nothing"))], default = afterevent)
+		self.timerentry_afterevent = ConfigSelection(choices = [("nothing", _("do nothing")),("wakeup", _("wakeup")), ("wakeuptostandby", _("wakeup to standby")), ("standby", _("go to standby")), ("deepstandby", shutdownString)], default = afterevent)
 		self.timerentry_type = ConfigSelection(choices = [("once",_("once")), ("repeated", _("repeated"))], default = type)
 
 		self.timerentry_repeated = ConfigSelection(default = repeated, choices = [("daily", _("daily")), ("weekly", _("weekly")), ("weekdays", _("Mon-Fri")), ("user", _("user defined"))])
diff --git a/lib/python/Screens/Satconfig.py b/lib/python/Screens/Satconfig.py
index 2eb6b10..66af995 100644
--- a/lib/python/Screens/Satconfig.py
+++ b/lib/python/Screens/Satconfig.py
@@ -309,6 +309,8 @@ class NimSetup(Screen, ConfigListScreen, ServiceStopScreen):
 				self.list.append(getConfigListEntry(_("Tone amplitude"), nimConfig.toneAmplitude))
 			if path.exists("/proc/stb/frontend/%d/use_scpc_optimized_search_range" % self.nim.slot) and config.usage.setup_level.index >= 2: # expert
 				self.list.append(getConfigListEntry(_("SCPC optimized search range"), nimConfig.scpcSearchRange))
+			if path.exists("/proc/stb/frontend/%d/t2mirawmode" % self.nim.slot) and config.usage.setup_level.index >= 2: # expert
+				self.list.append(getConfigListEntry(_("T2MI RAW Mode"), nimConfig.t2miRawMode))
 
 		elif self.nim.isCompatible("DVB-C"):
 			self.configMode = getConfigListEntry(_("Configuration mode"), self.nimConfig.dvbc.configMode)
@@ -823,7 +825,7 @@ class NimSetup(Screen, ConfigListScreen, ServiceStopScreen):
 
 	def layoutFinished(self):
 		self.newConfig()
-		self.setTitle(_("Reception Settings"))
+		self.setTitle(_("Reception Settings") + " " + _("Tuner") + " " + self.nim.slot_input_name)
 
 	def keyLeft(self):
 		cur = self["config"].getCurrent()
@@ -893,8 +895,8 @@ class NimSetup(Screen, ConfigListScreen, ServiceStopScreen):
 			self.nimConfig.terrestrial.value = self.originalTerrestrialRegion
 			self.nimConfig.terrestrial.save()
 		if hasattr(self, "originalCableRegion"):
-			self.nimConfig.cable.scan_provider.value = self.originalCableRegion
-			self.nimConfig.cable.scan_provider.save()
+			self.nimConfig.dvbc.scan_provider.value = self.originalCableRegion
+			self.nimConfig.dvbc.scan_provider.save()
 		# we need to call saveAll to reset the connectedTo choices
 		self.saveAll()
 		self.restoreService(_("Zap back to service before tuner setup?"))
@@ -1023,7 +1025,7 @@ class NimSelection(Screen):
 
 	def NimSetupCB(self, index=None):
 		self.loadFBCLinks()
-		self.updateList()
+		self.updateList(index)
 
 	def showNim(self, nim):
 		return True
diff --git a/lib/python/Screens/ScanSetup.py b/lib/python/Screens/ScanSetup.py
index f3a0d47..1d984f8 100755
--- a/lib/python/Screens/ScanSetup.py
+++ b/lib/python/Screens/ScanSetup.py
@@ -120,9 +120,12 @@ terrestrial_autoscan_nimtype = {
 'SSH108' : 'ssh108_t2_scan',
 'TT3L10' : 'tt3l10_t2_scan',
 'TURBO' : 'vuplus_turbo_t',
-'TT2L08' : 'tt2l08_t2_scan'
+'TT2L08' : 'tt2l08_t2_scan',
+'BCM3466' : 'bcm3466'
 }
 
+dual_tuner_list = ('TT3L10', 'BCM3466')
+
 def GetDeviceId(filter, nim_idx):
 	tuners={}
 	device_id = 0
@@ -507,9 +510,9 @@ class TerrestrialTransponderSearchSupport:
 			if nim_name is not None and nim_name != "":
 				device_id = ""
 				nim_name = nim_name.split(' ')[-1][4:-1]
-				if nim_name == 'TT3L10':
+				if nim_name in dual_tuner_list:
 					try:
-						device_id = GetDeviceId('TT3L10', nim_idx)
+						device_id = GetDeviceId(nim_name, nim_idx)
 						device_id = "--device %s" % (device_id)
 					except Exception, err:
 						print "terrestrialTransponderGetCmd ->", err
@@ -961,9 +964,9 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport, Terrest
 			"fec": eDVBFrontendParametersSatellite.FEC_Auto,
 			"fec_s2": eDVBFrontendParametersSatellite.FEC_9_10,
 			"modulation": eDVBFrontendParametersSatellite.Modulation_QPSK,
-			"is_id": 0,
-			"pls_mode": eDVBFrontendParametersSatellite.PLS_Root,
-			"pls_code": 1 }
+			"is_id": eDVBFrontendParametersSatellite.No_Stream_Id_Filter,
+			"pls_mode": eDVBFrontendParametersSatellite.PLS_Gold,
+			"pls_code": 0 }
 		defaultCab = {
 			"frequency": 466,
 			"inversion": eDVBFrontendParametersCable.Inversion_Unknown,
@@ -1001,9 +1004,9 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport, Terrest
 					defaultSat["fec_s2"] = frontendData.get("fec_inner", eDVBFrontendParametersSatellite.FEC_Auto)
 					defaultSat["rolloff"] = frontendData.get("rolloff", eDVBFrontendParametersSatellite.RollOff_alpha_0_35)
 					defaultSat["pilot"] = frontendData.get("pilot", eDVBFrontendParametersSatellite.Pilot_Unknown)
-					defaultSat["is_id"] = frontendData.get("is_id", 0)
-					defaultSat["pls_mode"] = frontendData.get("pls_mode", eDVBFrontendParametersSatellite.PLS_Root)
-					defaultSat["pls_code"] = frontendData.get("pls_code", 1)
+					defaultSat["is_id"] = frontendData.get("is_id", eDVBFrontendParametersSatellite.No_Stream_Id_Filter)
+					defaultSat["pls_mode"] = frontendData.get("pls_mode", eDVBFrontendParametersSatellite.PLS_Gold)
+					defaultSat["pls_code"] = frontendData.get("pls_code", 0)
 				else:
 					defaultSat["fec"] = frontendData.get("fec_inner", eDVBFrontendParametersSatellite.FEC_Auto)
 				defaultSat["modulation"] = frontendData.get("modulation", eDVBFrontendParametersSatellite.Modulation_QPSK)
@@ -1122,12 +1125,12 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport, Terrest
 			(eDVBFrontendParametersSatellite.Pilot_Off, _("Off")),
 			(eDVBFrontendParametersSatellite.Pilot_On, _("On")),
 			(eDVBFrontendParametersSatellite.Pilot_Unknown, _("Auto"))])
-		self.scan_sat.is_id = ConfigInteger(default = defaultSat.get("is_id",0), limits = (0, 255))
+		self.scan_sat.is_id = ConfigInteger(default = defaultSat["is_id"], limits = (eDVBFrontendParametersSatellite.No_Stream_Id_Filter, 255))
 		self.scan_sat.pls_mode = ConfigSelection(default = defaultSat["pls_mode"], choices = [
 			(eDVBFrontendParametersSatellite.PLS_Root, _("Root")),
 			(eDVBFrontendParametersSatellite.PLS_Gold, _("Gold")),
 			(eDVBFrontendParametersSatellite.PLS_Combo, _("Combo"))])
-		self.scan_sat.pls_code = ConfigInteger(default = defaultSat.get("pls_code",1), limits = (0, 262142))
+		self.scan_sat.pls_code = ConfigInteger(default = defaultSat.get("pls_code",0), limits = (0, 262142))
 
 		# cable
 		self.scan_cab.frequency = ConfigInteger(default = defaultCab["frequency"], limits = (50, 999))
@@ -1423,7 +1426,7 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport, Terrest
 		if not answer or self.scan_nims.value == "":
 			return
 		tlist = []
-		flags = None
+		flags = 0
 		removeAll = True
 		action = START_SCAN
 		index_to_scan = int(self.scan_nims.value)
@@ -1500,6 +1503,14 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport, Terrest
 			elif self.scan_typecable.value == "complete":
 				if config.Nims[index_to_scan].dvbc.scan_type.value == "provider":
 					getInitialCableTransponderList(tlist, index_to_scan)
+				elif nimmanager.nim_slots[index_to_scan].supportsBlindScan():
+					flags |= eComponentScan.scanBlindSearch
+					self.addCabTransponder(tlist, 73000,
+												  (866000 - 73000) / 1000,
+												  eDVBFrontendParametersCable.Modulation_Auto,
+												  eDVBFrontendParametersCable.FEC_Auto,
+												  eDVBFrontendParametersCable.Inversion_Unknown)
+					removeAll = False
 				else:
 					action = SEARCH_CABLE_TRANSPONDERS
 
@@ -1559,7 +1570,7 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport, Terrest
 			elif self.scan_typeatsc.value == "complete":
 				getInitialATSCTransponderList(tlist, index_to_scan)
 
-		flags = self.scan_networkScan.value and eComponentScan.scanNetworkSearch or 0
+		flags |= self.scan_networkScan.value and eComponentScan.scanNetworkSearch or 0
 
 		tmp = self.scan_clearallservices.value
 		if tmp == "yes":
@@ -1878,6 +1889,7 @@ class ScanSimple(ConfigListScreen, Screen, CableTransponderSearchSupport, Terres
 			self.list.append(getConfigListEntry(_("Clear before scan"), self.scan_clearallservices))
 
 			#assign nims
+			tag_dvbc_default = tag_dvbt_default = tag_dvbs_default = tag_atsc_default = True
 			for item in networks.iteritems():
 				req_type = item[0]
 				for req_network in item[1]:
@@ -1888,7 +1900,9 @@ class ScanSimple(ConfigListScreen, Screen, CableTransponderSearchSupport, Terres
 						if req_type in ("DVB-S", "DVB-S2") and nim.config.dvbs.configMode.value != "nothing" and not tag_dvbs:
 							if req_network in nimmanager.getSatListForNim(nim.slot):
 								tag_dvbs = True
-								nimconfig = ConfigYesNo(default = True)
+								nimconfig = ConfigYesNo(default = tag_dvbs_default)
+								if tag_dvbs_default == True:
+									tag_dvbs_default = False
 								nimconfig.nim_index = nim.slot
 								nimconfig.network = req_network
 								nimconfig.nim_type = "DVB-S"
@@ -1898,32 +1912,38 @@ class ScanSimple(ConfigListScreen, Screen, CableTransponderSearchSupport, Terres
 						elif req_type in ("DVB-C", "DVB-C2") and nim.config.dvbc.configMode.value != "nothing"and not tag_dvbc:
 							if req_network in nimmanager.getCableDescription(nim.slot):
 								tag_dvbc = True
-								nimconfig = ConfigYesNo(default = True)
+								nimconfig = ConfigYesNo(default = tag_dvbc_default)
+								if tag_dvbc_default == True:
+									tag_dvbc_default = False
 								nimconfig.nim_index = nim.slot
 								nimconfig.network = req_network
 								nimconfig.nim_type = "DVB-C"
 								self.nim_enable.append(nimconfig)
-								self.list.append(getConfigListEntry(_("Scan ") + nim.slot_name + " (DVB-C) " + req_network, nimconfig))
+								self.list.append(getConfigListEntry(_("Scan ") + nim.slot_name + " (DVB-C) " + req_network[:45], nimconfig))
 								break;
 						elif req_type in ("DVB-T", "DVB-T2") and nim.config.dvbt.configMode.value != "nothing" and not tag_dvbt:
 							if req_network in nimmanager.getTerrestrialDescription(nim.slot):
 								tag_dvbt = True
-								nimconfig = ConfigYesNo(default = True)
+								nimconfig = ConfigYesNo(default = tag_dvbt_default)
+								if tag_dvbt_default == True:
+									tag_dvbt_default = False
 								nimconfig.nim_index = nim.slot
 								nimconfig.network = req_network
 								nimconfig.nim_type = "DVB-T"
 								self.nim_enable.append(nimconfig)
-								self.list.append(getConfigListEntry(_("Scan ") + nim.slot_name + " (DVB-T) " + req_network, nimconfig))
+								self.list.append(getConfigListEntry(_("Scan ") + nim.slot_name + " (DVB-T) " + req_network[:45], nimconfig))
 								break;
 						elif req_type in ("ATSC") and nim.config.atsc.configMode.value != "nothing" and not tag_atsc:
 							if req_network in nimmanager.getATSCDescription(nim.slot):
 								tag_atsc = True
-								nimconfig = ConfigYesNo(default = True)
+								nimconfig = ConfigYesNo(default = tag_atsc_default)
+								if tag_atsc_default == True:
+									tag_atsc_default = False
 								nimconfig.nim_index = nim.slot
 								nimconfig.network = req_network
 								nimconfig.nim_type = "ATSC"
 								self.nim_enable.append(nimconfig)
-								self.list.append(getConfigListEntry(_("Scan ") + nim.slot_name + " (ATSC) " + req_network, nimconfig))
+								self.list.append(getConfigListEntry(_("Scan ") + nim.slot_name + " (ATSC) " + req_network[:45], nimconfig))
 								break;
 		self.list.sort()
 		ConfigListScreen.__init__(self, self.list)
diff --git a/lib/python/Screens/ServiceInfo.py b/lib/python/Screens/ServiceInfo.py
index ba40cfb..4d59809 100644
--- a/lib/python/Screens/ServiceInfo.py
+++ b/lib/python/Screens/ServiceInfo.py
@@ -153,10 +153,11 @@ class ServiceInfo(Screen):
 					resolution += ("i", "p", "-")[self.info.getInfo(iServiceInformation.sProgressive)]
 					resolution += str((self.info.getInfo(iServiceInformation.sFrameRate) + 500) / 1000)
 					aspect = self.getServiceInfoValue(iServiceInformation.sAspect)
-					if aspect in ( 1, 2, 5, 6, 9, 0xA, 0xD, 0xE ):
-						aspect = "4:3"
-					else:
-						aspect = "16:9"
+					aspect = aspect in ( 1, 2, 5, 6, 9, 0xA, 0xD, 0xE ) and "4:3" or "16:9"
+					resolution += " - ["+aspect+"]"
+					gamma = ("SDR", "HDR", "HDR10", "HLG", "")[self.info.getInfo(iServiceInformation.sGamma)]
+					if gamma:
+						resolution += " - " + gamma
 				f = open("/proc/stb/video/videomode")
 				videomode = f.read()[:-1].replace('\n','')
 				f.close()
diff --git a/lib/python/Screens/Setup.py b/lib/python/Screens/Setup.py
index 612f192..77a1e7c 100644
--- a/lib/python/Screens/Setup.py
+++ b/lib/python/Screens/Setup.py
@@ -248,6 +248,7 @@ class Setup(ConfigListScreen, Screen):
 					continue
 
 				requires = x.get("requires")
+				value = x.get("value")
 				if requires and requires.startswith('config.'):
 					item = eval(requires or "")
 					if item.value and not item.value == "0":
@@ -255,7 +256,7 @@ class Setup(ConfigListScreen, Screen):
 					else:
 						SystemInfo[requires] = False
 
-				if requires and not SystemInfo.get(requires, False):
+				if requires and not SystemInfo.get(requires, False) or value and not item.value==value:
 					continue
 
 				if self.PluginLanguageDomain:
diff --git a/lib/python/Screens/SkinSelector.py b/lib/python/Screens/SkinSelector.py
index 87c50bd..2cfb5b0 100644
--- a/lib/python/Screens/SkinSelector.py
+++ b/lib/python/Screens/SkinSelector.py
@@ -22,6 +22,8 @@ class SkinSelectorBase:
 			self.skinlist.append(self.PICONDEFAULTSKIN)
 		if self.ALTERNATESKINXML and os.path.exists(os.path.join(self.root, self.ALTERNATESKINXML)):
 			self.skinlist.append(self.ALTERNATESKIN)
+		if self.USERSKINXML and os.path.exists(os.path.join(self.root, self.USERSKINXML)):
+			self.skinlist.append(self.USERSKIN)
 		for root, dirs, files in os.walk(self.root, followlinks=True):
 			for subdir in dirs:
 				dir = os.path.join(root,subdir)
@@ -84,6 +86,9 @@ class SkinSelectorBase:
 		elif self["SkinList"].getCurrent() == self.ALTERNATESKIN:
 			self.skinfile = ""
 			self.skinfile = os.path.join(self.skinfile, self.ALTERNATESKINXML)
+		elif self["SkinList"].getCurrent() == self.USERSKIN:
+			self.skinfile = ""
+			self.skinfile = os.path.join(self.skinfile, self.USERSKINXML)
 		else:
 			self.skinfile = self["SkinList"].getCurrent()
 			self.skinfile = os.path.join(self.skinfile, self.SKINXML)
@@ -122,6 +127,9 @@ class SkinSelectorBase:
 		elif self["SkinList"].getCurrent() == self.ALTERNATESKIN:
 			pngpath = "."
 			pngpath = os.path.join(os.path.join(self.root, pngpath), "alternate.png")
+		elif self["SkinList"].getCurrent() == self.USERSKIN:
+			pngpath = "."
+			pngpath = os.path.join(os.path.join(self.root, pngpath), "userskin.png")
 		else:
 			pngpath = self["SkinList"].getCurrent()
 			try:
@@ -160,6 +168,8 @@ class SkinSelector(Screen, SkinSelectorBase):
 	PICONDEFAULTSKIN = None
 	ALTERNATESKINXML = None
 	ALTERNATESKIN = None
+	USERSKINXML = None
+	USERSKIN = None
 
 	skinlist = []
 	root = os.path.join(eEnv.resolve("${datadir}"),"enigma2")
@@ -178,6 +188,8 @@ class LcdSkinSelector(Screen, SkinSelectorBase):
 	PICONDEFAULTSKIN = _("< Default with Picon >")
 	ALTERNATESKINXML = "skin_display_alternate.xml"
 	ALTERNATESKIN = _("< Alternate Skin >")
+	USERSKINXML = "skin_display_usr.xml"
+	USERSKIN = _("< User Skin >")
 
 	skinlist = []
 	root = os.path.join(eEnv.resolve("${datadir}"),"enigma2/display/")
diff --git a/lib/python/Screens/SoftwareUpdate.py b/lib/python/Screens/SoftwareUpdate.py
index a88b9f1..927f405 100644
--- a/lib/python/Screens/SoftwareUpdate.py
+++ b/lib/python/Screens/SoftwareUpdate.py
@@ -209,7 +209,7 @@ class UpdatePlugin(Screen):
 		if 'bad address' in result:
 			self.session.openWithCallback(self.close, MessageBox, _("Your %s %s is not connected to the internet, please check your network settings and try again.") % (getMachineBrand(), getMachineName()), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
 		elif ('wget returned 1' or 'wget returned 255' or '404 Not Found') in result:
-			self.session.openWithCallback(self.close, MessageBox, _("Sorry feeds are down for maintenance, please try again later. If this issue persists please check www.open-plus.es"), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
+			self.session.openWithCallback(self.close, MessageBox, _("Sorry feeds are down for maintenance, please try again later. If this issue persists please check www.opena.tv"), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
 		elif 'Collected errors' in result:
 			self.session.openWithCallback(self.close, MessageBox, _("A background update check is in progress, please wait a few minutes and try again."), type=MessageBox.TYPE_INFO, timeout=10, close_on_any_key=True)
 		else:
diff --git a/lib/python/Screens/Standby.py b/lib/python/Screens/Standby.py
index d29797e..a9fbb2e 100644
--- a/lib/python/Screens/Standby.py
+++ b/lib/python/Screens/Standby.py
@@ -16,6 +16,68 @@ from gettext import dgettext
 import Components.RecordingConfig
 
 inStandby = None
+TVinStandby = None
+
+class TVstate: #load in Navigation
+	def __init__(self):
+		global TVinStandby
+		if TVinStandby is not None:
+			print "[Standby] only one TVstate instance is allowed!"
+		TVinStandby = self
+
+		try:
+			import Components.HdmiCec
+			self.hdmicec_instance = Components.HdmiCec.hdmi_cec.instance
+			self.hdmicec_ok = self.hdmicec_instance and config.hdmicec.enabled.value
+		except:
+			self.hdmicec_ok = False
+
+		if not self.hdmicec_ok:
+			print '[Standby] HDMI-CEC is not enabled or unavailable !!!'
+
+	def skipHdmiCecNow(self, value):
+		if self.hdmicec_ok:
+			if value is True or value is False:
+				self.hdmicec_instance.tv_skip_messages = value
+			elif 'zaptimer' in value:
+				self.hdmicec_instance.tv_skip_messages = config.hdmicec.control_tv_wakeup.value and not config.hdmicec.tv_wakeup_zaptimer.value and inStandby
+			elif 'zapandrecordtimer' in value:
+				self.hdmicec_instance.tv_skip_messages = config.hdmicec.control_tv_wakeup.value and not config.hdmicec.tv_wakeup_zapandrecordtimer.value and inStandby
+			elif 'wakeuppowertimer' in value:
+				self.hdmicec_instance.tv_skip_messages = config.hdmicec.control_tv_wakeup.value and not config.hdmicec.tv_wakeup_wakeuppowertimer.value and inStandby
+
+	def getTVstandby(self, value):
+		if self.hdmicec_ok:
+			if 'zaptimer' in value:
+				return config.hdmicec.control_tv_wakeup.value and not config.hdmicec.tv_wakeup_zaptimer.value
+			elif 'zapandrecordtimer' in value:
+				return config.hdmicec.control_tv_wakeup.value and not config.hdmicec.tv_wakeup_zapandrecordtimer.value
+			elif 'wakeuppowertimer' in value:
+				return config.hdmicec.control_tv_wakeup.value and not config.hdmicec.tv_wakeup_wakeuppowertimer.value
+			elif 'waitfortimesync' in value:
+				return config.hdmicec.control_tv_wakeup.value and not (config.hdmicec.deepstandby_waitfortimesync.value and config.workaround.deeprecord.value)
+		return False
+
+	def getTVstate(self, value):
+		if self.hdmicec_ok:
+			if not config.hdmicec.check_tv_state.value or self.hdmicec_instance.sendMessagesIsActive():
+				return False
+			elif value == 'on':
+				return value in self.hdmicec_instance.tv_powerstate and config.hdmicec.control_tv_standby.value
+			elif value == 'standby':
+				return value in self.hdmicec_instance.tv_powerstate and config.hdmicec.control_tv_wakeup.value
+			elif value == 'active':
+				return 'on' in self.hdmicec_instance.tv_powerstate and self.hdmicec_instance.activesource
+			elif value == 'notactive':
+				return 'standby' in self.hdmicec_instance.tv_powerstate or not self.hdmicec_instance.activesource
+		return False
+
+	def setTVstate(self, value):
+		if self.hdmicec_ok:
+			if value == 'on' or (value == 'power' and config.hdmicec.handle_deepstandby_events.value and not self.hdmicec_instance.handleTimer.isActive()):
+				self.hdmicec_instance.wakeupMessages()
+			elif value == 'standby':
+				self.hdmicec_instance.standbyMessages()
 
 def setLCDModeMinitTV(value):
 	try:
@@ -28,12 +90,15 @@ def setLCDModeMinitTV(value):
 class Standby2(Screen):
 	def Power(self):
 		print "[Standby] leave standby"
-		
+
 		if os.path.exists("/usr/script/StandbyLeave.sh"):
 			Console().ePopen("/usr/script/StandbyLeave.sh &")
 
-		if (getBrandOEM() in ('fulan')):
-			open("/proc/stb/hdmi/output", "w").write("on")
+		if (getBrandOEM() in ('fulan','clap','dinobot') or getBoxType() in ('sf8008','sf8008s','ustym4kpro')):
+			try:
+				open("/proc/stb/hdmi/output", "w").write("on")
+			except:
+				pass
 		#set input to encoder
 		self.avswitch.setInput("ENCODER")
 		#restart last played service
@@ -67,11 +132,8 @@ class Standby2(Screen):
 
 	def TVoff(self):
 		print "[Standby] TVoff"
-		try:
-			config.hdmicec.control_tv_standby_skipnow.setValue(False)
-			config.hdmicec.TVoffCounter.value += 1
-		except:
-			pass # no HdmiCec
+		TVinStandby.skipHdmiCecNow(False)
+		TVinStandby.setTVstate('standby')
 
 	def setMute(self):
 		if eDVBVolumecontrol.getInstance().isMuted():
@@ -148,8 +210,11 @@ class Standby2(Screen):
 			self.avswitch.setInput("SCART")
 		else:
 			self.avswitch.setInput("AUX")
-		if (getBrandOEM() in ('fulan')):
-			open("/proc/stb/hdmi/output", "w").write("off")
+		if (getBrandOEM() in ('fulan','clap','dinobot') or getBoxType() in ('sf8008','sf8008s','ustym4kpro')):
+			try:
+				open("/proc/stb/hdmi/output", "w").write("off")
+			except:
+				pass
 
 		if int(config.usage.hdd_standby_in_standby.value) != -1: # HDD standby timer value (box in standby) / -1 = same as when box is active
 			for hdd in harddiskmanager.HDDList():
@@ -279,8 +344,9 @@ class TryQuitMainloop(MessageBox):
 			default_yes = True
 			timeout=30
 		if recordings or (next_rec_time > 0 and (next_rec_time - time()) < 360):
-			default_yes = False
 			reason = _("Recording(s) are in progress or coming up in few seconds!") + '\n'
+			default_yes = False
+			timeout=30
 
 		if reason and inStandby:
 			session.nav.record_event.append(self.getRecordEvent)
diff --git a/lib/python/Screens/TaskView.py b/lib/python/Screens/TaskView.py
index 8f11ef5..69584c7 100644
--- a/lib/python/Screens/TaskView.py
+++ b/lib/python/Screens/TaskView.py
@@ -44,7 +44,7 @@ class JobView(InfoBarNotifications, Screen, ConfigListScreen):
 			"green": self.ok,
 			"red": self.abort,
 			"blue": self.background,
-			"cancel": self.ok,
+			"cancel": self.abort,
 			"ok": self.ok,
 		}, -2)
 
diff --git a/lib/python/Screens/TimerEntry.py b/lib/python/Screens/TimerEntry.py
index c015b6c..54c7914 100644
--- a/lib/python/Screens/TimerEntry.py
+++ b/lib/python/Screens/TimerEntry.py
@@ -320,8 +320,8 @@ class TimerEntry(Screen, ConfigListScreen):
 		cur = self["config"].getCurrent()
 		if cur in (self.channelEntry, self.tagsSet):
 			self.keySelect()
-		elif cur in (self.entryName, self.entryDescription):
-			self.renameEntry()
+		#elif cur in (self.entryName, self.entryDescription):
+		#	self.renameEntry()
 		else:
 			ConfigListScreen.keyLeft(self)
 			self.newConfig()
@@ -330,8 +330,8 @@ class TimerEntry(Screen, ConfigListScreen):
 		cur = self["config"].getCurrent()
 		if cur in (self.channelEntry, self.tagsSet):
 			self.keySelect()
-		elif cur in (self.entryName, self.entryDescription):
-			self.renameEntry()
+		#elif cur in (self.entryName, self.entryDescription):
+		#	self.renameEntry()
 		else:
 			ConfigListScreen.keyRight(self)
 			self.newConfig()
diff --git a/lib/python/Screens/VideoMode.py b/lib/python/Screens/VideoMode.py
index 3428616..c889173 100644
--- a/lib/python/Screens/VideoMode.py
+++ b/lib/python/Screens/VideoMode.py
@@ -49,7 +49,7 @@ def setProgressiveRate(vid_rate, new_rate, new_res, config_res, config_rate):
 			new_rate = config.av.autores_30p.value.split(',')[0]
 		else:
 			new_rate = config.av.autores_30p.value.split(',')[1]
-	if int(new_res) >= int(config_res) and config_rate != 'multi' and int(config_rate) < int(new_rate):
+	if int(new_res) >= int(config_res) and config_rate not in ("auto","multi") and int(config_rate) < int(new_rate):
 		new_rate = config_rate
 	return new_rate
 
@@ -205,8 +205,8 @@ class VideoSetup(Screen, ConfigListScreen):
 		elif config.av.aspect.value == "4:3":
 			self.list.append(getConfigListEntry(_("Display 16:9 content as"), config.av.policy_169, _("When the content has an aspect ratio of 16:9, choose whether to scale/stretch the picture.")))
 
-#		if config.av.videoport.value == "HDMI":
-#			self.list.append(getConfigListEntry(_("Allow unsupported modes"), config.av.edid_override))
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Allow unsupported modes"), config.av.edid_override,_("This option allows you to use all HDMI Modes")))
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color format"), config.av.colorformat, _("Configure which color format should be used on the SCART output.")))
 			if level >= 1:
@@ -226,12 +226,21 @@ class VideoSetup(Screen, ConfigListScreen):
 		if SystemInfo["havehdmicolordepth"]:
 			self.list.append(getConfigListEntry(_("HDMI Colordepth"), config.av.hdmicolordepth,_("This option allows you can config the Colordepth for UHD")))
 
+		if SystemInfo["havehdmihdrtype"]:
+			self.list.append(getConfigListEntry(_("HDMI HDR Type"), config.av.hdmihdrtype,_("This option allows you can force the HDR Modes for UHD")))
+
 		if SystemInfo["Canedidchecking"]:
 			self.list.append(getConfigListEntry(_("Bypass HDMI EDID Check"), config.av.bypass_edid_checking,_("This option allows you to bypass HDMI EDID check")))
 
 		if SystemInfo["haveboxmode"]:
 			self.list.append(getConfigListEntry(_("Change Boxmode to control Hardware Chip Modes*"), config.av.boxmode,_("Switch Mode to enable HDR Modes or PIP Functions")))
 
+		if SystemInfo["HDRSupport"]:
+			self.list.append(getConfigListEntry(_("HLG Support"), config.av.hlg_support,_("This option allows you can force the HLG Modes for UHD")))
+			self.list.append(getConfigListEntry(_("HDR10 Support"), config.av.hdr10_support,_("This option allows you can force the HDR10 Modes for UHD")))
+			self.list.append(getConfigListEntry(_("Allow 12bit"), config.av.allow_12bit,_("This option allows you can enable or disable the 12 Bit Color Mode")))
+			self.list.append(getConfigListEntry(_("Allow 10bit"), config.av.allow_10bit,_("This option allows you can enable or disable the 10 Bit Color Mode")))
+
 		self["config"].list = self.list
 		self["config"].l.setList(self.list)
 		if config.usage.sort_settings.value:
@@ -246,7 +255,7 @@ class VideoSetup(Screen, ConfigListScreen):
 
 		if int(res) > int(config_res) or (int(res) == int(config_res) and ((pol == 'p' and config_pol == 'i') or (config_mode == '2160p30' and mode == '2160p'))):
 			setmode[config_port].setValue(config_mode)
-		if config_rate != 'multi' and (rate == 'multi' or int(config_rate) < int(rate)):
+		if config_rate not in ("auto","multi") and (rate in ("auto","multi") or int(config_rate) < int(rate)):
 			setrate[config_mode].setValue(config_rate)
 
 	def keyLeft(self):
@@ -481,6 +490,8 @@ class AudioSetup(Screen, ConfigListScreen):
 				self.list.append(getConfigListEntry(_("WMA Pro"), config.av.wmapro, _("Choose whether WMA Pro channel sound tracks should be downmixed or transcoded.")))
 			if SystemInfo["CanDownmixAAC"]:
 				self.list.append(getConfigListEntry(_("AAC downmix"), config.av.downmix_aac, _("Choose whether multi channel sound tracks should be downmixed to stereo.")))
+			if SystemInfo["CanDownmixAACPlus"]:
+				self.list.append(getConfigListEntry(_("AAC plus downmix"), config.av.downmix_aacplus, _("Configure whether multi channel sound tracks should be downmixed to stereo.")))
 			if SystemInfo["Canaudiosource"]:
 				self.list.append(getConfigListEntry(_("Audio Source"), config.av.audio_source, _("Choose whether multi channel sound tracks should be convert to PCM or SPDIF.")))
 			if SystemInfo["CanAACTranscode"]:
@@ -500,6 +511,7 @@ class AudioSetup(Screen, ConfigListScreen):
 				self.list.append(getConfigListEntry(_("Audio Auto Volume Level"), config.av.autovolume,_("This option configures you can set Auto Volume Level.")))
 			self.list.append(getConfigListEntry(_("Audio volume step size"), config.av.volume_stepsize, _("Configure the general audio volume step size (limit 1-10).")))
 			self.list.append(getConfigListEntry(_("Audio volume step size fast mode"), config.av.volume_stepsize_fastmode, _("Configure the fast mode audio volume step size (limit 1-10). Activated when volume key permanent press or press fast in a row.")))
+			self.list.append(getConfigListEntry(_("Hide mute notification"), config.av.volume_hide_mute, _("If muted, hide mute icon or mute information after few seconds.")))
 
 		self["config"].list = self.list
 		self["config"].l.setList(self.list)
@@ -769,19 +781,19 @@ class AutoVideoMode(Screen):
 				autorestyp = 'simple'
 				new_rate = (video_rate + 500) / 1000
 				if video_height <= 576 and int(config_res) >= 576: #sd
-					if config.av.autores_rate_sd[config.av.autores_mode_sd[config.av.videoport.value].value].value == 'multi':
+					if config.av.autores_rate_sd[config.av.autores_mode_sd[config.av.videoport.value].value].value in ("auto","multi"):
 						if video_pol == 'i': new_rate *= 2
 					else:
 						new_rate = config.av.autores_rate_sd[config.av.autores_mode_sd[config.av.videoport.value].value].value.replace('Hz','')
 					new_mode = config.av.autores_mode_sd[config_port].value.replace('p30','p')
 				elif video_height <= 720 and int(config_res) >= 720: #hd
-					if config.av.autores_rate_hd[config.av.autores_mode_hd[config.av.videoport.value].value].value == 'multi':
+					if config.av.autores_rate_hd[config.av.autores_mode_hd[config.av.videoport.value].value].value in ("auto","multi"):
 						if video_pol == 'i': new_rate *= 2
 					else:
 						new_rate = config.av.autores_rate_hd[config.av.autores_mode_hd[config.av.videoport.value].value].value.replace('Hz','')
 					new_mode = config.av.autores_mode_hd[config_port].value.replace('p30','p')
 				elif video_height <= 1080 and int(config_res) >= 1080: #fhd
-					if config.av.autores_rate_fhd[config.av.autores_mode_fhd[config.av.videoport.value].value].value == 'multi':
+					if config.av.autores_rate_fhd[config.av.autores_mode_fhd[config.av.videoport.value].value].value in ("auto","multi"):
 						if video_pol == 'i': new_rate *= 2
 					else:
 						new_rate = config.av.autores_rate_fhd[config.av.autores_mode_fhd[config.av.videoport.value].value].value.replace('Hz','')
@@ -789,13 +801,13 @@ class AutoVideoMode(Screen):
 					if new_mode == '1080p' and not config.av.autores_1080i_deinterlace.value and video_height == 1080 and video_pol == 'i':
 						new_mode = '1080i'
 				elif video_height <= 2160 and int(config_res) >= 2160: #uhd
-					if config.av.autores_rate_uhd[config.av.autores_mode_uhd[config.av.videoport.value].value].value == 'multi':
+					if config.av.autores_rate_uhd[config.av.autores_mode_uhd[config.av.videoport.value].value].value in ("auto","multi"):
 						if video_pol == 'i': new_rate *= 2
 					else:
 						new_rate = config.av.autores_rate_uhd[config.av.autores_mode_uhd[config.av.videoport.value].value].value.replace('Hz','')
 					new_mode = config.av.autores_mode_uhd[config_port].value.replace('p30','p')
 				else:
-					if config_rate != 'multi': new_rate = config_rate
+					if config_rate not in ("auto","multi"): new_rate = config_rate
 					new_mode = config_mode
 				new_rate = str(new_rate)
 
@@ -807,7 +819,7 @@ class AutoVideoMode(Screen):
 				elif new_mode in iAVSwitch.modes_available:
 					write_mode = new_mode
 				else:
-					if config_rate != 'multi' and int(new_rate) > int(config_rate): new_rate = config_rate
+					if config_rate not in ("auto","multi") and int(new_rate) > int(config_rate): new_rate = config_rate
 					if config_mode+new_rate in iAVSwitch.modes_available:
 						write_mode = config_mode+new_rate
 					else:
@@ -824,12 +836,12 @@ class AutoVideoMode(Screen):
 
 				if video_height <= int(min_res):
 					if new_pol == 'i' and min_pol == 'p': new_pol = min_pol
-					if min_rate != 'multi' and new_rate < int(min_rate): new_rate = min_rate
+					if min_rate not in ("auto","multi") and new_rate < int(min_rate): new_rate = min_rate
 					new_res = min_res
 				if video_height >= int(config_res) or int(new_res) >= int(config_res):
 					new_res = config_res
 					if video_pol == 'p' and config_pol == 'i': new_pol = config_pol
-					if config_rate != 'multi' and int(config_rate) < new_rate: new_rate = config_rate
+					if config_rate not in ("auto","multi") and int(config_rate) < new_rate: new_rate = config_rate
 				new_rate = str(new_rate)
 
 				if new_pol == 'p':
@@ -866,7 +878,7 @@ class AutoVideoMode(Screen):
 					elif new_res+min_pol in iAVSwitch.modes_available:
 						write_mode = new_res+min_pol
 					else:
-						if config_rate != 'multi' and int(new_rate) > int(config_rate): new_rate = config_rate
+						if config_rate not in ("auto","multi") and int(new_rate) > int(config_rate): new_rate = config_rate
 						if config_mode+new_rate in iAVSwitch.modes_available:
 							write_mode = config_mode+new_rate
 						else:
@@ -916,7 +928,7 @@ class AutoVideoMode(Screen):
 				write_mode = new_mode
 			else:
 				autorestyp = 'no match'
-				if path.exists('/proc/stb/video/videomode_%shz' % new_rate) and config_rate == 'multi':
+				if path.exists('/proc/stb/video/videomode_%shz' % new_rate) and config_rate in ("auto","multi"):
 					f = open("/proc/stb/video/videomode_%shz" % new_rate, "r")
 					multi_videomode = f.read().replace('\n','')
 					f.close()
@@ -925,7 +937,7 @@ class AutoVideoMode(Screen):
 					else:
 						write_mode = config_mode+new_rate
 
-			# workaround for bug, see http://www.open-plus.es/forum/showthread.php?1642-Autoresolution-Plugin&p=38836&viewfull=1#post38836
+			# workaround for bug, see http://www.opena.tv/forum/showthread.php?1642-Autoresolution-Plugin&p=38836&viewfull=1#post38836
 			# always use a fixed resolution and frame rate   (e.g. 1080p50 if supported) for TV or .ts files
 			# always use a fixed resolution and correct rate (e.g. 1080p24/p50/p60 for all other videos
 			if config.av.smart1080p.value != 'false' and config.av.autores.value in ('all', 'hd'):
@@ -950,7 +962,7 @@ class AutoVideoMode(Screen):
 					new_rate = '50'
 				elif (mypath.find('p60.') >= 0) or (mypath.find('60p.') >= 0):
 					new_rate = '60'
-				elif new_rate == 'multi':
+				elif new_rate in ("auto","multi"):
 					new_rate = '' # omit frame rate specifier, e.g. '1080p' instead of '1080p50' if there is no clue
 				if mypath != '':
 					if mypath.endswith('.ts'):
diff --git a/lib/python/Screens/VideoWizard.py b/lib/python/Screens/VideoWizard.py
index 8e295ec..6fe6092 100644
--- a/lib/python/Screens/VideoWizard.py
+++ b/lib/python/Screens/VideoWizard.py
@@ -1,4 +1,3 @@
-from boxbranding import getBoxType, getMachineName
 from Screens.Wizard import WizardSummary
 from Screens.WizardLanguage import WizardLanguage
 from Screens.Rc import Rc
@@ -7,20 +6,25 @@ from Screens.Screen import Screen
 
 from Components.Pixmap import Pixmap
 from Components.config import config, ConfigBoolean, configfile
+from Components.SystemInfo import SystemInfo
 
 from Tools.Directories import resolveFilename, SCOPE_SKIN, SCOPE_ACTIVE_SKIN
 from Tools.HardwareInfo import HardwareInfo
 
-config.misc.showtestcard = ConfigBoolean(default = False)
 
-boxtype = getBoxType()
+config.misc.showtestcard = ConfigBoolean(default = False)
 
 has_rca = False
 has_dvi = False
-if boxtype in ('anadol4k','mediabox4k','dinobot4kl','dinobot4k','dinobot4kse','lunix','purehdse','lunix34k','zgemmah6','vipert2c','vipercombo','vipercombohdd','evoslimse','evoslimt2c','zgemmah4','spycat4kcombo','spycat4k','valalinux','formuler4ip','formuler3ip','formuler1tc','tm4ksuper','galaxy4k','zgemmah52splus','zgemmah2splus','zgemmah7','zgemmah32tc','zgemmah52tc','alphatriple','tmtwin4k','tmnanom3','tiviarmin','mbmicrov2', 'vimastec1500', 'revo4k','force3uhdplus','force3uhd','force2nano','zgemmah5ac', 'zgemmah3ac','bre2zet2c', 'e4hdcombo', 'ultrabox', 'osmega', 'tmnano3t', 'novacombo', 'novatwin', 'megaforce2', 'purehd', 'mutant11', 'sf128', 'sf138', 'xpeedlxpro', 'mbtwinplus', 'mutant51', 'ax51', 'formuler4', 'formuler4turbo', 'zgemmah5', 'zgemmah52s', 'sf98', 'evoslim', 'zgemmaslc', '9900lx', '9910lx', '9911lx', 'et7x00mini', 'tmnanosem2', 'tmnanosem2plus', 'evomini', 'evominiplus', 'zgemmahs', 'zgemmah2s', 'zgemmah2h', 't2cable', 'osmini', 'osminiplus', 'xpeedlxcs2', 'xpeedlxcc', 'odin2hybrid', 'odinplus', 'mutant500c', 'mutant530c', 'e4hd', 'e4hdhybrid' , 'mbmicro', 'beyonwizt2', 'fegasusx3', 'fegasusx5s', 'fegasusx5t', 'twinboxlcd', 'singleboxlcd', 'twinboxlcdci', 'twinboxlcdci5', 'sf3038', 'spycat', 'zgemmash1', 'zgemmash2', 'zgemmas2s', 'zgemmass' , 'formuler3', 'enibox', 'mago', 'sf108', 'x1plus', 'x2plus', 'atemio6000', 'atemio6100', 'atemio6200', 'mbminiplus', 'vp7358ci', 'xcombo', 'gbquad', 'gbquadplus', 'et5x00', 'et6000', 'et7000', 'et7100', 'et7500', 'et8500', 'et8500s', 'classm', 'axodin', 'axodinc', 'genius', 'evo', 'galaxym6', 'geniuse3hd', 'evoe3hd', 'axase3', 'axase3c', 'starsatlx', 'mixosf7', 'mixoslumi', 'tmnano', 'azboxme',  'azboxminime', 'optimussos1',  'optimussos2', 'gb800seplus', 'gb800ueplus', 'gbultrase', 'gbultraue', 'gbultraueh', 'sezam1000hd', 'ixussone', 'ixusszero', 'enfinity', 'marvel1', 'bre2ze', 'force1', 'force1plus', 'worldvisionf1', 'optimussos1plus',  'optimussos2plus',  'optimussos3plus', 'formuler1', 'tmnano2super', 'vusolose', 'vuzero', 'tyrant'):
-	has_rca = True
-if boxtype == 'dm8000' or boxtype == 'dm800':
-	has_dvi = True
+has_jack = False
+has_scart = False
+
+
+has_rca = SystemInfo["HaveRCA"]
+has_dvi = SystemInfo["HaveDVI"]
+has_jack = SystemInfo["HaveAVJACK"]
+has_scart = SystemInfo["HAVESCART"]
+
 
 class VideoWizardSummary(WizardSummary):
 	skin = (
@@ -104,8 +108,10 @@ class VideoWizard(WizardLanguage, Rc):
 				descr = port
 				if descr == 'HDMI' and has_dvi:
 					descr = 'DVI'
-				if descr == 'Scart' and has_rca:
+				if descr == 'Scart' and has_rca and not has_scart:
 					descr = 'RCA'
+				if descr == 'Scart' and has_jack and not has_scart:
+					descr = 'Jack'
 				if port != "DVI-PC":
 					list.append((descr,port))
 		list.sort(key = lambda x: x[0])
@@ -127,7 +133,9 @@ class VideoWizard(WizardLanguage, Rc):
 			if picname == 'HDMI' and has_dvi:
 				picname = "DVI"
 			if picname == 'Scart' and has_rca:
-				picname = "RCA"	
+				picname = "RCA"
+			if picname == 'Scart' and has_jack:
+				picname = "JACK"
 			self["portpic"].instance.setPixmapFromFile(resolveFilename(SCOPE_ACTIVE_SKIN, "icons/" + picname + ".png"))
 
 	def inputSelect(self, port):
@@ -175,6 +183,8 @@ class VideoWizard(WizardLanguage, Rc):
 			print mode
 			if mode[0] == querymode:
 				for rate in mode[1]:
+					if rate in ("auto") and not SystemInfo["have24hz"]:
+						continue
 					if self.port == "DVI-PC":
 						print "rate:", rate
 						if rate == "640x480":
diff --git a/lib/python/Screens/VirtualKeyBoard.py b/lib/python/Screens/VirtualKeyBoard.py
index 42afd4a..cc38f5f 100644
--- a/lib/python/Screens/VirtualKeyBoard.py
+++ b/lib/python/Screens/VirtualKeyBoard.py
@@ -52,6 +52,7 @@ class VirtualKeyBoard(Screen):
 
 		self.keyImages =  {
 				"BACKSPACE": self.key_backspace,
+				"CLEAR": self.key_clr,
 				"ALL": self.key_all,
 				"EXIT": self.key_esc,
 				"OK": self.key_ok,
@@ -126,13 +127,27 @@ class VirtualKeyBoard(Screen):
 				[u"q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
 				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
 				[u"<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"ALL"],
-				[u"SHIFT", u"SPACE", u"@", u"", u"OK", u"LEFT", u"RIGHT"]]
+				[u"SHIFT", u"SPACE", u"@", u"", u"[", u"]", u"OK", u"LEFT", u"RIGHT"]]
 			self.shiftkeys_list = [
 				[u"EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
 				[u"Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
 				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
 				[u">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
 				[u"SHIFT", u"SPACE", u"?", u"\\",u"|",u"^", u"OK", u"LEFT", u"RIGHT"]]
+			self.nextLang = 'hu_HU'
+		elif self.lang == 'hu_HU':
+			self.keys_list = [
+				[u"EXIT", u"0", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"BACKSPACE"],
+				[u"q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u""],
+				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u""],
+				[u"", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"ALL"],
+				[u"SHIFT", u"SPACE", u"", u"", u"", u"#", u"@", u"*", u"OK", u"LEFT", u"RIGHT", u"CLEAR"]]
+			self.shiftkeys_list = [
+				[u"EXIT", u"", u"'", u'"', u"+", u"!", u"%", u"/", u"=", u"(", u")", u"BACKSPACE"],
+				[u"Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u""],
+				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u""],
+				[u"", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u"?", u":", u"_", u";"],
+				[u"SHIFT", u"", u"", u"", u"&", u"<", u">", u"{", u"}", u"[", u"]", u"\\"]]
 			self.nextLang = 'es_ES'
 		elif self.lang == 'es_ES':
 			self.keys_list = [
@@ -266,7 +281,7 @@ class VirtualKeyBoard(Screen):
 				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
 				[u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u""],
 				[u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"#"],
-				[u"", u"", u"", u"", u"", u"", u"", u"", u"", "", u"", u"CLEAR"],
+				[u"", u"", u"", u"", u"", u"", u"", u"", u"", "", u"", u"ALL"],
 				[u"SHIFT", u"SPACE", u"+", u"-", u"*", u"/", u".", u",", u"@", u"%", u"&", u"OK"]]
 			self.shiftkeys_list = [
 				[u"EXIT", u"!", u'"', u"", u"$", u"^", u"<", u">", u"(", u")", u"=", u"BACKSPACE"],
diff --git a/lib/python/Tools/Downloader.py b/lib/python/Tools/Downloader.py
index 1d4af92..5f22041 100644
--- a/lib/python/Tools/Downloader.py
+++ b/lib/python/Tools/Downloader.py
@@ -6,7 +6,7 @@ from twisted.internet import reactor, defer, ssl
 
 class HTTPProgressDownloader(client.HTTPDownloader):
 	def __init__(self, url, outfile, headers=None):
-		client.HTTPDownloader.__init__(self, url, outfile, headers=headers, agent="Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;OpenPlus;;;)")
+		client.HTTPDownloader.__init__(self, url, outfile, headers=headers, agent="Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;OpenATV;;;)")
 		self.status = None
 		self.progress_callback = None
 		self.deferred = defer.Deferred()
diff --git a/lib/python/enigma_python.i b/lib/python/enigma_python.i
index 747802a..30dcbfb 100644
--- a/lib/python/enigma_python.i
+++ b/lib/python/enigma_python.i
@@ -42,6 +42,7 @@ is usually caused by not marking PSignals as immutable.
 #include <lib/base/eerror.h>
 #include <lib/base/etpm.h>
 #include <lib/base/message.h>
+#include <lib/base/modelinformation.h>
 #include <lib/base/e2avahi.h>
 #include <lib/driver/rc.h>
 #include <lib/driver/rcinput_swig.h>
@@ -158,6 +159,7 @@ typedef long time_t;
 
 %immutable eSocketNotifier::activated;
 %include <lib/base/ebase.h>
+%include <lib/base/modelinformation.h>
 %include <lib/base/smartptr.h>
 %include <lib/service/event.h>
 %include <lib/service/iservice.h>
diff --git a/lib/service/iservice.h b/lib/service/iservice.h
index 3517e89..7a8de8b 100644
--- a/lib/service/iservice.h
+++ b/lib/service/iservice.h
@@ -392,6 +392,8 @@ public:
 		sHideVBI,
 		sCenterDVBSubs,
 
+		sGamma,
+
 		sUser = 0x100
 	};
 	enum {
@@ -931,6 +933,8 @@ public:
 
 		evHBBTVInfo,
 
+		evVideoGammaChanged,
+
 		evUser = 0x100
 	};
 };
diff --git a/lib/service/listboxservice.cpp b/lib/service/listboxservice.cpp
index ed68142..5f0d0b0 100644
--- a/lib/service/listboxservice.cpp
+++ b/lib/service/listboxservice.cpp
@@ -878,7 +878,7 @@ void eListboxServiceContent::paint(gPainter &painter, eWindowStyle &style, const
 					tmp.setWidth(((!isPlayable || m_column_width == -1 || (!piconPixmap && !m_column_width)) ? tmp.width() : m_column_width) - xoffs);
 				}
 
-				eTextPara *para = new eTextPara(tmp);
+				ePtr<eTextPara> para = new eTextPara(tmp);
 				para->setFont(m_element_font[e]);
 				para->renderString(text.c_str());
 
diff --git a/lib/service/servicedvb.cpp b/lib/service/servicedvb.cpp
index 44e1cb4..b27acb4 100644
--- a/lib/service/servicedvb.cpp
+++ b/lib/service/servicedvb.cpp
@@ -42,6 +42,12 @@ using namespace std;
 #include <sstream>
 #include <iomanip>
 
+#if HAVE_ALIEN5
+extern "C" {
+#include <codec.h>
+}
+#endif
+
 class eStaticServiceDVBInformation: public iStaticServiceInformation
 {
 	DECLARE_REF(eStaticServiceDVBInformation);
@@ -1367,6 +1373,15 @@ RESULT eDVBServicePlay::start()
 		type = eDVBServicePMTHandler::streamclient;
 	}
 
+#if HAVE_ALIEN5
+	if(m_is_stream || m_is_pvr)
+	{
+			eDebug("[eDVBServicePlay]start m_is_pvr %d", m_is_pvr);
+			aml_set_demux2_source();
+	}
+#endif
+
+
 	m_first_program_info = 1;
 	ePtr<iTsSource> source = createTsSource(service, packetsize);
 	m_service_handler.tuneExt(service, source, service.path.c_str(), m_cue, false, m_dvb_service, type, scrambled);
@@ -1928,6 +1943,9 @@ int eDVBServicePlay::getInfo(int w)
 			return aspect;
 		break;
 	}
+	case sGamma:
+		if (m_decoder) return m_decoder->getVideoGamma();
+		break;
 	case sIsCrypted:
 		if (no_program_info)
 			return false;
@@ -1969,6 +1987,9 @@ int eDVBServicePlay::getInfo(int w)
 			apid = m_dvb_service->getCacheEntry(eDVBService::cAC3PID);
 			if (apid != -1)
 				return apid;
+			apid = m_dvb_service->getCacheEntry(eDVBService::cAC4PID);
+			if (apid != -1)
+				return apid;
 			apid = m_dvb_service->getCacheEntry(eDVBService::cDDPPID);
 			if (apid != -1)
 				return apid;
@@ -1978,6 +1999,9 @@ int eDVBServicePlay::getInfo(int w)
 			apid = m_dvb_service->getCacheEntry(eDVBService::cAACAPID);
 			if (apid != -1)
 				return apid;
+			apid = m_dvb_service->getCacheEntry(eDVBService::cDRAAPID);
+			if (apid != -1)
+				return apid;				
 		}
 		if (no_program_info)
 			return -1;
@@ -2126,10 +2150,14 @@ RESULT eDVBServicePlay::getTrackInfo(struct iAudioTrackInfo &info, unsigned int
 		info.m_description = "MPEG";
 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAC3)
 		info.m_description = "AC3";
+	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAC4)
+		info.m_description = "AC4";
 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atDDP)
 		info.m_description = "AC3+";
 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAAC)
 		info.m_description = "AAC";
+	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atDRA)
+		info.m_description = "DRA";
 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAACHE)
 		info.m_description = "AAC-HE";
 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atDTS)
@@ -2243,15 +2271,20 @@ int eDVBServicePlay::selectAudioStream(int i)
 	if (m_dvb_service && ((i != -1) || (program.audioStreams.size() == 1)
 		|| ((m_dvb_service->getCacheEntry(eDVBService::cMPEGAPID) == -1)
 		&& (m_dvb_service->getCacheEntry(eDVBService::cAC3PID)== -1)
+		&& (m_dvb_service->getCacheEntry(eDVBService::cAC4PID)== -1)
 		&& (m_dvb_service->getCacheEntry(eDVBService::cDDPPID)== -1)
 		&& (m_dvb_service->getCacheEntry(eDVBService::cAACHEAPID) == -1)
-		&& (m_dvb_service->getCacheEntry(eDVBService::cAACAPID) == -1))))
+		&& (m_dvb_service->getCacheEntry(eDVBService::cAACAPID) == -1)
+		&& (m_dvb_service->getCacheEntry(eDVBService::cDRAAPID) == -1))))
 	{
 		m_dvb_service->setCacheEntry(eDVBService::cMPEGAPID, apidtype == eDVBAudio::aMPEG ? apid : -1);
 		m_dvb_service->setCacheEntry(eDVBService::cAC3PID, apidtype == eDVBAudio::aAC3 ? apid : -1);
+		m_dvb_service->setCacheEntry(eDVBService::cAC4PID, apidtype == eDVBAudio::aAC4 ? apid : -1);
 		m_dvb_service->setCacheEntry(eDVBService::cDDPPID, apidtype == eDVBAudio::aDDP ? apid : -1);
 		m_dvb_service->setCacheEntry(eDVBService::cAACHEAPID, apidtype == eDVBAudio::aAACHE ? apid : -1);
 		m_dvb_service->setCacheEntry(eDVBService::cAACAPID, apidtype == eDVBAudio::aAAC ? apid : -1);
+		m_dvb_service->setCacheEntry(eDVBService::cDRAAPID, apidtype == eDVBAudio::aDRA ? apid : -1);
+
 	}
 
 	h.resetCachedProgram();
@@ -2965,15 +2998,16 @@ void eDVBServicePlay::updateDecoder(bool sendSeekableStateChanged)
 		if (!m_noaudio)
 		{
 			selectAudioStream();
+		}
+
 #if HAVE_AMLOGIC
-			m_decoder->setSyncPCR(pcrpid);
+		m_decoder->setSyncPCR(pcrpid);
 #else
-			if (!(m_is_pvr || m_is_stream || m_timeshift_active))
-				m_decoder->setSyncPCR(pcrpid);
-			else
-				m_decoder->setSyncPCR(-1);
+		if (!(m_is_pvr || m_is_stream || m_timeshift_active))
+			m_decoder->setSyncPCR(pcrpid);
+		else
+			m_decoder->setSyncPCR(-1);
 #endif
-		}
 
 		if (m_decoder_index == 0)
 		{
@@ -3274,8 +3308,8 @@ RESULT eDVBServicePlay::getCachedSubtitle(struct SubtitleTrack &track)
 		if (!h.getProgramInfo(program))
 		{
 			bool usecache = eConfigManager::getConfigBoolValue("config.autolanguage.subtitle_usecache");
-			int stream=program.defaultSubtitleStream;
-			int tmp = m_dvb_service->getCacheEntry(eDVBService::cSUBTITLE);
+			int stream = program.defaultSubtitleStream;
+			int tmp = usecache ? m_dvb_service->getCacheEntry(eDVBService::cSUBTITLE) : -1;
 
 			if (usecache || stream == -1)
 			{
@@ -3360,8 +3394,8 @@ RESULT eDVBServicePlay::getSubtitleList(std::vector<SubtitleTrack> &subtitlelist
 					}
 					break;
 				}
-				case 0x10 ... 0x13:
-				case 0x20 ... 0x23: // dvb subtitles
+				case 0x10 ... 0x15:
+				case 0x20 ... 0x25: // dvb subtitles
 				{
 					track.type = 0;
 					track.pid = it->pid;
@@ -3580,6 +3614,9 @@ void eDVBServicePlay::video_event(struct iTSMPEGDecoder::videoEvent event)
 		case iTSMPEGDecoder::videoEvent::eventProgressiveChanged:
 			m_event((iPlayableService*)this, evVideoProgressiveChanged);
 			break;
+		case iTSMPEGDecoder::videoEvent::eventGammaChanged:
+			m_event((iPlayableService*)this, evVideoGammaChanged);
+			break;
 		default:
 			break;
 	}
diff --git a/lib/service/servicedvbstream.cpp b/lib/service/servicedvbstream.cpp
index cd94a88..05ba87e 100644
--- a/lib/service/servicedvbstream.cpp
+++ b/lib/service/servicedvbstream.cpp
@@ -24,6 +24,9 @@ eDVBServiceStream::eDVBServiceStream()
 void eDVBServiceStream::serviceEvent(int event)
 {
 	eDebug("[eDVBServiceStream] STREAM service event %d", event);
+	if(event == eDVBServicePMTHandler::eventTuneFailed || event == eDVBServicePMTHandler::eventMisconfiguration || event == eDVBServicePMTHandler::eventNoResources)
+		eventUpdate(event);
+
 	switch (event)
 	{
 	case eDVBServicePMTHandler::eventTuned:
@@ -64,6 +67,8 @@ void eDVBServiceStream::serviceEvent(int event)
 		tuneFailed();
 		break;
 	}
+	if(event != eDVBServicePMTHandler::eventTuneFailed && event != eDVBServicePMTHandler::eventMisconfiguration && event != eDVBServicePMTHandler::eventNoResources)
+		eventUpdate(event);
 }
 
 int eDVBServiceStream::start(const char *serviceref, int fd)
@@ -159,7 +164,7 @@ int eDVBServiceStream::doRecord()
 	{
 		eDebug("[eDVBServiceStream] getting program info failed.");
 	}
-	else
+	else if(m_record_no_pids == 0)
 	{
 		std::set<int> pids_to_record;
 
diff --git a/lib/service/servicedvbstream.h b/lib/service/servicedvbstream.h
index e4819fd..f847f9b 100644
--- a/lib/service/servicedvbstream.h
+++ b/lib/service/servicedvbstream.h
@@ -17,7 +17,7 @@ public:
 	int start(const char *serviceref, int fd);
 	int stop();
 
-private:
+protected:
 	enum { stateIdle, statePrepared, stateRecording };
 	int m_state, m_want_record;
 	bool m_stream_ecm, m_stream_eit, m_stream_ait;
@@ -48,7 +48,8 @@ private:
 
 	virtual void streamStopped() {}
 	virtual void tuneFailed() {}
-
+	virtual void eventUpdate(int event){}
+ 	int m_record_no_pids = 0;	
 	void recordPids(std::set<int> pids_to_record, int timing_pid, int timing_stream_type, iDVBTSRecorder::timing_pid_type timing_pid_type);
 	bool recordCachedPids();
 };
diff --git a/lib/service/servicehdmi.cpp b/lib/service/servicehdmi.cpp
index 1579df9..4222f95 100644
--- a/lib/service/servicehdmi.cpp
+++ b/lib/service/servicehdmi.cpp
@@ -249,7 +249,16 @@ int eServiceHDMIRecord::doPrepare()
 {
 	if (!m_simulate && m_encoder_fd < 0)
 	{
-		if (eEncoder::getInstance()) m_encoder_fd = eEncoder::getInstance()->allocateEncoder(m_ref.toString(), 8 * 1024 * 1024, 1280, 720, 25000, false, 0);
+		if (eEncoder::getInstance())
+		{
+			int bitrate = eConfigManager::getConfigIntValue("config.hdmirecord.bitrate", 8 * 1024 * 1024);
+			int width = eConfigManager::getConfigIntValue("config.hdmirecord.width", 1280);
+			int height = eConfigManager::getConfigIntValue("config.hdmirecord.height", 720);
+			int framerate = eConfigManager::getConfigIntValue("config.hdmirecord.framerate", 50000);
+			int interlaced = eConfigManager::getConfigIntValue("config.hdmirecord.interlaced", 0);
+			int aspectratio = eConfigManager::getConfigIntValue("config.hdmirecord.aspectratio", 0);
+			m_encoder_fd = eEncoder::getInstance()->allocateEncoder(m_ref.toString(), bitrate, width, height, framerate, interlaced, aspectratio);
+		}
 		if (m_encoder_fd < 0) return -1;
 	}
 	m_state = statePrepared;
diff --git a/lib/service/servicemp3.cpp b/lib/service/servicemp3.cpp
index d540474..3a88b0a 100644
--- a/lib/service/servicemp3.cpp
+++ b/lib/service/servicemp3.cpp
@@ -23,6 +23,12 @@
 
 #include <sys/time.h>
 
+#if HAVE_ALIEN5
+extern "C" {
+#include <codec.h>
+}
+#endif
+
 #define HTTP_TIMEOUT 10
 
 /*
@@ -504,7 +510,7 @@ eServiceMP3::eServiceMP3(eServiceReference ref):
 	m_last_seek_pos = 0;
 	m_media_lenght = 0;
 #endif
-	m_useragent = "Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;OpenPlus;;;)";
+	m_useragent = "Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;openPlus;;;)";
 	m_extra_headers = "";
 	m_download_buffer_path = "";
 	m_prev_decoder_time = -1;
@@ -594,6 +600,11 @@ eServiceMP3::eServiceMP3(eServiceReference ref):
 		m_sourceinfo.containertype = ctMP4;
 		m_sourceinfo.audiotype = atAAC;
 	}
+	else if ( strcasecmp(ext, ".dra") == 0 )
+	{
+		m_sourceinfo.containertype = ctDRA;
+		m_sourceinfo.audiotype = atDRA;
+	}
 	else if ( strcasecmp(ext, ".m3u8") == 0 )
 		m_sourceinfo.is_hls = TRUE;
 	else if ( strcasecmp(ext, ".mp3") == 0 )
@@ -722,6 +733,9 @@ eServiceMP3::eServiceMP3(eServiceReference ref):
 			g_object_set(dvb_videosink, "e2-async", FALSE, NULL);
 			g_object_set(m_gst_playbin, "video-sink", dvb_videosink, NULL);
 		}
+#if HAVE_ALIEN5
+		aml_set_mediaplay_source((void *)m_gst_playbin,(int)m_sourceinfo.is_audio);
+#endif
 		/*
 		 * avoid video conversion, let the dvbmediasink handle that using native video flag
 		 * volume control is done by hardware, do not use soft volume flag
@@ -1318,7 +1332,7 @@ RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 		return -1;
 
 	//eDebug("[eServiceMP3]  seekRelative direction %d, pts_t to %" G_GINT64_FORMAT, direction, (gint64)to);
-	gint64 ppos = 0;
+	pts_t ppos = 0;
 #if GST_VERSION_MAJOR >= 1
 	//m_seeking_or_paused = true;
 	if (direction > 0)
diff --git a/lib/service/servicemp3.h b/lib/service/servicemp3.h
index b4fc9a9..91affc4 100644
--- a/lib/service/servicemp3.h
+++ b/lib/service/servicemp3.h
@@ -117,9 +117,9 @@ public:
 
 typedef struct _GstElement GstElement;
 
-typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
+typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA, atDRA } audiotype_t;
 typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
-typedef enum { ctNone, ctMPEGTS, ctMPEGPS, ctMKV, ctAVI, ctMP4, ctVCD, ctCDA, ctASF, ctOGG, ctWEBM } containertype_t;
+typedef enum { ctNone, ctMPEGTS, ctMPEGPS, ctMKV, ctAVI, ctMP4, ctVCD, ctCDA, ctASF, ctOGG, ctWEBM, ctDRA } containertype_t;
 
 class eServiceMP3: public iPlayableService, public iPauseableService,
 	public iServiceInformation, public iSeekableService, public iAudioTrackSelection, public iAudioChannelSelection,
diff --git a/main/Makefile.am b/main/Makefile.am
index 894f5e1..a9103c2 100644
--- a/main/Makefile.am
+++ b/main/Makefile.am
@@ -47,6 +47,7 @@ enigma2_LDADD = \
 	@AMADEC_LIBS@ \
 	@DVBCSA_LIBS@ \
 	@AVAHI_LIBS@ \
+	@LIBHIACCEL_LIBS@ \
 	-ltuxtxt -ltuxtxt32bpp -lcrypt -lrt -ldl
 
 enigma2_LDFLAGS = -Wl,--export-dynamic
diff --git a/main/bsod.cpp b/main/bsod.cpp
index ae6467c..e0ebeae 100644
--- a/main/bsod.cpp
+++ b/main/bsod.cpp
@@ -23,7 +23,7 @@
 
 static const char *crash_emailaddr =
 #ifndef CRASH_EMAILADDR
-	"the OpenPlus forum";
+	"the openPlus forum";
 #else
 	CRASH_EMAILADDR;
 #endif
@@ -163,7 +163,7 @@ void bsodFatal(const char *component)
 		strftime(tm_str, sizeof(tm_str), "%a %b %_d %T %Y", &tm);
 
 		fprintf(f,
-			"OpenPlus Enigma2 crash log\n\n"
+			"openPlus Enigma2 crash log\n\n"
 			"crashdate=%s\n"
 			"compiledate=%s\n"
 			"skin=%s\n"
diff --git a/main/enigma.cpp b/main/enigma.cpp
index 1239bd9..159c9ed 100644
--- a/main/enigma.cpp
+++ b/main/enigma.cpp
@@ -43,6 +43,8 @@
 #include <lib/base/eerroroutput.h>
 ePtr<eErrorOutput> m_erroroutput;
 
+bool verbose = false;
+
 #ifdef OBJECT_DEBUG
 int object_total_remaining;
 
@@ -265,6 +267,11 @@ int main(int argc, char **argv)
 		{
 			logOutputColors = 0;
 		}
+
+		if (!(strcmp(argv[i], "--verbose")))
+		{
+			verbose = true;
+		}
 	}
 
 	m_erroroutput = new eErrorOutput();
diff --git a/tools/Makefile.am b/tools/Makefile.am
index 9e69b46..52c42e1 100644
--- a/tools/Makefile.am
+++ b/tools/Makefile.am
@@ -1,6 +1,8 @@
 bin_SCRIPTS = enigma2.sh
 lib_LTLIBRARIES = libopen.la
 
+CFLAGS += -DLIBC_SO=\"$(base_libdir)/libc.so.6\"
+
 libopen_la_SOURCES = libopen.c
 libopen_la_LIBADD = @LIBDL_LIBS@
 
diff --git a/tools/enigma2.sh.in b/tools/enigma2.sh.in
index 49e1af1..be355a3 100755
--- a/tools/enigma2.sh.in
+++ b/tools/enigma2.sh.in
@@ -34,6 +34,15 @@ if [ ! "$(grep config.misc.firstrun /etc/enigma2/settings)" == "config.misc.firs
 	rm -rf /etc/enigma2/key.pem &
 fi
 
+if [ -e /proc/stb/info/boxtype ]; then
+	stbcheck=`cat /proc/stb/info/boxtype`
+	if [ $stbcheck == "sf8008" ] || [ $stbcheck == "ustym4kpro" ] || [ $stbcheck == "cc1" ]; then
+		count=`ps -ef |grep libreader |grep -v "grep" |wc -l`
+		if [ 0 == $count ];then
+			libreader 720P_50
+		fi
+	fi
+fi
 if [ -x @bindir@/showiframe ]; then
 	if [ -e /proc/stb/info/boxtype ]; then
 		stbcheck=`cat /proc/stb/info/boxtype | cut -c1-2`
@@ -73,14 +82,14 @@ fi
 
 #check for sundtek tuner helper lib
 if [ -e /opt/lib/libmediaclient.so ]; then
-	LIBS="/opt/lib/libmediaclient.so /usr/lib/libopen.so.0.0.0"
+	LIBS="/opt/lib/libmediaclient.so @libdir@/libopen.so.0.0.0"
 else
-	LIBS="/usr/lib/libopen.so.0.0.0"
+	LIBS="@libdir@/libopen.so.0.0.0"
 fi
 
 #check for specific pagecache helper lib
-if [ -e /usr/lib/libpagecache.so ]; then
-	LIBS="$LIBS /usr/lib/libpagecache.so"
+if [ -e @libdir@/libpagecache.so ]; then
+	LIBS="$LIBS @libdir@/libpagecache.so"
 fi
 
 #check for receiver specific passthrough helper lib
@@ -116,6 +125,11 @@ sysctl -p
 (sleep 2; echo "enigma2 is the main pvr application... adjust oom score!"; PID=$(pidof enigma2); \
         [ -e /proc/$PID/oom_score_adj ] && echo "-999" > /proc/$PID/oom_score_adj || echo "-17" > /proc/$PID/oom_adj;) &
 
+VERBOSE=''
+if [ "$(grep config.log.level /etc/enigma2/settings)" == "config.log.level=3" ]; then
+	VERBOSE='--verbose'
+fi
+
 if [ "$(grep config.crash.enabledebug /etc/enigma2/settings)" == "config.crash.enabledebug=true" ]; then
 	RANDOMIZE1970=''
 	time=`date +%Y` ;
@@ -127,13 +141,13 @@ if [ "$(grep config.crash.enabledebug /etc/enigma2/settings)" == "config.crash.e
 	if [ "$(grep config.crash.debug_path= /etc/enigma2/settings | sed 's/config.crash.debug_path=//g')" != "" -a -d "$(grep config.crash.debug_path= /etc/enigma2/settings | sed 's/config.crash.debug_path=//g')" ]; then
 		LOGFOLDER=$(grep config.crash.debug_path= /etc/enigma2/settings | sed 's/config.crash.debug_path=//g')
 	fi
-	LD_PRELOAD=$LIBS @bindir@/enigma2 --debug-no-color &> ${LOGFOLDER}Enigma2-debug-$(date +%Y%m%d_%H-%M-%S)${RANDOMIZE1970}.log
+	LD_PRELOAD=$LIBS @bindir@/enigma2 --debug-no-color $VERBOSE &> ${LOGFOLDER}Enigma2-debug-$(date +%Y%m%d_%H-%M-%S)${RANDOMIZE1970}.log
 else
 	# in case $TERM is "linux" the serial output is activated - discard debug output
 	if [ "$TERM" = linux ]; then
-		LD_PRELOAD=$LIBS @bindir@/enigma2 2> /dev/null
+		LD_PRELOAD=$LIBS @bindir@/enigma2 $VERBOSE 2> /dev/null
 	else
-		LD_PRELOAD=$LIBS @bindir@/enigma2
+		LD_PRELOAD=$LIBS @bindir@/enigma2 $VERBOSE
 	fi
 fi
 
@@ -153,21 +167,16 @@ if [ "$ret" -ne "1" ]; then
 		if [ $stbcheck == "u5" ]; then
 			killall -9 showiframe; sleep 5
 		fi
+		stbcheck=`cat /proc/stb/info/boxtype`
+		if [ $stbcheck == "sf8008" ] || [ $stbcheck == "ustym4kpro" ] || [ $stbcheck == "cc1" ] ; then
+			killall -9 libreader; sleep 5
+		fi
 	fi
 fi
 
 case $ret in
 	1)
-		if [ -e /proc/stb/info/boxtype ]; then
-			stbcheck=`cat /proc/stb/info/boxtype | cut -c1-2`
-			if [ $stbcheck == "u5" ]; then
-				/usr/bin/hihalt
-			else
-				/sbin/halt
-			fi
-		else
-			/sbin/halt
-		fi
+		/sbin/halt
 		;;
 	2)
 		if [ -f /proc/stb/fp/force_restart ]; then
@@ -192,17 +201,17 @@ case $ret in
 		/sbin/reboot
 		;;
 	42)
-		python /usr/lib/enigma2/python/upgrade.pyo
+		python @libdir@/enigma2/python/upgrade.pyo
 		;;
 	43)
 		init 1
 		;;
 	44)
 		# little hack but it will be fixed soon in drivers
-		/usr/lib/enigma2/python/Plugins/SystemPlugins/MICOMUpgrade/bin/fbclear
-		/usr/bin/showiframe /usr/lib/enigma2/python/Plugins/SystemPlugins/MICOMUpgrade/wait.mvi
+		@libdir@/enigma2/python/Plugins/SystemPlugins/MICOMUpgrade/bin/fbclear
+		/usr/bin/showiframe @libdir@/enigma2/python/Plugins/SystemPlugins/MICOMUpgrade/wait.mvi
 		echo fpupload >/proc/vfd && sleep 3 && dd bs=256k if=/tmp/micom.bin of=/dev/mcu
-		/usr/bin/showiframe /usr/lib/enigma2/python/Plugins/SystemPlugins/MICOMUpgrade/reboot.mvi
+		/usr/bin/showiframe @libdir@/enigma2/python/Plugins/SystemPlugins/MICOMUpgrade/reboot.mvi
 		# Wait forever for the user to power off
 		while(true) ; do sleep 60 ; done
 		;;
diff --git a/tools/libopen.c b/tools/libopen.c
index d7c1b17..632fee8 100644
--- a/tools/libopen.c
+++ b/tools/libopen.c
@@ -17,7 +17,7 @@ int open64(const char *pathname, int flags, ...)
 	{
 		void *handle;
 		char *error;
-		handle = dlopen("/lib/libc.so.6", RTLD_LAZY);
+		handle = dlopen(LIBC_SO, RTLD_LAZY);
 		if (!handle)
 		{
 			fputs(dlerror(), stderr);
@@ -55,7 +55,7 @@ int open(const char *pathname, int flags, ...)
 	{
 		void *handle;
 		char *error;
-		handle = dlopen("/lib/libc.so.6", RTLD_LAZY);
+		handle = dlopen(LIBC_SO, RTLD_LAZY);
 		if (!handle)
 		{
 			fputs(dlerror(), stderr);
@@ -93,7 +93,7 @@ FILE *fopen64(const char *pathname, const char *mode)
 	{
 		void *handle;
 		char *error;
-		handle = dlopen("/lib/libc.so.6", RTLD_LAZY);
+		handle = dlopen(LIBC_SO, RTLD_LAZY);
 		if (!handle)
 		{
 			fputs(dlerror(), stderr);
@@ -132,7 +132,7 @@ FILE *fopen(const char *pathname, const char *mode)
 	{
 		void *handle;
 		char *error;
-		handle = dlopen("/lib/libc.so.6", RTLD_LAZY);
+		handle = dlopen(LIBC_SO, RTLD_LAZY);
 		if (!handle)
 		{
 			fputs(dlerror(), stderr);
@@ -171,7 +171,7 @@ int socket(int domain, int type, int protocol)
 	{
 		void *handle;
 		char *error;
-		handle = dlopen("/lib/libc.so.6", RTLD_LAZY);
+		handle = dlopen(LIBC_SO, RTLD_LAZY);
 		if (!handle)
 		{
 			fputs(dlerror(), stderr);
@@ -209,7 +209,7 @@ int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
 	{
 		void *handle;
 		char *error;
-		handle = dlopen("/lib/libc.so.6", RTLD_LAZY);
+		handle = dlopen(LIBC_SO, RTLD_LAZY);
 		if (!handle)
 		{
 			fputs(dlerror(), stderr);
@@ -237,7 +237,6 @@ int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
 	return fd;
 }
 
-
 int socketpair(int d, int type, int protocol, int sv[2])
 {
 	typedef int (*FUNC_PTR) (int d, int type, int protocol, int sv[2]);
@@ -247,7 +246,7 @@ int socketpair(int d, int type, int protocol, int sv[2])
 	{
 		void *handle;
 		char *error;
-		handle = dlopen("/lib/libc.so.6", RTLD_LAZY);
+		handle = dlopen(LIBC_SO, RTLD_LAZY);
 		if (!handle)
 		{
 			fputs(dlerror(), stderr);
@@ -290,7 +289,7 @@ int pipe(int modus[2])
 	{
 		void *handle;
 		char *error;
-		handle = dlopen("/lib/libc.so.6", RTLD_LAZY);
+		handle = dlopen(LIBC_SO, RTLD_LAZY);
 		if (!handle)
 		{
 			fputs(dlerror(), stderr);
